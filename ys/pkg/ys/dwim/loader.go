// Code generated by glojure codegen. DO NOT EDIT.

package dwim

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
	regexp4 "regexp"
)

func init() {
	runtime.RegisterNSLoader("ys/dwim", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "ys.dwim"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__PLUS__PLUS_filter := lang.NewSymbol("++filter")
	sym__PLUS__PLUS_filterv := lang.NewSymbol("++filterv")
	sym__PLUS__PLUS_keep := lang.NewSymbol("++keep")
	sym__PLUS__PLUS_map := lang.NewSymbol("++map")
	sym__PLUS__PLUS_mapv := lang.NewSymbol("++mapv")
	sym__PLUS__PLUS_remove := lang.NewSymbol("++remove")
	sym__PLUS__PLUS_replace := lang.NewSymbol("++replace")
	sym__PLUS__PLUS_take_DASH_while := lang.NewSymbol("++take-while")
	sym__PLUS_apply := lang.NewSymbol("+apply")
	sym__PLUS_cons := lang.NewSymbol("+cons")
	sym__PLUS_contains_QMARK_ := lang.NewSymbol("+contains?")
	sym__PLUS_drop := lang.NewSymbol("+drop")
	sym__PLUS_drop_DASH_last := lang.NewSymbol("+drop-last")
	sym__PLUS_drop_DASH_while := lang.NewSymbol("+drop-while")
	sym__PLUS_escape := lang.NewSymbol("+escape")
	sym__PLUS_every_QMARK_ := lang.NewSymbol("+every?")
	sym__PLUS_filter := lang.NewSymbol("+filter")
	sym__PLUS_filterv := lang.NewSymbol("+filterv")
	sym__PLUS_format := lang.NewSymbol("+format")
	sym__PLUS_interpose := lang.NewSymbol("+interpose")
	sym__PLUS_keep := lang.NewSymbol("+keep")
	sym__PLUS_map := lang.NewSymbol("+map")
	sym__PLUS_mapcat := lang.NewSymbol("+mapcat")
	sym__PLUS_mapv := lang.NewSymbol("+mapv")
	sym__PLUS_not_DASH_any_QMARK_ := lang.NewSymbol("+not-any?")
	sym__PLUS_nth := lang.NewSymbol("+nth")
	sym__PLUS_partition := lang.NewSymbol("+partition")
	sym__PLUS_random_DASH_sample := lang.NewSymbol("+random-sample")
	sym__PLUS_re_DASH_find := lang.NewSymbol("+re-find")
	sym__PLUS_re_DASH_matches := lang.NewSymbol("+re-matches")
	sym__PLUS_re_DASH_seq := lang.NewSymbol("+re-seq")
	sym__PLUS_reduce := lang.NewSymbol("+reduce")
	sym__PLUS_remove := lang.NewSymbol("+remove")
	sym__PLUS_repeat := lang.NewSymbol("+repeat")
	sym__PLUS_replace := lang.NewSymbol("+replace")
	sym__PLUS_some := lang.NewSymbol("+some")
	sym__PLUS_sort := lang.NewSymbol("+sort")
	sym__PLUS_sort_DASH_by := lang.NewSymbol("+sort-by")
	sym__PLUS_split_DASH_at := lang.NewSymbol("+split-at")
	sym__PLUS_split_DASH_with := lang.NewSymbol("+split-with")
	sym__PLUS_take := lang.NewSymbol("+take")
	sym__PLUS_take_DASH_last := lang.NewSymbol("+take-last")
	sym__PLUS_take_DASH_while := lang.NewSymbol("+take-while")
	sym__EQ_ := lang.NewSymbol("=")
	sym_a := lang.NewSymbol("a")
	sym_apply := lang.NewSymbol("apply")
	sym_b := lang.NewSymbol("b")
	sym_c := lang.NewSymbol("c")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH_apply := lang.NewSymbol("clojure.core/apply")
	sym_clojure_DOT_core_SLASH_concat := lang.NewSymbol("clojure.core/concat")
	sym_clojure_DOT_core_SLASH_defn := lang.NewSymbol("clojure.core/defn")
	sym_clojure_DOT_string := lang.NewSymbol("clojure.string")
	sym_concat := lang.NewSymbol("concat")
	sym_cons := lang.NewSymbol("cons")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_drop := lang.NewSymbol("drop")
	sym_drop_DASH_last := lang.NewSymbol("drop-last")
	sym_drop_DASH_while := lang.NewSymbol("drop-while")
	sym_dwim := lang.NewSymbol("dwim")
	sym_escape := lang.NewSymbol("escape")
	sym_every_QMARK_ := lang.NewSymbol("every?")
	sym_f := lang.NewSymbol("f")
	sym_filter := lang.NewSymbol("filter")
	sym_filterv := lang.NewSymbol("filterv")
	sym_format := lang.NewSymbol("format")
	sym_idfn := lang.NewSymbol("idfn")
	sym_if := lang.NewSymbol("if")
	sym_ifn_QMARK_ := lang.NewSymbol("ifn?")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_interpose := lang.NewSymbol("interpose")
	sym_keep := lang.NewSymbol("keep")
	sym_list := lang.NewSymbol("list")
	sym_map := lang.NewSymbol("map")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_mapcat := lang.NewSymbol("mapcat")
	sym_mapv := lang.NewSymbol("mapv")
	sym_name := lang.NewSymbol("name")
	sym_not_DASH_any_QMARK_ := lang.NewSymbol("not-any?")
	sym_nth := lang.NewSymbol("nth")
	sym_partition := lang.NewSymbol("partition")
	sym_random_DASH_sample := lang.NewSymbol("random-sample")
	sym_re_DASH_find := lang.NewSymbol("re-find")
	sym_re_DASH_matches := lang.NewSymbol("re-matches")
	sym_re_DASH_seq := lang.NewSymbol("re-seq")
	sym_reduce := lang.NewSymbol("reduce")
	sym_regex_DASH_to_DASH_fn := lang.NewSymbol("regex-to-fn")
	sym_regex_QMARK_ := lang.NewSymbol("regex?")
	sym_remove := lang.NewSymbol("remove")
	sym_repeat := lang.NewSymbol("repeat")
	sym_replace := lang.NewSymbol("replace")
	sym_resolve := lang.NewSymbol("resolve")
	sym_seq := lang.NewSymbol("seq")
	sym_seqable_QMARK_ := lang.NewSymbol("seqable?")
	sym_sequential_QMARK_ := lang.NewSymbol("sequential?")
	sym_some := lang.NewSymbol("some")
	sym_sort := lang.NewSymbol("sort")
	sym_sort_DASH_by := lang.NewSymbol("sort-by")
	sym_split_DASH_at := lang.NewSymbol("split-at")
	sym_split_DASH_with := lang.NewSymbol("split-with")
	sym_str := lang.NewSymbol("str")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_symbol := lang.NewSymbol("symbol")
	sym_take := lang.NewSymbol("take")
	sym_take_DASH_last := lang.NewSymbol("take-last")
	sym_take_DASH_while := lang.NewSymbol("take-while")
	sym_type := lang.NewSymbol("type")
	sym_vector := lang.NewSymbol("vector")
	sym_x := lang.NewSymbol("x")
	sym_x__0__auto__ := lang.NewSymbol("x__0__auto__")
	sym_xs__1__auto__ := lang.NewSymbol("xs__1__auto__")
	sym_xs__2__auto__ := lang.NewSymbol("xs__2__auto__")
	sym_y__1__auto__ := lang.NewSymbol("y__1__auto__")
	sym_ys_DOT_dwim := lang.NewSymbol("ys.dwim")
	sym_z__2__auto__ := lang.NewSymbol("z__2__auto__")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/cons
	var_clojure_DOT_core_cons := lang.InternVarName(sym_clojure_DOT_core, sym_cons)
	// var clojure.core/contains?
	var_clojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_contains_QMARK_)
	// var clojure.core/drop
	var_clojure_DOT_core_drop := lang.InternVarName(sym_clojure_DOT_core, sym_drop)
	// var clojure.core/drop-last
	var_clojure_DOT_core_drop_DASH_last := lang.InternVarName(sym_clojure_DOT_core, sym_drop_DASH_last)
	// var clojure.core/drop-while
	var_clojure_DOT_core_drop_DASH_while := lang.InternVarName(sym_clojure_DOT_core, sym_drop_DASH_while)
	// var clojure.core/every?
	var_clojure_DOT_core_every_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_every_QMARK_)
	// var clojure.core/filter
	var_clojure_DOT_core_filter := lang.InternVarName(sym_clojure_DOT_core, sym_filter)
	// var clojure.core/filterv
	var_clojure_DOT_core_filterv := lang.InternVarName(sym_clojure_DOT_core, sym_filterv)
	// var clojure.core/format
	var_clojure_DOT_core_format := lang.InternVarName(sym_clojure_DOT_core, sym_format)
	// var clojure.core/ifn?
	var_clojure_DOT_core_ifn_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_ifn_QMARK_)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/interpose
	var_clojure_DOT_core_interpose := lang.InternVarName(sym_clojure_DOT_core, sym_interpose)
	// var clojure.core/keep
	var_clojure_DOT_core_keep := lang.InternVarName(sym_clojure_DOT_core, sym_keep)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/map?
	var_clojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_map_QMARK_)
	// var clojure.core/mapcat
	var_clojure_DOT_core_mapcat := lang.InternVarName(sym_clojure_DOT_core, sym_mapcat)
	// var clojure.core/mapv
	var_clojure_DOT_core_mapv := lang.InternVarName(sym_clojure_DOT_core, sym_mapv)
	// var clojure.core/not-any?
	var_clojure_DOT_core_not_DASH_any_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_not_DASH_any_QMARK_)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/partition
	var_clojure_DOT_core_partition := lang.InternVarName(sym_clojure_DOT_core, sym_partition)
	// var clojure.core/random-sample
	var_clojure_DOT_core_random_DASH_sample := lang.InternVarName(sym_clojure_DOT_core, sym_random_DASH_sample)
	// var clojure.core/re-find
	var_clojure_DOT_core_re_DASH_find := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_find)
	// var clojure.core/re-matches
	var_clojure_DOT_core_re_DASH_matches := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_matches)
	// var clojure.core/re-seq
	var_clojure_DOT_core_re_DASH_seq := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_seq)
	// var clojure.core/reduce
	var_clojure_DOT_core_reduce := lang.InternVarName(sym_clojure_DOT_core, sym_reduce)
	// var clojure.core/remove
	var_clojure_DOT_core_remove := lang.InternVarName(sym_clojure_DOT_core, sym_remove)
	// var clojure.core/repeat
	var_clojure_DOT_core_repeat := lang.InternVarName(sym_clojure_DOT_core, sym_repeat)
	// var clojure.core/resolve
	var_clojure_DOT_core_resolve := lang.InternVarName(sym_clojure_DOT_core, sym_resolve)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/seqable?
	var_clojure_DOT_core_seqable_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seqable_QMARK_)
	// var clojure.core/sequential?
	var_clojure_DOT_core_sequential_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_sequential_QMARK_)
	// var clojure.core/some
	var_clojure_DOT_core_some := lang.InternVarName(sym_clojure_DOT_core, sym_some)
	// var clojure.core/sort
	var_clojure_DOT_core_sort := lang.InternVarName(sym_clojure_DOT_core, sym_sort)
	// var clojure.core/sort-by
	var_clojure_DOT_core_sort_DASH_by := lang.InternVarName(sym_clojure_DOT_core, sym_sort_DASH_by)
	// var clojure.core/split-at
	var_clojure_DOT_core_split_DASH_at := lang.InternVarName(sym_clojure_DOT_core, sym_split_DASH_at)
	// var clojure.core/split-with
	var_clojure_DOT_core_split_DASH_with := lang.InternVarName(sym_clojure_DOT_core, sym_split_DASH_with)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/string?
	var_clojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_string_QMARK_)
	// var clojure.core/symbol
	var_clojure_DOT_core_symbol := lang.InternVarName(sym_clojure_DOT_core, sym_symbol)
	// var clojure.core/take
	var_clojure_DOT_core_take := lang.InternVarName(sym_clojure_DOT_core, sym_take)
	// var clojure.core/take-last
	var_clojure_DOT_core_take_DASH_last := lang.InternVarName(sym_clojure_DOT_core, sym_take_DASH_last)
	// var clojure.core/take-while
	var_clojure_DOT_core_take_DASH_while := lang.InternVarName(sym_clojure_DOT_core, sym_take_DASH_while)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.string/escape
	var_clojure_DOT_string_escape := lang.InternVarName(sym_clojure_DOT_string, sym_escape)
	// var clojure.string/replace
	var_clojure_DOT_string_replace := lang.InternVarName(sym_clojure_DOT_string, sym_replace)
	// var ys.dwim/++filter
	var_ys_DOT_dwim__PLUS__PLUS_filter := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_filter)
	// var ys.dwim/++filterv
	var_ys_DOT_dwim__PLUS__PLUS_filterv := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_filterv)
	// var ys.dwim/++keep
	var_ys_DOT_dwim__PLUS__PLUS_keep := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_keep)
	// var ys.dwim/++map
	var_ys_DOT_dwim__PLUS__PLUS_map := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_map)
	// var ys.dwim/++mapv
	var_ys_DOT_dwim__PLUS__PLUS_mapv := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_mapv)
	// var ys.dwim/++remove
	var_ys_DOT_dwim__PLUS__PLUS_remove := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_remove)
	// var ys.dwim/++replace
	var_ys_DOT_dwim__PLUS__PLUS_replace := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_replace)
	// var ys.dwim/++take-while
	var_ys_DOT_dwim__PLUS__PLUS_take_DASH_while := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS__PLUS_take_DASH_while)
	// var ys.dwim/+apply
	var_ys_DOT_dwim__PLUS_apply := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_apply)
	// var ys.dwim/+cons
	var_ys_DOT_dwim__PLUS_cons := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_cons)
	// var ys.dwim/+contains?
	var_ys_DOT_dwim__PLUS_contains_QMARK_ := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_contains_QMARK_)
	// var ys.dwim/+drop
	var_ys_DOT_dwim__PLUS_drop := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_drop)
	// var ys.dwim/+drop-last
	var_ys_DOT_dwim__PLUS_drop_DASH_last := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_drop_DASH_last)
	// var ys.dwim/+drop-while
	var_ys_DOT_dwim__PLUS_drop_DASH_while := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_drop_DASH_while)
	// var ys.dwim/+escape
	var_ys_DOT_dwim__PLUS_escape := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_escape)
	// var ys.dwim/+every?
	var_ys_DOT_dwim__PLUS_every_QMARK_ := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_every_QMARK_)
	// var ys.dwim/+filter
	var_ys_DOT_dwim__PLUS_filter := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_filter)
	// var ys.dwim/+filterv
	var_ys_DOT_dwim__PLUS_filterv := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_filterv)
	// var ys.dwim/+format
	var_ys_DOT_dwim__PLUS_format := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_format)
	// var ys.dwim/+interpose
	var_ys_DOT_dwim__PLUS_interpose := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_interpose)
	// var ys.dwim/+keep
	var_ys_DOT_dwim__PLUS_keep := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_keep)
	// var ys.dwim/+map
	var_ys_DOT_dwim__PLUS_map := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_map)
	// var ys.dwim/+mapcat
	var_ys_DOT_dwim__PLUS_mapcat := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_mapcat)
	// var ys.dwim/+mapv
	var_ys_DOT_dwim__PLUS_mapv := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_mapv)
	// var ys.dwim/+not-any?
	var_ys_DOT_dwim__PLUS_not_DASH_any_QMARK_ := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_not_DASH_any_QMARK_)
	// var ys.dwim/+nth
	var_ys_DOT_dwim__PLUS_nth := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_nth)
	// var ys.dwim/+partition
	var_ys_DOT_dwim__PLUS_partition := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_partition)
	// var ys.dwim/+random-sample
	var_ys_DOT_dwim__PLUS_random_DASH_sample := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_random_DASH_sample)
	// var ys.dwim/+re-find
	var_ys_DOT_dwim__PLUS_re_DASH_find := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_re_DASH_find)
	// var ys.dwim/+re-matches
	var_ys_DOT_dwim__PLUS_re_DASH_matches := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_re_DASH_matches)
	// var ys.dwim/+re-seq
	var_ys_DOT_dwim__PLUS_re_DASH_seq := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_re_DASH_seq)
	// var ys.dwim/+reduce
	var_ys_DOT_dwim__PLUS_reduce := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_reduce)
	// var ys.dwim/+remove
	var_ys_DOT_dwim__PLUS_remove := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_remove)
	// var ys.dwim/+repeat
	var_ys_DOT_dwim__PLUS_repeat := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_repeat)
	// var ys.dwim/+replace
	var_ys_DOT_dwim__PLUS_replace := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_replace)
	// var ys.dwim/+some
	var_ys_DOT_dwim__PLUS_some := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_some)
	// var ys.dwim/+sort
	var_ys_DOT_dwim__PLUS_sort := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_sort)
	// var ys.dwim/+sort-by
	var_ys_DOT_dwim__PLUS_sort_DASH_by := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_sort_DASH_by)
	// var ys.dwim/+split-at
	var_ys_DOT_dwim__PLUS_split_DASH_at := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_split_DASH_at)
	// var ys.dwim/+split-with
	var_ys_DOT_dwim__PLUS_split_DASH_with := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_split_DASH_with)
	// var ys.dwim/+take
	var_ys_DOT_dwim__PLUS_take := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_take)
	// var ys.dwim/+take-last
	var_ys_DOT_dwim__PLUS_take_DASH_last := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_take_DASH_last)
	// var ys.dwim/+take-while
	var_ys_DOT_dwim__PLUS_take_DASH_while := lang.InternVarName(sym_ys_DOT_dwim, sym__PLUS_take_DASH_while)
	// var ys.dwim/dwim
	var_ys_DOT_dwim_dwim := lang.InternVarName(sym_ys_DOT_dwim, sym_dwim)
	// var ys.dwim/regex-to-fn
	var_ys_DOT_dwim_regex_DASH_to_DASH_fn := lang.InternVarName(sym_ys_DOT_dwim, sym_regex_DASH_to_DASH_fn)
	// var ys.dwim/regex?
	var_ys_DOT_dwim_regex_QMARK_ := lang.InternVarName(sym_ys_DOT_dwim, sym_regex_QMARK_)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_ys_DOT_dwim)
	_ = ns
	// ++filter
	{
		tmp0 := sym__PLUS__PLUS_filter.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(19), kw_column, int(7), kw_end_DASH_line, int(19), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_ys_DOT_dwim_regex_DASH_to_DASH_fn)
			tmp5 := checkDerefVar(var_clojure_DOT_core_filter)
			tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_filter = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_filter.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++filterv
	{
		tmp0 := sym__PLUS__PLUS_filterv.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(21), kw_column, int(7), kw_end_DASH_line, int(21), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_ys_DOT_dwim_regex_DASH_to_DASH_fn)
			tmp5 := checkDerefVar(var_clojure_DOT_core_filterv)
			tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_filterv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_filterv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++keep
	{
		tmp0 := sym__PLUS__PLUS_keep.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(23), kw_column, int(7), kw_end_DASH_line, int(23), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_ys_DOT_dwim_regex_DASH_to_DASH_fn)
			tmp5 := checkDerefVar(var_clojure_DOT_core_keep)
			tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_keep = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_keep.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++map
	{
		tmp0 := sym__PLUS__PLUS_map.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(25), kw_column, int(7), kw_end_DASH_line, int(25), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(var_clojure_DOT_core_ifn_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "or__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v2})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = v13
						} else {
							tmp15 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
							tmp16 := lang.Apply(tmp15, []any{v2})
							tmp14 = tmp16
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_clojure_DOT_core_map)
				tmp7 := lang.Apply(tmp6, []any{v3, v2})
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_clojure_DOT_core_map)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++mapv
	{
		tmp0 := sym__PLUS__PLUS_mapv.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(30), kw_column, int(7), kw_end_DASH_line, int(30), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(var_clojure_DOT_core_ifn_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "or__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v2})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = v13
						} else {
							tmp15 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
							tmp16 := lang.Apply(tmp15, []any{v2})
							tmp14 = tmp16
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_clojure_DOT_core_mapv)
				tmp7 := lang.Apply(tmp6, []any{v3, v2})
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_clojure_DOT_core_mapv)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_mapv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_mapv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++remove
	{
		tmp0 := sym__PLUS__PLUS_remove.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(35), kw_column, int(7), kw_end_DASH_line, int(35), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_ys_DOT_dwim_regex_DASH_to_DASH_fn)
			tmp5 := checkDerefVar(var_clojure_DOT_core_remove)
			tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_remove = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_remove.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++replace
	{
		tmp0 := sym__PLUS__PLUS_replace.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(37), kw_column, int(7), kw_end_DASH_line, int(37), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b), lang.NewVector(sym_a, sym_b, sym_c)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_string_replace)
				tmp5 := lang.Apply(tmp4, []any{v2, v3, ""})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_string_replace)
				tmp6 := lang.Apply(tmp5, []any{v2, v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ++take-while
	{
		tmp0 := sym__PLUS__PLUS_take_DASH_while.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(41), kw_column, int(7), kw_end_DASH_line, int(41), kw_end_DASH_column, int(18), kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_ys_DOT_dwim_regex_DASH_to_DASH_fn)
			tmp5 := checkDerefVar(var_clojure_DOT_core_take_DASH_while)
			tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS__PLUS_take_DASH_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS__PLUS_take_DASH_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +apply
	{
		tmp0 := sym__PLUS_apply.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_apply = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_apply.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +cons
	{
		tmp0 := sym__PLUS_cons.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_cons = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_cons.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +contains?
	{
		tmp0 := sym__PLUS_contains_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_contains_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_contains_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +drop
	{
		tmp0 := sym__PLUS_drop.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_drop)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_drop)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_drop = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_drop.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +drop-last
	{
		tmp0 := sym__PLUS_drop_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_drop_DASH_last)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_drop_DASH_last)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_drop_DASH_last = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_drop_DASH_last.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +drop-while
	{
		tmp0 := sym__PLUS_drop_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_drop_DASH_while)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_drop_DASH_while)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_drop_DASH_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_drop_DASH_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +escape
	{
		tmp0 := sym__PLUS_escape.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_string_escape)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_string_escape)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_escape = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_escape.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +every?
	{
		tmp0 := sym__PLUS_every_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_every_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_every_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_every_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_every_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +filter
	{
		tmp0 := sym__PLUS_filter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_filter)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_filter)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_filter = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_filter.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +filterv
	{
		tmp0 := sym__PLUS_filterv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_filterv)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_filterv)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_filterv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_filterv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +format
	{
		tmp0 := sym__PLUS_format.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__, sym__AMP_, sym_xs__2__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp9 := checkDerefVar(var_clojure_DOT_core_format)
					tmp10 := lang.Apply(tmp8, []any{tmp9, v3, v2, v4})
					tmp5 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp12 := checkDerefVar(var_clojure_DOT_core_format)
					tmp13 := lang.Apply(tmp11, []any{tmp12, v2, v3, v4})
					tmp5 = tmp13
				}
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_format = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_format.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +interpose
	{
		tmp0 := sym__PLUS_interpose.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_interpose)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_interpose)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_interpose = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_interpose.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +keep
	{
		tmp0 := sym__PLUS_keep.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_keep)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_keep)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_keep = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_keep.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +map
	{
		tmp0 := sym__PLUS_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_map)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_map)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +mapcat
	{
		tmp0 := sym__PLUS_mapcat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_mapcat)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_mapcat)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_mapcat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_mapcat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +mapv
	{
		tmp0 := sym__PLUS_mapv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_mapv)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_mapv)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_mapv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_mapv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +not-any?
	{
		tmp0 := sym__PLUS_not_DASH_any_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_not_DASH_any_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_not_DASH_any_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_not_DASH_any_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_not_DASH_any_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +nth
	{
		tmp0 := sym__PLUS_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_nth = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_nth.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +partition
	{
		tmp0 := sym__PLUS_partition.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym__AMP_, sym_xs__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_clojure_DOT_core_partition)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := lang.NewVector(v2)
					tmp11 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(359), kw_column, int(8), kw_end_DASH_line, int(359), kw_end_DASH_column, int(10))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{v3, tmp12})
					tmp14 := lang.Apply(tmp7, []any{tmp8, tmp13})
					tmp4 = tmp14
				} else {
					tmp15 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_clojure_DOT_core_partition)
					tmp17 := lang.Apply(tmp15, []any{tmp16, v2, v3})
					tmp4 = tmp17
				}
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_partition = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_partition.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +random-sample
	{
		tmp0 := sym__PLUS_random_DASH_sample.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_random_DASH_sample)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_random_DASH_sample)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_random_DASH_sample = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_random_DASH_sample.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +re-find
	{
		tmp0 := sym__PLUS_re_DASH_find.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_re_DASH_find)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_re_DASH_find)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_re_DASH_find = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_re_DASH_find.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +re-matches
	{
		tmp0 := sym__PLUS_re_DASH_matches.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_re_DASH_matches = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_re_DASH_matches.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +re-seq
	{
		tmp0 := sym__PLUS_re_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_re_DASH_seq)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_re_DASH_seq)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_re_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_re_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +reduce
	{
		tmp0 := sym__PLUS_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym__AMP_, sym_xs__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_clojure_DOT_core_reduce)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := lang.NewVector(v2)
					tmp11 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(359), kw_column, int(8), kw_end_DASH_line, int(359), kw_end_DASH_column, int(10))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{v3, tmp12})
					tmp14 := lang.Apply(tmp7, []any{tmp8, tmp13})
					tmp4 = tmp14
				} else {
					tmp15 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_clojure_DOT_core_reduce)
					tmp17 := lang.Apply(tmp15, []any{tmp16, v2, v3})
					tmp4 = tmp17
				}
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +remove
	{
		tmp0 := sym__PLUS_remove.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_remove)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_remove)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_remove = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_remove.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +repeat
	{
		tmp0 := sym__PLUS_repeat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_repeat)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_repeat)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_repeat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_repeat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +replace
	{
		tmp0 := sym__PLUS_replace.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__), lang.NewVector(sym_x__0__auto__, sym_y__1__auto__, sym_z__2__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_replace)
					tmp8 := lang.Apply(tmp7, []any{v3, v2})
					tmp4 = tmp8
				} else {
					tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_replace)
					tmp10 := lang.Apply(tmp9, []any{v2, v3})
					tmp4 = tmp10
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v2})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_replace)
					tmp9 := lang.Apply(tmp8, []any{v3, v2, v4})
					tmp5 = tmp9
				} else {
					tmp10 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_replace)
					tmp11 := lang.Apply(tmp10, []any{v2, v3, v4})
					tmp5 = tmp11
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +some
	{
		tmp0 := sym__PLUS_some.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_some)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_some)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_some = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_some.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +sort
	{
		tmp0 := sym__PLUS_sort.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_sort)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_sort)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_sort = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_sort.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +sort-by
	{
		tmp0 := sym__PLUS_sort_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_sort_DASH_by)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_sort_DASH_by)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_sort_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_sort_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +split-at
	{
		tmp0 := sym__PLUS_split_DASH_at.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_split_DASH_at)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_split_DASH_at)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_split_DASH_at = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_split_DASH_at.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +split-with
	{
		tmp0 := sym__PLUS_split_DASH_with.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_split_DASH_with)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_split_DASH_with)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_split_DASH_with = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_split_DASH_with.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +take
	{
		tmp0 := sym__PLUS_take.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_take)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_take)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_take = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_take.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +take-last
	{
		tmp0 := sym__PLUS_take_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_clojure_DOT_core_take_DASH_last)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_clojure_DOT_core_take_DASH_last)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_take_DASH_last = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_take_DASH_last.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +take-while
	{
		tmp0 := sym__PLUS_take_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x__0__auto__, sym_y__1__auto__)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_take_DASH_while)
				tmp8 := lang.Apply(tmp7, []any{v3, v2})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_ys_DOT_dwim__PLUS__PLUS_take_DASH_while)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim__PLUS_take_DASH_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim__PLUS_take_DASH_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dwim
	{
		tmp0 := sym_dwim.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_type, sym_idfn, sym_name)), kw_file, "ys/dwim.glj", kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim), kw_end_DASH_column, int(24), kw_column, int(11), kw_line, int(45), kw_end_DASH_line, int(45), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 5)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "dname"
				tmp8 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp9 := checkDerefVar(var_clojure_DOT_core_str)
				tmp10 := lang.Apply(tmp9, []any{"+", v6})
				tmp11 := lang.Apply(tmp8, []any{tmp10})
				var v12 any = tmp11
				_ = v12
				// let binding "pname"
				tmp13 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp14 := checkDerefVar(var_clojure_DOT_core_str)
				tmp15 := lang.Apply(tmp14, []any{"++", v6})
				tmp16 := lang.Apply(tmp13, []any{tmp15})
				var v17 any = tmp16
				_ = v17
				// let binding "name"
				var tmp18 any
				tmp19 := checkDerefVar(var_clojure_DOT_core_resolve)
				tmp20 := lang.Apply(tmp19, []any{v17})
				if lang.IsTruthy(tmp20) {
					tmp18 = v17
				} else {
					tmp18 = v6
				}
				var v21 any = tmp18
				_ = v21
				var tmp22 any
				{ // let
					// let binding "pred__1"
					tmp23 := checkDerefVar(var_clojure_DOT_core__EQ_)
					var v24 any = tmp23
					_ = v24
					// let binding "expr__2"
					var v25 any = v4
					_ = v25
					var tmp26 any
					tmp27 := lang.Apply(v24, []any{float64(2.1), v25})
					if lang.IsTruthy(tmp27) {
						tmp28 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp29 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp30 := checkDerefVar(var_clojure_DOT_core_list)
						tmp31 := lang.Apply(tmp30, []any{sym_clojure_DOT_core_SLASH_defn})
						tmp32 := checkDerefVar(var_clojure_DOT_core_list)
						tmp33 := lang.Apply(tmp32, []any{v12})
						tmp34 := checkDerefVar(var_clojure_DOT_core_list)
						tmp35 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp36 := checkDerefVar(var_clojure_DOT_core_vector)
						tmp37 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp38 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp39 := checkDerefVar(var_clojure_DOT_core_list)
						tmp40 := lang.Apply(tmp39, []any{sym_x__0__auto__})
						tmp41 := checkDerefVar(var_clojure_DOT_core_list)
						tmp42 := lang.Apply(tmp41, []any{sym_y__1__auto__})
						tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
						tmp44 := lang.Apply(tmp37, []any{tmp43})
						tmp45 := lang.Apply(tmp35, []any{tmp36, tmp44})
						tmp46 := lang.Apply(tmp34, []any{tmp45})
						tmp47 := checkDerefVar(var_clojure_DOT_core_list)
						tmp48 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp49 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp50 := checkDerefVar(var_clojure_DOT_core_list)
						tmp51 := lang.Apply(tmp50, []any{sym_if})
						tmp52 := checkDerefVar(var_clojure_DOT_core_list)
						tmp53 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp54 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp55 := checkDerefVar(var_clojure_DOT_core_list)
						tmp56 := lang.Apply(tmp55, []any{v5})
						tmp57 := checkDerefVar(var_clojure_DOT_core_list)
						tmp58 := lang.Apply(tmp57, []any{sym_y__1__auto__})
						tmp59 := lang.Apply(tmp54, []any{tmp56, tmp58})
						tmp60 := lang.Apply(tmp53, []any{tmp59})
						tmp61 := lang.Apply(tmp52, []any{tmp60})
						tmp62 := checkDerefVar(var_clojure_DOT_core_list)
						tmp63 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp64 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp65 := checkDerefVar(var_clojure_DOT_core_list)
						tmp66 := lang.Apply(tmp65, []any{v21})
						tmp67 := checkDerefVar(var_clojure_DOT_core_list)
						tmp68 := lang.Apply(tmp67, []any{sym_y__1__auto__})
						tmp69 := checkDerefVar(var_clojure_DOT_core_list)
						tmp70 := lang.Apply(tmp69, []any{sym_x__0__auto__})
						tmp71 := lang.Apply(tmp64, []any{tmp66, tmp68, tmp70})
						tmp72 := lang.Apply(tmp63, []any{tmp71})
						tmp73 := lang.Apply(tmp62, []any{tmp72})
						tmp74 := checkDerefVar(var_clojure_DOT_core_list)
						tmp75 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp76 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp77 := checkDerefVar(var_clojure_DOT_core_list)
						tmp78 := lang.Apply(tmp77, []any{v21})
						tmp79 := checkDerefVar(var_clojure_DOT_core_list)
						tmp80 := lang.Apply(tmp79, []any{sym_x__0__auto__})
						tmp81 := checkDerefVar(var_clojure_DOT_core_list)
						tmp82 := lang.Apply(tmp81, []any{sym_y__1__auto__})
						tmp83 := lang.Apply(tmp76, []any{tmp78, tmp80, tmp82})
						tmp84 := lang.Apply(tmp75, []any{tmp83})
						tmp85 := lang.Apply(tmp74, []any{tmp84})
						tmp86 := lang.Apply(tmp49, []any{tmp51, tmp61, tmp73, tmp85})
						tmp87 := lang.Apply(tmp48, []any{tmp86})
						tmp88 := lang.Apply(tmp47, []any{tmp87})
						tmp89 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp46, tmp88})
						tmp90 := lang.Apply(tmp28, []any{tmp89})
						tmp26 = tmp90
					} else {
						var tmp91 any
						tmp92 := lang.Apply(v24, []any{float64(2.2), v25})
						if lang.IsTruthy(tmp92) {
							tmp93 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp94 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp95 := checkDerefVar(var_clojure_DOT_core_list)
							tmp96 := lang.Apply(tmp95, []any{sym_clojure_DOT_core_SLASH_defn})
							tmp97 := checkDerefVar(var_clojure_DOT_core_list)
							tmp98 := lang.Apply(tmp97, []any{v12})
							tmp99 := checkDerefVar(var_clojure_DOT_core_list)
							tmp100 := checkDerefVar(var_clojure_DOT_core_apply)
							tmp101 := checkDerefVar(var_clojure_DOT_core_vector)
							tmp102 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp103 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp104 := checkDerefVar(var_clojure_DOT_core_list)
							tmp105 := lang.Apply(tmp104, []any{sym_x__0__auto__})
							tmp106 := checkDerefVar(var_clojure_DOT_core_list)
							tmp107 := lang.Apply(tmp106, []any{sym_y__1__auto__})
							tmp108 := lang.Apply(tmp103, []any{tmp105, tmp107})
							tmp109 := lang.Apply(tmp102, []any{tmp108})
							tmp110 := lang.Apply(tmp100, []any{tmp101, tmp109})
							tmp111 := lang.Apply(tmp99, []any{tmp110})
							tmp112 := checkDerefVar(var_clojure_DOT_core_list)
							tmp113 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp114 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp115 := checkDerefVar(var_clojure_DOT_core_list)
							tmp116 := lang.Apply(tmp115, []any{sym_if})
							tmp117 := checkDerefVar(var_clojure_DOT_core_list)
							tmp118 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp119 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp120 := checkDerefVar(var_clojure_DOT_core_list)
							tmp121 := lang.Apply(tmp120, []any{v5})
							tmp122 := checkDerefVar(var_clojure_DOT_core_list)
							tmp123 := lang.Apply(tmp122, []any{sym_x__0__auto__})
							tmp124 := lang.Apply(tmp119, []any{tmp121, tmp123})
							tmp125 := lang.Apply(tmp118, []any{tmp124})
							tmp126 := lang.Apply(tmp117, []any{tmp125})
							tmp127 := checkDerefVar(var_clojure_DOT_core_list)
							tmp128 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp129 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp130 := checkDerefVar(var_clojure_DOT_core_list)
							tmp131 := lang.Apply(tmp130, []any{v21})
							tmp132 := checkDerefVar(var_clojure_DOT_core_list)
							tmp133 := lang.Apply(tmp132, []any{sym_y__1__auto__})
							tmp134 := checkDerefVar(var_clojure_DOT_core_list)
							tmp135 := lang.Apply(tmp134, []any{sym_x__0__auto__})
							tmp136 := lang.Apply(tmp129, []any{tmp131, tmp133, tmp135})
							tmp137 := lang.Apply(tmp128, []any{tmp136})
							tmp138 := lang.Apply(tmp127, []any{tmp137})
							tmp139 := checkDerefVar(var_clojure_DOT_core_list)
							tmp140 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp141 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp142 := checkDerefVar(var_clojure_DOT_core_list)
							tmp143 := lang.Apply(tmp142, []any{v21})
							tmp144 := checkDerefVar(var_clojure_DOT_core_list)
							tmp145 := lang.Apply(tmp144, []any{sym_x__0__auto__})
							tmp146 := checkDerefVar(var_clojure_DOT_core_list)
							tmp147 := lang.Apply(tmp146, []any{sym_y__1__auto__})
							tmp148 := lang.Apply(tmp141, []any{tmp143, tmp145, tmp147})
							tmp149 := lang.Apply(tmp140, []any{tmp148})
							tmp150 := lang.Apply(tmp139, []any{tmp149})
							tmp151 := lang.Apply(tmp114, []any{tmp116, tmp126, tmp138, tmp150})
							tmp152 := lang.Apply(tmp113, []any{tmp151})
							tmp153 := lang.Apply(tmp112, []any{tmp152})
							tmp154 := lang.Apply(tmp94, []any{tmp96, tmp98, tmp111, tmp153})
							tmp155 := lang.Apply(tmp93, []any{tmp154})
							tmp91 = tmp155
						} else {
							var tmp156 any
							tmp157 := lang.Apply(v24, []any{float64(23.2), v25})
							if lang.IsTruthy(tmp157) {
								tmp158 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp159 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp160 := checkDerefVar(var_clojure_DOT_core_list)
								tmp161 := lang.Apply(tmp160, []any{sym_clojure_DOT_core_SLASH_defn})
								tmp162 := checkDerefVar(var_clojure_DOT_core_list)
								tmp163 := lang.Apply(tmp162, []any{v12})
								tmp164 := checkDerefVar(var_clojure_DOT_core_list)
								tmp165 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp166 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp167 := checkDerefVar(var_clojure_DOT_core_list)
								tmp168 := checkDerefVar(var_clojure_DOT_core_apply)
								tmp169 := checkDerefVar(var_clojure_DOT_core_vector)
								tmp170 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp171 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp172 := checkDerefVar(var_clojure_DOT_core_list)
								tmp173 := lang.Apply(tmp172, []any{sym_x__0__auto__})
								tmp174 := checkDerefVar(var_clojure_DOT_core_list)
								tmp175 := lang.Apply(tmp174, []any{sym_y__1__auto__})
								tmp176 := lang.Apply(tmp171, []any{tmp173, tmp175})
								tmp177 := lang.Apply(tmp170, []any{tmp176})
								tmp178 := lang.Apply(tmp168, []any{tmp169, tmp177})
								tmp179 := lang.Apply(tmp167, []any{tmp178})
								tmp180 := checkDerefVar(var_clojure_DOT_core_list)
								tmp181 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp182 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp183 := checkDerefVar(var_clojure_DOT_core_list)
								tmp184 := lang.Apply(tmp183, []any{sym_if})
								tmp185 := checkDerefVar(var_clojure_DOT_core_list)
								tmp186 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp187 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp188 := checkDerefVar(var_clojure_DOT_core_list)
								tmp189 := lang.Apply(tmp188, []any{v5})
								tmp190 := checkDerefVar(var_clojure_DOT_core_list)
								tmp191 := lang.Apply(tmp190, []any{sym_x__0__auto__})
								tmp192 := lang.Apply(tmp187, []any{tmp189, tmp191})
								tmp193 := lang.Apply(tmp186, []any{tmp192})
								tmp194 := lang.Apply(tmp185, []any{tmp193})
								tmp195 := checkDerefVar(var_clojure_DOT_core_list)
								tmp196 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp197 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp198 := checkDerefVar(var_clojure_DOT_core_list)
								tmp199 := lang.Apply(tmp198, []any{v21})
								tmp200 := checkDerefVar(var_clojure_DOT_core_list)
								tmp201 := lang.Apply(tmp200, []any{sym_y__1__auto__})
								tmp202 := checkDerefVar(var_clojure_DOT_core_list)
								tmp203 := lang.Apply(tmp202, []any{sym_x__0__auto__})
								tmp204 := lang.Apply(tmp197, []any{tmp199, tmp201, tmp203})
								tmp205 := lang.Apply(tmp196, []any{tmp204})
								tmp206 := lang.Apply(tmp195, []any{tmp205})
								tmp207 := checkDerefVar(var_clojure_DOT_core_list)
								tmp208 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp209 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp210 := checkDerefVar(var_clojure_DOT_core_list)
								tmp211 := lang.Apply(tmp210, []any{v21})
								tmp212 := checkDerefVar(var_clojure_DOT_core_list)
								tmp213 := lang.Apply(tmp212, []any{sym_x__0__auto__})
								tmp214 := checkDerefVar(var_clojure_DOT_core_list)
								tmp215 := lang.Apply(tmp214, []any{sym_y__1__auto__})
								tmp216 := lang.Apply(tmp209, []any{tmp211, tmp213, tmp215})
								tmp217 := lang.Apply(tmp208, []any{tmp216})
								tmp218 := lang.Apply(tmp207, []any{tmp217})
								tmp219 := lang.Apply(tmp182, []any{tmp184, tmp194, tmp206, tmp218})
								tmp220 := lang.Apply(tmp181, []any{tmp219})
								tmp221 := lang.Apply(tmp180, []any{tmp220})
								tmp222 := lang.Apply(tmp166, []any{tmp179, tmp221})
								tmp223 := lang.Apply(tmp165, []any{tmp222})
								tmp224 := lang.Apply(tmp164, []any{tmp223})
								tmp225 := checkDerefVar(var_clojure_DOT_core_list)
								tmp226 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp227 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp228 := checkDerefVar(var_clojure_DOT_core_list)
								tmp229 := checkDerefVar(var_clojure_DOT_core_apply)
								tmp230 := checkDerefVar(var_clojure_DOT_core_vector)
								tmp231 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp232 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp233 := checkDerefVar(var_clojure_DOT_core_list)
								tmp234 := lang.Apply(tmp233, []any{sym_x__0__auto__})
								tmp235 := checkDerefVar(var_clojure_DOT_core_list)
								tmp236 := lang.Apply(tmp235, []any{sym_y__1__auto__})
								tmp237 := checkDerefVar(var_clojure_DOT_core_list)
								tmp238 := lang.Apply(tmp237, []any{sym_z__2__auto__})
								tmp239 := lang.Apply(tmp232, []any{tmp234, tmp236, tmp238})
								tmp240 := lang.Apply(tmp231, []any{tmp239})
								tmp241 := lang.Apply(tmp229, []any{tmp230, tmp240})
								tmp242 := lang.Apply(tmp228, []any{tmp241})
								tmp243 := checkDerefVar(var_clojure_DOT_core_list)
								tmp244 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp245 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp246 := checkDerefVar(var_clojure_DOT_core_list)
								tmp247 := lang.Apply(tmp246, []any{sym_if})
								tmp248 := checkDerefVar(var_clojure_DOT_core_list)
								tmp249 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp250 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp251 := checkDerefVar(var_clojure_DOT_core_list)
								tmp252 := lang.Apply(tmp251, []any{v5})
								tmp253 := checkDerefVar(var_clojure_DOT_core_list)
								tmp254 := lang.Apply(tmp253, []any{sym_x__0__auto__})
								tmp255 := lang.Apply(tmp250, []any{tmp252, tmp254})
								tmp256 := lang.Apply(tmp249, []any{tmp255})
								tmp257 := lang.Apply(tmp248, []any{tmp256})
								tmp258 := checkDerefVar(var_clojure_DOT_core_list)
								tmp259 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp260 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp261 := checkDerefVar(var_clojure_DOT_core_list)
								tmp262 := lang.Apply(tmp261, []any{v21})
								tmp263 := checkDerefVar(var_clojure_DOT_core_list)
								tmp264 := lang.Apply(tmp263, []any{sym_y__1__auto__})
								tmp265 := checkDerefVar(var_clojure_DOT_core_list)
								tmp266 := lang.Apply(tmp265, []any{sym_x__0__auto__})
								tmp267 := checkDerefVar(var_clojure_DOT_core_list)
								tmp268 := lang.Apply(tmp267, []any{sym_z__2__auto__})
								tmp269 := lang.Apply(tmp260, []any{tmp262, tmp264, tmp266, tmp268})
								tmp270 := lang.Apply(tmp259, []any{tmp269})
								tmp271 := lang.Apply(tmp258, []any{tmp270})
								tmp272 := checkDerefVar(var_clojure_DOT_core_list)
								tmp273 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp274 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp275 := checkDerefVar(var_clojure_DOT_core_list)
								tmp276 := lang.Apply(tmp275, []any{v21})
								tmp277 := checkDerefVar(var_clojure_DOT_core_list)
								tmp278 := lang.Apply(tmp277, []any{sym_x__0__auto__})
								tmp279 := checkDerefVar(var_clojure_DOT_core_list)
								tmp280 := lang.Apply(tmp279, []any{sym_y__1__auto__})
								tmp281 := checkDerefVar(var_clojure_DOT_core_list)
								tmp282 := lang.Apply(tmp281, []any{sym_z__2__auto__})
								tmp283 := lang.Apply(tmp274, []any{tmp276, tmp278, tmp280, tmp282})
								tmp284 := lang.Apply(tmp273, []any{tmp283})
								tmp285 := lang.Apply(tmp272, []any{tmp284})
								tmp286 := lang.Apply(tmp245, []any{tmp247, tmp257, tmp271, tmp285})
								tmp287 := lang.Apply(tmp244, []any{tmp286})
								tmp288 := lang.Apply(tmp243, []any{tmp287})
								tmp289 := lang.Apply(tmp227, []any{tmp242, tmp288})
								tmp290 := lang.Apply(tmp226, []any{tmp289})
								tmp291 := lang.Apply(tmp225, []any{tmp290})
								tmp292 := lang.Apply(tmp159, []any{tmp161, tmp163, tmp224, tmp291})
								tmp293 := lang.Apply(tmp158, []any{tmp292})
								tmp156 = tmp293
							} else {
								var tmp294 any
								tmp295 := lang.Apply(v24, []any{float64(9.1), v25})
								if lang.IsTruthy(tmp295) {
									tmp296 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp297 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp298 := checkDerefVar(var_clojure_DOT_core_list)
									tmp299 := lang.Apply(tmp298, []any{sym_clojure_DOT_core_SLASH_defn})
									tmp300 := checkDerefVar(var_clojure_DOT_core_list)
									tmp301 := lang.Apply(tmp300, []any{v12})
									tmp302 := checkDerefVar(var_clojure_DOT_core_list)
									tmp303 := checkDerefVar(var_clojure_DOT_core_apply)
									tmp304 := checkDerefVar(var_clojure_DOT_core_vector)
									tmp305 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp306 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp307 := checkDerefVar(var_clojure_DOT_core_list)
									tmp308 := lang.Apply(tmp307, []any{sym_x__0__auto__})
									tmp309 := checkDerefVar(var_clojure_DOT_core_list)
									tmp310 := lang.Apply(tmp309, []any{sym_y__1__auto__})
									tmp311 := checkDerefVar(var_clojure_DOT_core_list)
									tmp312 := lang.Apply(tmp311, []any{sym__AMP_})
									tmp313 := checkDerefVar(var_clojure_DOT_core_list)
									tmp314 := lang.Apply(tmp313, []any{sym_xs__2__auto__})
									tmp315 := lang.Apply(tmp306, []any{tmp308, tmp310, tmp312, tmp314})
									tmp316 := lang.Apply(tmp305, []any{tmp315})
									tmp317 := lang.Apply(tmp303, []any{tmp304, tmp316})
									tmp318 := lang.Apply(tmp302, []any{tmp317})
									tmp319 := checkDerefVar(var_clojure_DOT_core_list)
									tmp320 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp321 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp322 := checkDerefVar(var_clojure_DOT_core_list)
									tmp323 := lang.Apply(tmp322, []any{sym_if})
									tmp324 := checkDerefVar(var_clojure_DOT_core_list)
									tmp325 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp326 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp327 := checkDerefVar(var_clojure_DOT_core_list)
									tmp328 := lang.Apply(tmp327, []any{v5})
									tmp329 := checkDerefVar(var_clojure_DOT_core_list)
									tmp330 := lang.Apply(tmp329, []any{sym_y__1__auto__})
									tmp331 := lang.Apply(tmp326, []any{tmp328, tmp330})
									tmp332 := lang.Apply(tmp325, []any{tmp331})
									tmp333 := lang.Apply(tmp324, []any{tmp332})
									tmp334 := checkDerefVar(var_clojure_DOT_core_list)
									tmp335 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp336 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp337 := checkDerefVar(var_clojure_DOT_core_list)
									tmp338 := lang.Apply(tmp337, []any{sym_clojure_DOT_core_SLASH_apply})
									tmp339 := checkDerefVar(var_clojure_DOT_core_list)
									tmp340 := lang.Apply(tmp339, []any{v21})
									tmp341 := checkDerefVar(var_clojure_DOT_core_list)
									tmp342 := lang.Apply(tmp341, []any{sym_y__1__auto__})
									tmp343 := checkDerefVar(var_clojure_DOT_core_list)
									tmp344 := lang.Apply(tmp343, []any{sym_x__0__auto__})
									tmp345 := checkDerefVar(var_clojure_DOT_core_list)
									tmp346 := lang.Apply(tmp345, []any{sym_xs__2__auto__})
									tmp347 := lang.Apply(tmp336, []any{tmp338, tmp340, tmp342, tmp344, tmp346})
									tmp348 := lang.Apply(tmp335, []any{tmp347})
									tmp349 := lang.Apply(tmp334, []any{tmp348})
									tmp350 := checkDerefVar(var_clojure_DOT_core_list)
									tmp351 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp352 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp353 := checkDerefVar(var_clojure_DOT_core_list)
									tmp354 := lang.Apply(tmp353, []any{sym_clojure_DOT_core_SLASH_apply})
									tmp355 := checkDerefVar(var_clojure_DOT_core_list)
									tmp356 := lang.Apply(tmp355, []any{v21})
									tmp357 := checkDerefVar(var_clojure_DOT_core_list)
									tmp358 := lang.Apply(tmp357, []any{sym_x__0__auto__})
									tmp359 := checkDerefVar(var_clojure_DOT_core_list)
									tmp360 := lang.Apply(tmp359, []any{sym_y__1__auto__})
									tmp361 := checkDerefVar(var_clojure_DOT_core_list)
									tmp362 := lang.Apply(tmp361, []any{sym_xs__2__auto__})
									tmp363 := lang.Apply(tmp352, []any{tmp354, tmp356, tmp358, tmp360, tmp362})
									tmp364 := lang.Apply(tmp351, []any{tmp363})
									tmp365 := lang.Apply(tmp350, []any{tmp364})
									tmp366 := lang.Apply(tmp321, []any{tmp323, tmp333, tmp349, tmp365})
									tmp367 := lang.Apply(tmp320, []any{tmp366})
									tmp368 := lang.Apply(tmp319, []any{tmp367})
									tmp369 := lang.Apply(tmp297, []any{tmp299, tmp301, tmp318, tmp368})
									tmp370 := lang.Apply(tmp296, []any{tmp369})
									tmp294 = tmp370
								} else {
									var tmp371 any
									tmp372 := lang.Apply(v24, []any{float64(9.9), v25})
									if lang.IsTruthy(tmp372) {
										tmp373 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp374 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp375 := checkDerefVar(var_clojure_DOT_core_list)
										tmp376 := lang.Apply(tmp375, []any{sym_clojure_DOT_core_SLASH_defn})
										tmp377 := checkDerefVar(var_clojure_DOT_core_list)
										tmp378 := lang.Apply(tmp377, []any{v12})
										tmp379 := checkDerefVar(var_clojure_DOT_core_list)
										tmp380 := checkDerefVar(var_clojure_DOT_core_apply)
										tmp381 := checkDerefVar(var_clojure_DOT_core_vector)
										tmp382 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp383 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp384 := checkDerefVar(var_clojure_DOT_core_list)
										tmp385 := lang.Apply(tmp384, []any{sym_x__0__auto__})
										tmp386 := checkDerefVar(var_clojure_DOT_core_list)
										tmp387 := lang.Apply(tmp386, []any{sym__AMP_})
										tmp388 := checkDerefVar(var_clojure_DOT_core_list)
										tmp389 := lang.Apply(tmp388, []any{sym_xs__1__auto__})
										tmp390 := lang.Apply(tmp383, []any{tmp385, tmp387, tmp389})
										tmp391 := lang.Apply(tmp382, []any{tmp390})
										tmp392 := lang.Apply(tmp380, []any{tmp381, tmp391})
										tmp393 := lang.Apply(tmp379, []any{tmp392})
										tmp394 := checkDerefVar(var_clojure_DOT_core_list)
										tmp395 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp396 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp397 := checkDerefVar(var_clojure_DOT_core_list)
										tmp398 := lang.Apply(tmp397, []any{sym_if})
										tmp399 := checkDerefVar(var_clojure_DOT_core_list)
										tmp400 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp401 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp402 := checkDerefVar(var_clojure_DOT_core_list)
										tmp403 := lang.Apply(tmp402, []any{v5})
										tmp404 := checkDerefVar(var_clojure_DOT_core_list)
										tmp405 := lang.Apply(tmp404, []any{sym_x__0__auto__})
										tmp406 := lang.Apply(tmp401, []any{tmp403, tmp405})
										tmp407 := lang.Apply(tmp400, []any{tmp406})
										tmp408 := lang.Apply(tmp399, []any{tmp407})
										tmp409 := checkDerefVar(var_clojure_DOT_core_list)
										tmp410 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp411 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp412 := checkDerefVar(var_clojure_DOT_core_list)
										tmp413 := lang.Apply(tmp412, []any{sym_clojure_DOT_core_SLASH_apply})
										tmp414 := checkDerefVar(var_clojure_DOT_core_list)
										tmp415 := lang.Apply(tmp414, []any{v21})
										tmp416 := checkDerefVar(var_clojure_DOT_core_list)
										tmp417 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp418 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp419 := checkDerefVar(var_clojure_DOT_core_list)
										tmp420 := lang.Apply(tmp419, []any{sym_clojure_DOT_core_SLASH_concat})
										tmp421 := checkDerefVar(var_clojure_DOT_core_list)
										tmp422 := lang.Apply(tmp421, []any{sym_xs__1__auto__})
										tmp423 := checkDerefVar(var_clojure_DOT_core_list)
										tmp424 := checkDerefVar(var_clojure_DOT_core_apply)
										tmp425 := checkDerefVar(var_clojure_DOT_core_vector)
										tmp426 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp427 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp428 := checkDerefVar(var_clojure_DOT_core_list)
										tmp429 := lang.Apply(tmp428, []any{sym_x__0__auto__})
										tmp430 := lang.Apply(tmp427, []any{tmp429})
										tmp431 := lang.Apply(tmp426, []any{tmp430})
										tmp432 := lang.Apply(tmp424, []any{tmp425, tmp431})
										tmp433 := lang.Apply(tmp423, []any{tmp432})
										tmp434 := lang.Apply(tmp418, []any{tmp420, tmp422, tmp433})
										tmp435 := lang.Apply(tmp417, []any{tmp434})
										tmp436 := lang.Apply(tmp416, []any{tmp435})
										tmp437 := lang.Apply(tmp411, []any{tmp413, tmp415, tmp436})
										tmp438 := lang.Apply(tmp410, []any{tmp437})
										tmp439 := lang.Apply(tmp409, []any{tmp438})
										tmp440 := checkDerefVar(var_clojure_DOT_core_list)
										tmp441 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp442 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp443 := checkDerefVar(var_clojure_DOT_core_list)
										tmp444 := lang.Apply(tmp443, []any{sym_clojure_DOT_core_SLASH_apply})
										tmp445 := checkDerefVar(var_clojure_DOT_core_list)
										tmp446 := lang.Apply(tmp445, []any{v21})
										tmp447 := checkDerefVar(var_clojure_DOT_core_list)
										tmp448 := lang.Apply(tmp447, []any{sym_x__0__auto__})
										tmp449 := checkDerefVar(var_clojure_DOT_core_list)
										tmp450 := lang.Apply(tmp449, []any{sym_xs__1__auto__})
										tmp451 := lang.Apply(tmp442, []any{tmp444, tmp446, tmp448, tmp450})
										tmp452 := lang.Apply(tmp441, []any{tmp451})
										tmp453 := lang.Apply(tmp440, []any{tmp452})
										tmp454 := lang.Apply(tmp396, []any{tmp398, tmp408, tmp439, tmp453})
										tmp455 := lang.Apply(tmp395, []any{tmp454})
										tmp456 := lang.Apply(tmp394, []any{tmp455})
										tmp457 := lang.Apply(tmp374, []any{tmp376, tmp378, tmp393, tmp456})
										tmp458 := lang.Apply(tmp373, []any{tmp457})
										tmp371 = tmp458
									} else {
										tmp459 := checkDerefVar(var_clojure_DOT_core_str)
										tmp460 := lang.Apply(tmp459, []any{"Bad dwim  type: ", v4})
										tmp461 := lang.Apply(lang.NewError, []any{tmp460})
										panic(tmp461)
									}
									tmp294 = tmp371
								}
								tmp156 = tmp294
							}
							tmp91 = tmp156
						}
						tmp26 = tmp91
					}
					tmp22 = tmp26
				} // end let
				tmp7 = tmp22
			} // end let
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim_dwim = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim_dwim.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// regex-to-fn
	{
		tmp0 := sym_regex_DASH_to_DASH_fn.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(13), kw_column, int(8), kw_end_DASH_line, int(13), kw_end_DASH_column, int(18), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_b, sym_f)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "a"
				var tmp6 any
				tmp7 := checkDerefVar(var_ys_DOT_dwim_regex_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v2})
				if lang.IsTruthy(tmp8) {
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v10 := args[0]
						_ = v10
						tmp11 := checkDerefVar(var_clojure_DOT_core_re_DASH_find)
						tmp12 := lang.Apply(tmp11, []any{v2, v10})
						return tmp12
					})
					tmp10 := lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(14), kw_column, int(26), kw_end_DASH_line, int(14), kw_end_DASH_column, int(40))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp11
				} else {
					tmp6 = v2
				}
				var v12 any = tmp6
				_ = v12
				tmp13 := lang.Apply(v4, []any{v12, v3})
				tmp5 = tmp13
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim_regex_DASH_to_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim_regex_DASH_to_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// regex?
	{
		tmp0 := sym_regex_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/dwim.glj", kw_line, int(11), kw_column, int(8), kw_end_DASH_line, int(11), kw_end_DASH_column, int(13), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_dwim))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*regexp4.Regexp)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_dwim_regex_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_dwim_regex_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}
