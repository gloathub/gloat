#!/usr/bin/env bash

# make-do â€” Helper functions for Makefile rules

set -euo pipefail

save-patch() (
  repo_url=$1
  shift
  gloat_only=$1
  shift
  clj_files=("$@")

  for f in "${clj_files[@]}"; do
    # Skip gloat-only files
    skip=false
    for gloat_file in $gloat_only; do
      if [[ $f == "$gloat_file" ]]; then
        skip=true
        break
      fi
    done
    $skip && continue

    clj=${f#ys/src/}
    name=$(echo "$clj" | tr '/' '-' | perl -pe 's/\.clj$//')
    diff -u <(curl -sL "$repo_url/$clj") "$f" 2>/dev/null \
      | perl -pe 's/\t.*// if 1..2' > "ys/patch/$name.patch" || true
    if [ ! -s "ys/patch/$name.patch" ]; then
      rm -f "ys/patch/$name.patch"
    else
      echo "Saved ys/patch/$name.patch"
    fi
  done
  echo "Patches saved to ys/patch/"
)

test-docker() (
  if [[ -d .cache/.local/bin/bb ]]; then
    echo 'Run first: make distclean'
    exit 1
  fi
  docker run --rm -it \
    -w /work \
    -v "$PWD:/work" \
    ubuntu:24.04 \
    bash -c '
      set -x &&
      apt update &&
      apt install -y curl git make xz-utils &&
      git config --global --add safe.directory /work &&
      export PERL_BADLANG=0 &&
      make test &&
      chown -R '"$(id -u):$(id -g) .cache"
)

update-clj() (
  repo_url=$1
  stem=$2
  target=$3

  curl -sL "$repo_url/$stem.clj" -o "$target"
  patch_file=ys/patch/$(echo "$stem" | tr '/' '-').patch
  if [ -f "$patch_file" ]; then
    echo "Applying $patch_file"
    patch --no-backup-if-mismatch -p0 < "$patch_file"
  fi
)

compile-glj() (
  stem=$1
  target=$2

  mkdir -p "$(dirname "$target")"
  tmpdir=$(mktemp -d)
  cp -r ys/glj/* "$tmpdir/"
  cd "$tmpdir"
  ns=$(echo "$stem" | tr '/' '.')
  echo "(compile (quote $ns))" | glj >/dev/null 2>&1 || true
  cd - >/dev/null
  cp "$tmpdir/$stem/loader.go" "$target"
  rm -rf "$tmpdir"
)

compile-glj-patched() (
  target=$1

  mkdir -p "$(dirname "$target")"
  tmpdir=$(mktemp -d)
  cp -r ys/glj/* "$tmpdir/"
  cd "$tmpdir"
  ns=$(echo "yamlscript/util" | tr '/' '.')
  echo "(compile (quote $ns))" | glj >/dev/null 2>&1 || true
  cd - >/dev/null
  cp "$tmpdir/yamlscript/util/loader.go" "$target"
  rm -rf "$tmpdir"

  patch --no-backup-if-mismatch -p1 < ys/patch/yamlscript-util-seqable.patch
)

release() (
  version=$1
  message=${2:-Release v$version}

  # --- Update version in all files ---
  perl -i -pe "s/^YS-PKG-VERSION .*/YS-PKG-VERSION ?= v$version/" Makefile
  perl -i -pe "s/^export GLOAT_VERSION=.*/export GLOAT_VERSION=$version/" \
    bin/gloat

  { echo "- version: $version"
    echo "  date:    $(date)"
    echo "  changes:"
    echo "  - $message"
    echo ""
    cat Changes
  } > Changes.tmp && mv Changes.tmp Changes

  # --- Rebuild and test ---
  make update ys-pkg
  make test

  # --- Commit and tag ys/pkg ---
  git add Makefile bin/gloat Changes ys/
  git commit -m "Version $version"
  git tag -a "ys/pkg/v$version" -m "Release ys/pkg v$version"
  git push origin main
  git push origin "ys/pkg/v$version"

  # --- Wait for Go proxy ---
  echo "Waiting for Go proxy to index ys/pkg v$version..."
  for i in $(seq 1 30); do
    if go list -m \
      "github.com/gloathub/gloat/ys/pkg@v$version" \
      2>/dev/null; then
      echo "  ys/pkg v$version is live on Go proxy"
      break
    fi
    echo "  Attempt $i/30, retrying in 10s..."
    sleep 10
  done

  # --- Tag and release gloat ---
  git tag -a "v$version" -m "Release v$version"
  git push origin "v$version"
  gh release create "v$version" \
    --title "gloat v$version" \
    --generate-notes
)

"$@"
