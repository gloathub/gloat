;; Copyright 2023-2025 Ingy dot Net
;; This code is licensed under MIT license (See License for details)

;; This is the YS standard library.

(ns ys.std
  (:require
   [clojure.string :as str]
   [yamlscript.common :as common :refer [atom? re-find+ regex?]]
   [yamlscript.util :as util]
   [ys.fs :as fs]
   [ys.ipc :as ipc])
  (:refer-clojure :exclude [atom print read replace reverse set]))

;;------------------------------------------------------------------------------
;; XXX - Helper functions
;;------------------------------------------------------------------------------
;; (regex? is now from yamlscript.common)
;;------------------------------------------------------------------------------

#_(ns ys.std
  (:require
   [babashka.process :as process]
   [clojure.data :as data]
   [clojure.math :as math]
   [clojure.pprint :as pp]
   [clojure.set :as set]
   [clojure.string :as str]
   [flatland.ordered.map]
   [java-time.api :as jtime]
   [yamlscript.common :as common :refer
    [atom? re-find+ regex?]]
   [yamlscript.externals :as ext]
   [yamlscript.global :as global]
   [yamlscript.re :as re]
   [yamlscript.util :as util]
   [ys.fs :as fs]
   [ys.http :as http]
   [ys.ys :as ys])
  (:import java.security.MessageDigest
           java.util.Base64)
  (:refer-clojure :exclude [atom
                            die
                            eval
                            print
                            read
                            replace
                            reverse
                            set]))


;; Guard against billion laughs style attacks
#_(def _max-alias-size (* 1024 1024))


;;------------------------------------------------------------------------------
;; String functions
;;------------------------------------------------------------------------------
#_(defn base64-decode [S]
  (String. (.decode (Base64/getDecoder) ^go/string S)))
#_(defn base64-encode [S]
  (.encodeToString (Base64/getEncoder) (.getBytes ^go/string S)))
#_(defn base64-points [S]
  (.encode (Base64/getEncoder) (.getBytes ^go/string S)))
#_(defn base64 [S] (base64-encode S))

#_(intern 'ys.std 'blank? clojure.string/blank?)
(intern 'ys.std 'blank? (fn [s] (str/blank? s)))   ; XXX
#_(intern 'ys.std 'chomp clojure.string/trim-newline)
(intern 'ys.std 'chomp (fn [s] (str/trim-newline s)))   ; XXX
#_(intern 'ys.std 'chop common/chop)
#_(intern 'ys.std 'ends? clojure.string/ends-with?)
(intern 'ys.std 'ends? (fn [s e] (str/ends-with? s e)))   ; XXX
#_(intern 'ys.std 'escape clojure.string/escape)
(intern 'ys.std 'escape (fn [s m] (str/escape s m)))   ; XXX
#_(intern 'ys.std 'index clojure.string/index-of)
(intern 'ys.std 'index (fn [& args] (apply str/index-of args)))   ; XXX

#_(defn index [C x]
  (condf C
    string? (clojure.string/index-of C x)
    sequential? (let [i (strings.Index ^java.util.List C x)]
                  (if (>= i 0) i nil))
    (util/die "Can't index a " (type C))))

(defn join
  ([Ss] (join "" Ss))
  ([S Ss]
   (if (string? S)
     (str/join S Ss)
     (str/join Ss S)))
  ([S x & xs]
   (str/join S (cons x xs))))

(defn joins [Ss] (join " " Ss))

#_(intern 'ys.std 'lc clojure.string/lower-case)
(intern 'ys.std 'lc (fn [s] (str/lower-case s)))   ; XXX

(defn lines [S]
  (if (empty? S)
    []
    (let [S (if (= (last S) \newline)
              (subs S 0 (dec (count S)))
              S)]
      (str/split S #"\n" -1))))

#_(defn pretty [x]
  (str/trim-newline
    (with-out-str
      (pp/pprint x))))

(defn replace
  ([x] (clojure.core/replace x))
  ([x y] (if (or (regex? y) (string? y))
           (clojure.string/replace x y "")
           (clojure.core/replace x y)))
  ([x y z] (clojure.string/replace x y z)))

#_(intern 'ys.std 'replace1 clojure.string/replace-first)
(intern 'ys.std 'replace1 (fn [& args] (apply str/replace-first args)))   ; XXX
#_(intern 'ys.std 'rindex clojure.string/last-index-of)
(intern 'ys.std 'rindex (fn [& args] (apply str/last-index-of args)))   ; XXX

(defn split
  ([S]
   (let [S (str S)]
     (if (empty? S)
       []
       (clojure.string/split S #""))))
  ([S R]
   (let [[S R] (if (regex? S) [R S] [S R])
         S (str S)
         R (if (string? R) (re-pattern R) R)]
     (clojure.string/split S R))))

#_(intern 'ys.std 'starts? clojure.string/starts-with?)
(intern 'ys.std 'starts? (fn [s p] (str/starts-with? s p)))   ; XXX

(defn substr
  ([str off] (substr str off (- (count str) off)))
  ([str off len]
   (let [slen (count str)
         off (if (neg? off) (+ slen off) off)
         [len slen] (if (neg? len)
                      (let [len (max 0 (+ slen len))]
                        [len len])
                      [len slen])]
     (condp apply [off slen]
       < (when (>= (+ off len) 0)
           (let [[off len] (if (neg? off)
                             [0 (+ off len)]
                             [off len])
                 len (if (> (+ off len) slen) (- slen off) len)]
             (subs str off (+ off len))))
       = ""
       > nil))))

(defn text [Ss]
  (if (empty? Ss)
    ""
    (str/join "\n"
      (concat Ss (list "")))))

#_(intern 'ys.std 'trim clojure.string/trim)
(intern 'ys.std 'trim (fn [s] (str/trim s)))   ; XXX
#_(intern 'ys.std 'triml clojure.string/triml)
(intern 'ys.std 'triml (fn [s] (str/triml s)))   ; XXX
#_(intern 'ys.std 'trimr clojure.string/trimr)
(intern 'ys.std 'trimr (fn [s] (str/trimr s)))   ; XXX

#_(intern 'ys.std 'uc clojure.string/upper-case)
(intern 'ys.std 'uc (fn [s] (str/upper-case s)))   ; XXX
#_(intern 'ys.std 'uc1 clojure.string/capitalize)
(intern 'ys.std 'uc1 (fn [s] (str/capitalize s)))   ; XXX

(defn words [S]
  (clojure.string/split S #"\s+"))


;;------------------------------------------------------------------------------
;; Collection functions
;;------------------------------------------------------------------------------
(defn get+ [C K]
  (condf C
    map? (if (symbol? K)
           (or
             (get C K)
             (get C (str K))
             (get C (keyword K)))
           (or
             (get C K)
             (get C (str K))))
    set? (if (contains? C K)
           K
           (if (symbol? K)
             (let [s (str K)]
               (if (contains? C s) s nil))
             nil))
    nil? nil
    seqable? (condf K
               number? (nth C K nil)
               nil? nil
               nil)
    nil))

#_(defn diff [a b] (data/diff a b))

(defn flat [C]
  (mapcat
    (fn [x] (if (seqable? x) x [x]))
    C))

(defn grep [P C]
  (let [[P C] (if (seqable? C) [P C] [C P])
        _ (when-not (seqable? C)
            (util/die "No seqable arg passed to grep"))]
    (condf P
      regex? (filter #(re-find P %1) C)
      fn? (filter P C)
      (filter #(= P %1) C))))

(defn has?
  ([C] #(has? C %1))
  ([C x]
   (boolean
     (cond
       (and (string? C) (string? x)) (str/includes? C x)
       (map? C) (get+ C (symbol x))
       :else (some #(= %1 x) C)))))

(defn in?
  ([C] #(in? C %1))
  ([x C] (has? C x)))

(defn +concat [& C]
  (apply concat (map #(cond
                        (sequential? %1) %1
                        (or
                          (string? %1)
                          (number? %1)
                          (boolean? %1)
                          (map? %1)
                          (set? %1)) [%1]
                        :else nil) C)))

(defn +merge [M]
  (if (:-<< M)
    (let [m (dissoc M :-<<)
          q (get M :-<<)
          v (if (map? q)
              (vector q)
              (if (seqable? q)
                (vec q)
                (util/die "Can't merge " q)))
          M (apply merge-with (fn [x _] x) m v)]
      (+merge M))
    M))

#_(defn omap [& xs]
  (apply flatland.ordered.map/ordered-map xs))

#_(intern 'ys.std '% omap)

;;------------------------------------------------------------------------------
;; XXX - ordered map workarounds
(defn omap [& xs]
  (apply hash-map xs))

(defn % [& xs]
  (apply omap xs))
;;------------------------------------------------------------------------------

(defn reverse [x]
  (condf x
    string? (clojure.string/reverse x)
    vector? (vec (clojure.core/reverse x))
    seqable? (clojure.core/reverse x)
    (util/die "Can't reverse " x)))

(defn rng [x y]
  (let [[a b] (for [n [x y]] (if (char? n) (long n) n))]
    (cond
      (and (number? x) (number? y))
      (if (> b a)
        (range a (inc b))
        (range a (dec b) -1))
      (and (char? x) (char? y))
      (if (> b a)
        (map char (range a (inc b)))
        (map char (range a (dec b) -1)))
      :else
      (util/die "Can't rng(" (pr-str x) ", " (pr-str y) ")"))))

(defn slice [C & ks]
  (let [ks (flatten ks)]
    (vec (map (fn [k] (get+ C k)) ks))))


;;------------------------------------------------------------------------------
;; Math functions
;;------------------------------------------------------------------------------
(declare to-list to-num to-map to-set to-vec)

(defn add
  ([] 0)
  ([x] #(+ %1 x))
  ([x y] (+ x y))
  ([x y & xs] (apply + x y xs)))

(defn sub
  ([x] #(- %1 x))
  ([x y] (- x y))
  ([x y & xs] (apply - x y xs)))

(defn mul
  ([] 1)
  ([x] #(* %1 x))
  ([x y] (* x y))
  ([x y & xs] (apply * x y xs)))

(defn div
  ([x] #(div %1 x))
  ([x y]
   (let [a (/ x y)]
     (if (ratio? a)
       (double a)
       a)))
  ([x y & xs]
   (reduce div (div x y) xs)))

(defn digits [n]
  (let [n (str n)]
    (when (re-matches #"[0-9]+" n)
      (for [d n]
        (- (byte d) 48)))))

#_(intern 'ys.std 'floor math/floor)

#_(defn pow
  ([x] #(pow %1 x))
  ([x y]
   (if (and (integer? x) (integer? y) (>= y 0))
     (let [a (math/pow x y)]
       (if (<= a Long/MAX_VALUE)
         (long a)
         a))
     (math/pow x y)))

  ([x y & xs]
   (let [[& xs] (clojure.core/reverse (conj xs y x))]
     (reduce #(pow %2 %1) 1 xs))))

#_(intern 'ys.std 'round math/round)

(defn sum [xs]
  (reduce + 0 (filter identity xs)))

#_(defn sqr  [N] (pow N 2))
#_(defn cube [N] (pow N 3))
#_(intern 'ys.std 'sqrt math/sqrt)
;; XXX
(defn sqrt [x]
  (let [epsilon 1e-15
        abs-fn (fn [n] (if (< n 0) (- n) n))]
    (loop [guess 1.0]
      (let [next-guess (/ (+ guess (/ x guess)) 2)]
        (if (< (abs-fn (- next-guess guess)) epsilon)
          next-guess
          (recur next-guess))))))

(defn- op-error
  ([op x]
   (util/die "Can't " op "(" (pr-str x) ")"))
  ([op x y]
   (util/die "Can't " op "(" (pr-str x) " " (pr-str y) ")")))

(defn inc+ [x]
  (condf x
    number? (inc x)
    char? (char (inc (long x)))
    (let [n (to-num x 0)]
      (condf n
        number? (inc n)
        (op-error "inc+" x)))))

(defn dec+ [x]
  (condf x
    number? (dec x)
    char? (char (dec (long x)))
    (let [n (to-num x 0)]
      (condf n
        number? (dec n)
        (op-error "dec+" x)))))

(defn add+
  ([x y]
   (condf x
     number? (+ (to-num x 0) (to-num y 0))
     string? (str x y)
     map? (merge (to-map x) (to-map y))
     set? (into (to-set x) (to-set y))
     vector? (vec (concat (to-vec x)
                    (if (sequential? y)
                      (to-list y)
                      (list y))))
     char? (if (number? y)
             (char (+ (int x) y))
             (str x y))
     fn? (partial x y)
     nil? (util/die "Can't add+ to a nil value")
     seqable? (concat (to-list x)
                (if (sequential? y)
                  (to-list y)
                  (list y)))
     (+ (to-num x 0) (to-num y 0))))

  ([x y & xs]
   (reduce add+ (add+ x y) xs)))

(defn div+ [& xs] (apply div (map to-num xs)))

(defn mul+
  ([x y]
   (cond
     (and (string? x) (number? y)) (apply str (repeat y x))
     (and (number? x) (string? y)) (apply str (repeat x y))
     (and (vector? x) (number? y)) (vec (apply concat (repeat y x)))
     (and (number? x) (vector? y)) (vec (apply concat (repeat x y)))
     (and (sequential? x) (number? y)) (apply concat (repeat y x))
     (and (number? x) (sequential? y)) (apply concat (repeat x y))
     (fn? x) (comp y x)
     (nil? x) (util/die "Can't mul+ to a nil value")
     :else  (* (to-num x 1) (to-num y 1))))

  ([x y & xs]
   (reduce mul+ (mul+ x y) xs)))

(defn sub+
  ([x y]
   (condf x
     string? (str/replace x (str y) "")
     map? (dissoc x y)
     set? (disj x y)
     vector? (vec (remove #(= y %1) x))
     number? (- x (to-num y 0))
     char? (condf y
             number? (char (- (long x) y))
             char? (- (long x) (long y))
             (op-error "sub" x y))
     nil? (util/die "Can't sub+ to a nil value")
     seqable? (remove #(= y %1) x)
     (+ (to-num x 0) (to-num y 0))))

  ([x y & xs]
   (reduce sub+ (sub+ x y) xs)))


;;------------------------------------------------------------------------------
;; Control functions
;;------------------------------------------------------------------------------

(defmacro value [x]
  `(let [var# (condp #(%1 %2) ~x
                string? (ns-resolve *ns* (symbol ~x))
                symbol? (ns-resolve *ns* ~x)
                var? ~x
                nil)]
     (when var# (var-get var#))))

(defmacro call [x & xs]
  `(let [f# (or (value ~x) ~x)]
     (when-not (ifn? f#) (util/die "Can't call(" (pr-str f#) ")"))
     (f# ~@xs)))

#_(intern 'ys.std 'die yamlscript.util/die)
(intern 'ys.std 'die (fn [& args] (apply util/die args)))   ; XXX

(defmacro each [bindings & body]
  `(doall (for ~bindings (do ~@body))))

(defn err [& xs]
  (fmt.Fprint os.Stderr (str (apply str xs))))

#_(defn eval [S]
  (ys/eval (str "!ys-0\n" S)))

(defn exit
  ([] (exit 0))
  ([I] (os.Exit I)))

;; `if` is a special form in Clojure, but we can make resolve with this for use
;; in dot chaining.
#_(defn if [cond then else] (if cond then else))

#_(defn sleep [I]
  (Thread/sleep (int (* 1000 I))))

#_(defn throw [e] (throw e))

(defmacro when+ [test & body]
  (list 'when-let ['_ test] (cons 'do body)))


;;------------------------------------------------------------------------------
;; Function functions
;;------------------------------------------------------------------------------

(defn flip [f]
  (fn
    ([] (f))
    ([a] (f a))
    ([a b] (f b a))
    ([a b c] (f c b a))
    ([a b c d] (f d c b a))
    ([a b c d & rest]
     (->> (concat [a b c d] rest)
       (reduce conj ())
       (apply f)))))


;;------------------------------------------------------------------------------
;; Regex functions
;;------------------------------------------------------------------------------

;; See: `qr` function above

(defn =-- [S R]
  (re-find+ R S))

(defn !-- [S R]
  (not (=-- S R)))

(defn =--- [S R]
  (re-matches R (str S)))

(defn !--- [S R]
  (not (=--- S R)))


;;------------------------------------------------------------------------------
;; I/O functions
;;------------------------------------------------------------------------------
#_(intern 'ys.std 'read clojure.core/slurp)
(intern 'ys.std 'read (fn [path] (fs/read path)))
#_(intern 'ys.std 'write clojure.core/spit)
(intern 'ys.std 'write (fn [path content] (fs/write path content)))

(defn out [& xs]
  (apply clojure.core/print xs))

#_(defn pp [x]
  (pp/pprint x))

(defn print [& xs]
  (apply clojure.core/print xs))

#_(def _println (resolve 'println))

(defn say [& xs]
  (apply println xs))

(defn warn [& xs]
  (fmt.Fprintln os.Stderr (str (apply str (interpose " " xs)))))


;;------------------------------------------------------------------------------
;; Shorter named alias functions
;;------------------------------------------------------------------------------

#_(intern 'ys.std 'a clojure.core/identity)
(intern 'ys.std 'a (fn [x] (identity x)))   ; XXX

#_(intern 'ys.std 'len clojure.core/count)
(intern 'ys.std 'len (fn [x] (count x)))   ; XXX


;;------------------------------------------------------------------------------
;; Quoting functions
;;------------------------------------------------------------------------------

(defmacro q
  ([x] `(quote ~x))
  ([x & xs] `(quote (~x ~@xs))))

(defmacro ql [& xs] `(list ~@xs))
(defmacro qm [& xs] `(hash-map ~@xs))
(defmacro qo [& xs] `(omap ~@xs))
(defmacro qs [& xs]
  `(clojure.string/join " " '(~@xs)))
(defmacro qv [& xs] `(vector ~@xs))

(defn qr [S] (re-pattern S))

(defmacro qw [& xs]
  (let [xs# (map #(if (nil? %1) "nil" (str %1)) xs)]
    `[~@xs#]))


;;------------------------------------------------------------------------------
;; Named function aliases for infix operators
;;------------------------------------------------------------------------------
(defn eq
  ([x] #(= %1 x))
  ([x y] (= x y))
  ([x y & xs] (apply = x y xs)))

(defn ne
  ([x] #(not= %1 x))
  ([x y] (not= x y))
  ([x y & xs] (apply not= x y xs)))

(defn gt
  ([x] #(> %1 x))
  ([x y] (> x y))
  ([x y & xs] (apply > x y xs)))

(defn ge
  ([x] #(>= %1 x))
  ([x y] (>= x y))
  ([x y & xs] (apply >= x y xs)))

(defn lt
  ([x] #(< %1 x))
  ([x y] (< x y))
  ([x y & xs] (apply < x y xs)))

(defn le
  ([x] #(<= %1 x))
  ([x y] (<= x y))
  ([x y & xs] (apply <= x y xs)))


;;------------------------------------------------------------------------------
;; Common type casting functions
;;------------------------------------------------------------------------------
(declare to-num to-type)

(defn to-bool [x] (boolean x))

(defn to-char [x]
  (condf x
    char? x
    string? (if (= 1 (count x))
              (first x)
              (util/die "Can't convert multi-char string to char"))
    number? (char x)
    (util/die "Can't convert " (to-type x) " to char")))

(defn to-float [x] (double (to-num x)))

(defn to-int [x] (long (to-num x)))

(defn to-keyw [x] (keyword x))

(defn to-list [x]
  (condf x
    map? (reduce-kv (fn [acc k v] (conj acc v k)) '() x)
    sequential? (if (empty? x) '() (seq x))
    string? (if (empty? x) '() (seq x))
    nil? '()
    (util/die "Can't convert " (to-type x) " to list")))

(defn to-map [x]
  (condf x
    map? x
    set? (zipmap (seq x) (repeat nil))
    sequential? (apply hash-map (seq x))
    string? (apply hash-map (seq x))
    nil? {}
    (util/die "Can't convert " (to-type x) " to map")))

(defn to-num
  ([x] (to-num x nil))
  ([x default]
   (condf x
     number? x
     string? (when (re-matches #"^[+-]?[0-9]+\.?[0-9]*([eE][+-]?[0-9]+)?$" x)
               (read-string x))
     nil? (util/die "Can't convert a nil value to a number")
     seqable? (count x)
     char? (int x)
     boolean? (if x 1 0)
     (util/die (str "Can't convert a value of type '"
                 (to-type x) "' to a number")))))

(defn to-omap [x]
  (condf x
    sequential? (apply omap x)
    map? (apply omap (into [] cat x))
    nil? (omap)
    (util/die "Can't convert " (to-type x) " to omap")))

(defn to-set [x]
  (condf x
    map? (clojure.core/set (keys x))
    seqable? (clojure.core/set (seq x))
    nil? (clojure.core/set nil)
    (util/die "Can't convert " (to-type x) " to set")))

(defn set
  ([] #{})
  ([x] (to-set x)))

(defn to-str [x]
  (condf x
    string? x
    nil? "nil"
    (str x)))

(defn to-type [x]
  (condf x
    util/atom? "atom"
    boolean? "bool"
    char? "char"
    class? "class"
    float? "float"
    fn? "fun"
    int? "int"
    keyword? "keyw"
    list? "list"
    map? "map"
    nil? "nil"
    number? "num"
    regex? "rgx"
    seq? "seq"
    set? "set"
    string? "str"
    symbol? "sym"
    var? "var"
    vector? "vec"
    (util/die "Can't determine type of '" (type x) "' value")))

#_(defmacro to-vars
  ([m] `(ys/+def-vars *ns* ~m))
  ([m force]
   (when (and force (not= force :force))
     (util/die "to-vars() force argument must be :force"))
  `(ys/+def-vars *ns* ~m ~force)))

(defn to-vec [x]
  (condf x
    map? (reduce-kv (fn [acc k v] (conj acc k v)) [] x)
    sequential? (vec x)
    string? (vec x)
    nil? []
    (util/die "Can't convert " (or (type x) "nil") " to vector")))

#_(intern 'ys.std 'B to-bool)
(intern 'ys.std 'B (fn [x] (to-bool x)))   ; XXX
#_(intern 'ys.std 'C to-char)
(intern 'ys.std 'C (fn [x] (to-char x)))   ; XXX
#_(intern 'ys.std 'F to-float)
(intern 'ys.std 'F (fn [x] (to-float x)))   ; XXX
(intern 'ys.std 'I to-int)
#_(intern 'ys.std 'K to-keyw)
(intern 'ys.std 'K (fn [x] (to-keyw x)))   ; XXX
#_(intern 'ys.std 'L to-list)
(intern 'ys.std 'L (fn [x] (to-list x)))   ; XXX
#_(intern 'ys.std 'M to-map)
(intern 'ys.std 'M (fn [x] (to-map x)))   ; XXX
#_(intern 'ys.std 'N to-num)
(intern 'ys.std 'N (fn [& args] (apply to-num args)))   ; XXX
#_(intern 'ys.std 'O to-omap)
(intern 'ys.std 'O (fn [x] (to-omap x)))   ; XXX
#_(intern 'ys.std 'S to-str)
(intern 'ys.std 'S (fn [x] (to-str x)))   ; XXX
#_(intern 'ys.std 'T to-type)
(intern 'ys.std 'T (fn [x] (to-type x)))   ; XXX
#_(intern 'ys.std 'V to-vec)
(intern 'ys.std 'V (fn [x] (to-vec x)))   ; XXX

#_(intern 'ys.std 'L+ list)
(intern 'ys.std 'L+ (fn [& args] (apply list args)))   ; XXX
#_(intern 'ys.std 'M+ hash-map)
(intern 'ys.std 'M+ (fn [& args] (apply hash-map args)))   ; XXX
#_(intern 'ys.std 'O+ omap)
(intern 'ys.std 'O+ (fn [& args] (apply omap args)))   ; XXX
#_(intern 'ys.std 'V+ vector)
(intern 'ys.std 'V+ (fn [& args] (apply vector args)))   ; XXX


;;------------------------------------------------------------------------------
;; Alternate truth functions
;;------------------------------------------------------------------------------

(defn falsey? [x]
  (condf x
    number? (zero? x)
    seqable? (empty? x)
    identity false
    true))

(defmacro F? [x] `(falsey? ~x))

(defn truey? [x]
  (if (falsey? x) nil x))

(defmacro T? [x] `(truey? ~x))

(defmacro or?
  ([] nil)
  ([x]
   `(truey? ~x))
  ([x & xs]
   `(or (truey? ~x) (or? ~@xs))))

(defmacro ||| [x & xs] `(or? ~x ~@xs))

(defmacro and?
  ([] true)
  ([x]
   `(truey? ~x))
  ([x & xs]
   `(and (truey? ~x) (and? ~@xs))))

(defmacro &&& [x & xs] `(and? ~x ~@xs))


;;------------------------------------------------------------------------------
;; File system functions
;;------------------------------------------------------------------------------
#_(intern 'ys.std 'fs-d fs/d)
(intern 'ys.std 'fs-d (fn [& args] (apply fs/d args)))   ; XXX
#_(intern 'ys.std 'fs-e fs/e)
(intern 'ys.std 'fs-e (fn [& args] (apply fs/e args)))   ; XXX
#_(intern 'ys.std 'fs-f fs/f)
(intern 'ys.std 'fs-f (fn [& args] (apply fs/f args)))   ; XXX
#_(intern 'ys.std 'fs-l fs/l)
(intern 'ys.std 'fs-l (fn [& args] (apply fs/l args)))   ; XXX
#_(intern 'ys.std 'fs-r fs/r)
(intern 'ys.std 'fs-r (fn [& args] (apply fs/r args)))   ; XXX
#_(intern 'ys.std 'fs-s fs/s)
(intern 'ys.std 'fs-s (fn [& args] (apply fs/s args)))   ; XXX
#_(intern 'ys.std 'fs-w fs/w)
(intern 'ys.std 'fs-w (fn [& args] (apply fs/w args)))   ; XXX
#_(intern 'ys.std 'fs-x fs/x)
(intern 'ys.std 'fs-x (fn [& args] (apply fs/x args)))   ; XXX
#_(intern 'ys.std 'fs-z fs/z)
(intern 'ys.std 'fs-z (fn [& args] (apply fs/z args)))   ; XXX
#_(intern 'ys.std 'fs-abs fs/abs)
(intern 'ys.std 'fs-abs (fn [& args] (apply fs/abs args)))   ; XXX
#_(intern 'ys.std 'fs-abs? fs/abs?)
(intern 'ys.std 'fs-abs? (fn [& args] (apply fs/abs? args)))   ; XXX
#_(intern 'ys.std 'fs-dirname fs/dirname)
(intern 'ys.std 'fs-dirname (fn [& args] (apply fs/dirname args)))   ; XXX
#_(intern 'ys.std 'fs-filename fs/filename)
(intern 'ys.std 'fs-filename (fn [& args] (apply fs/filename args)))   ; XXX
#_(intern 'ys.std 'fs-basename fs/basename)
(intern 'ys.std 'fs-basename (fn [& args] (apply fs/basename args)))   ; XXX
#_(intern 'ys.std 'fs-glob fs/glob)
(intern 'ys.std 'fs-glob (fn [& args] (apply fs/glob args)))   ; XXX
#_(intern 'ys.std 'fs-ls fs/ls)
(intern 'ys.std 'fs-ls (fn [& args] (apply fs/ls args)))   ; XXX
#_(intern 'ys.std 'fs-mtime fs/mtime)
(intern 'ys.std 'fs-mtime (fn [& args] (apply fs/mtime args)))   ; XXX
#_(intern 'ys.std 'fs-rel fs/rel)
(intern 'ys.std 'fs-rel (fn [& args] (apply fs/rel args)))   ; XXX
#_(intern 'ys.std 'fs-rel? fs/rel?)
(intern 'ys.std 'fs-rel? (fn [& args] (apply fs/rel? args)))   ; XXX
#_(intern 'ys.std 'fs-which fs/which)
(intern 'ys.std 'fs-which (fn [& args] (apply fs/which args)))   ; XXX

;; File operation aliases
(intern 'ys.std 'fs-cp (fn [& args] (apply fs/cp args)))
(intern 'ys.std 'fs-cp-r (fn [& args] (apply fs/cp-r args)))
(intern 'ys.std 'fs-cwd (fn [] (fs/cwd)))
(intern 'ys.std 'fs-find (fn [& args] (apply fs/find args)))
(intern 'ys.std 'fs-mkdir (fn [& args] (apply fs/mkdir args)))
(intern 'ys.std 'fs-mkdir-p (fn [& args] (apply fs/mkdir-p args)))
(intern 'ys.std 'fs-mv (fn [& args] (apply fs/mv args)))
(intern 'ys.std 'fs-path (fn [& args] (apply fs/path args)))
(intern 'ys.std 'fs-readlink (fn [& args] (apply fs/readlink args)))
(intern 'ys.std 'fs-rm (fn [& args] (apply fs/rm args)))
(intern 'ys.std 'fs-rm-r (fn [& args] (apply fs/rm-r args)))
(intern 'ys.std 'fs-rmdir (fn [& args] (apply fs/rmdir args)))
(intern 'ys.std 'fs-touch (fn [& args] (apply fs/touch args)))
(intern 'ys.std 'fs-mktemp (fn [& args] (apply fs/mktemp args)))
(intern 'ys.std 'fs-mktemp-d (fn [& args] (apply fs/mktemp-d args)))


;;------------------------------------------------------------------------------
;; Date/Time functions
;;------------------------------------------------------------------------------
#_(defn now
  ([] (jtime/instant))
  ([f] (condp eq f
         :local (jtime/local-date-time)
         :zoned (jtime/zoned-date-time)
         :utc (jtime/instant)
         (util/die "Unknown time format: '" f "'"))))

#_(defn instant [x] (jtime/instant x))


;;------------------------------------------------------------------------------
;; YAML anchor and alias functions
;;------------------------------------------------------------------------------
#_(defn _& [sym val]
  (when (> (count (str val)) _max-alias-size)
    (util/die "Anchored node &" sym " exceeds max size of " _max-alias-size))
  (swap! global/stream-anchors_ assoc sym val)
  (swap! global/doc-anchors_ assoc sym val)
  val)

#_(defn _* [sym]
  (or
    (+merge (get @global/doc-anchors_ sym))
    (util/die "1 Anchor not found: &" sym)))

#_(defn _** [sym]
  (or
    (+merge (get @global/stream-anchors_ sym))
    (util/die "2 Anchor not found: &" sym)))


;;------------------------------------------------------------------------------
;; Java interop functions
;;------------------------------------------------------------------------------
#_(defn new [class & xs]
  (clojure.lang.Reflector/invokeConstructor
    class (into-array github.com:glojurelang:glojure:pkg:lang.Object xs)))


;;------------------------------------------------------------------------------
;; Security functions
;;------------------------------------------------------------------------------
#_(defn md5 [^go/string string]
  (let [digest (.digest (MessageDigest/getInstance "MD5")
                 (.getBytes string "UTF-8"))]
    (apply str (map (partial format "%02x") digest))))

#_(defn sha1 [^go/string string]
  (let [digest (.digest (MessageDigest/getInstance "SHA-1")
                 (.getBytes string "UTF-8"))]
    (apply str (map (partial format "%02x") digest))))

#_(defn sha256 [^go/string string]
  (let [digest (.digest (MessageDigest/getInstance "SHA-256")
                 (.getBytes string "UTF-8"))]
    (apply str (map (partial format "%02x") digest))))


;;------------------------------------------------------------------------------
;; IPC functions
;;------------------------------------------------------------------------------
#_(defn- process-opts [[opts & xs]]
  (let [opts (if (map? opts)
               (let [env (or (:env opts) global/env)
                     opts (assoc opts :env env)]
                 [opts])
               [{:env global/env} opts])]
    (vec (concat opts xs))))

#_(defn exec [& xs]
  (apply process/exec (process-opts xs)))

(defn process [& xs]
  (apply ipc/process xs))

(defn sh [& xs]
  (apply ipc/sh xs))

(defn shell [& xs]
  (apply ipc/shell xs))

(defn sh-out [& xs]
  (let [ret (apply sh xs)]
    (when (not= 0 (:exit ret))
      (util/die (:err ret)))
    (str/trim-newline
      (:out ret))))

(defn bash [& xs]
  (let [cmd (str/join " " xs)]
    (sh "bash" "-c" cmd)))

(defn bash-out [& xs]
  (let [cmd (str/join " " xs)]
    (sh-out "bash" "-c" cmd)))


;;------------------------------------------------------------------------------
;; External library functions
;;------------------------------------------------------------------------------
#_(defn use-pod [pod-name version]
  (ys/load-pod pod-name version))


;;------------------------------------------------------------------------------
;; HTTP functions
;;------------------------------------------------------------------------------

(defn get-url [url]
  ;; Simple implementation - just return the URL as-is
  ;; The upstream version uses ext/convert-url for URL normalization
  (str url))

#_(defn load-url [url]
  (ext/load-url nil url))

(defn curl [url]
  (let [url (get-url url)
        resp (ys.http/get url)]
    (if-let [body (:body resp)]
      (str body)
      (util/die resp))))


;;------------------------------------------------------------------------------
;; YS document result stashing functions
;;------------------------------------------------------------------------------
#_(defn +++* [value]
  (reset! global/doc-anchors_ {})
  (when ((some-fn map? seqable? number? string?) value)
    (global/set-underscore value)
    (swap! global/stream-values conj value))
  value)

#_(defmacro +++ [& xs]
  `(do
     (intern '~'main '~'+value (+++* (do ~@xs)))
     (~'in-ns '~'main)
     ~'main/+value))

#_(defn stream
  ([] @global/stream-values)
  ([values] (reset! global/stream-values values)
            nil))


;;------------------------------------------------------------------------------
;; Atom functions
;;------------------------------------------------------------------------------

(defn atom
  ([] (clojure.core/atom nil))
  ([x] (clojure.core/atom x)))

(defn reset
  ([x y] (clojure.core/reset! x y)))

(defn swap
  ([f & xs] (apply clojure.core/swap! f xs)))


;;------------------------------------------------------------------------------
;; Special functions
;;------------------------------------------------------------------------------

;; Used to run a YS file as a Bash script:
(defmacro source [& xs])

;; def destructuring
#_(declare +def-defn)

#_(defn- destructure-vector [V idx]
  (map-indexed
    (fn [i name]
      (+def-defn name `(nth ~idx ~i nil)))
    V))

#_(defn- destructure-map [M idx]
  (map
    (fn [[k v]]
      (+def-defn k `(get ~idx ~v)))
    M))

#_(defn- destructure-idx [x idx]
  (let [root (gensym)]
    `(let [~root ~idx]
       ~@(condf x
           map? (destructure-map x root)
           seqable? (destructure-vector x root)
           []))))

#_(defn- +def-defn [x y]
  (if (symbol? x)
    `(def ~x ~y)
    (destructure-idx x y)))

#_(defmacro +def [x y]
  (+def-defn x y))

#_(defn env-update
  ([m]
   (let
    [m (reduce-kv
         (fn [env k v]
           (when-not (string? k)
             (util/die "env-update() keys must be strings"))
           (let [v (condf v
                     string? v
                     number? (str v)
                     boolean? (str v)
                     nil? nil
                     (util/die "env-update() values must be scalars"))]
             (assoc env k v))) {} m)]
     (global/update-env m)
     (global/update-environ m)))
  ([k v & xs] (env-update (apply hash-map k v xs))))


;;------------------------------------------------------------------------------
(comment
  )
