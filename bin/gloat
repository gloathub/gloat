#!/usr/bin/env bash

# gloat - Glojure AOT Tool
# Compiles YAMLScript/Clojure/Glojure to Go, binaries, or Wasm

# shellcheck disable=2034,2064,2154

VERSION=0.1.0

GLOAT_ROOT=$(cd -P "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P)

# Set Go environment to keep everything under .cache
export GOPATH="$GLOAT_ROOT/.cache/.local/go"
export GOMODCACHE="$GOPATH/pkg/mod"
export GOCACHE="$GLOAT_ROOT/.cache/.local/cache/go-build"

source "$GLOAT_ROOT/.bpan/lib/bpan.bash" --
source "$GLOAT_ROOT/.bpan/lib/getopt.bash" --

getopt_spec="\
getopt_default=(--help)

gloat [<options>] <file>...

Glojure AOT Tool - version $VERSION

Compiles Clojure or YAMLScript code to Go code
or any of the other FORMATS listed below.

  FILE:
    path      Source file (.ys, .clj, .glj) or directory
    -         Read from stdin

  FORMATS (-t):
    bin       Native binary
    lib       Shared library (.so .dylib .dll)
    wasm      Wasm wasip1
    js        Wasm js target
    clj       Clojure source file
    bb        Babashka-ready source file (self-contained)
    glj       Glojure source file
    go        Go source (default for stdout)
    dir       Go project directory

  Examples:
    gloat foo.ys                        Go code to stdout
    gloat foo.ys -t clj                 Clojure code to stdout
    gloat foo.ys -o foo.go              Go source file
    gloat foo.ys -o foo                 Native binary
    gloat foo.ys -o foo -p linux/amd64  Cross-compile
    gloat --run foo.ys -- arg1 arg2     Compile and run
--
t,to=         Output format (inferred from -o)
o,out=        Output file or directory
platform=     Cross-compile (e.g., linux/amd64)

ns=           Override namespace
module=       Go module name (e.g., github.com/user/project)

r,run         Compile and run (pass program args after --)
f,force       Overwrite existing output files
v,verbose     Print timing for each compilation step
q,quiet       Suppress progress messages

h,help        Show this help
version       Show version
"

main() (
  # When --run/-r is used, split args at -- to capture program arguments.
  # We must do this before getopt, which consumes --.
  init "$@"
  set -- "${args[@]}"
  getopt "$@"

  if do-version; then
    exit 0
  fi

  set-vars

  # Infer format
  format=$(infer-format "$output" "$to")

  check-exists

  # Fail fast if output already exists (unless --force)
  if [[ $output ]] && ! $option_force; then
    # Check exact path (covers both files and directories)
    [[ -e $output ]] &&
      die "Output already exists: $output (use --force to overwrite)"
    # For directory output (trailing /), check if file exists at that path
    [[ $output == */ && -e ${output%/} ]] &&
      die "Output already exists: ${output%/} (use --force to overwrite)"
  fi

  print-verbose-header

  # Dispatch based on input/output
  if [[ -z $output ]]; then
    # Stdout mode
    case $format in
      clj|bb|glj|go)
        convert-to-stdout "$input" "$format" "${namespace:-main.core}"
        ;;
      *)
        die "Format '$format' requires -o output"
        ;;
    esac
  elif [[ -f $input ]]; then
    convert-file "$input" "$output" "$format" "$namespace" "$module" "$platform"
  elif [[ -d $input ]]; then
    convert-directory "$input" "$output" "$format" "$namespace" "$module" "$platform"
  elif [[ $input == - ]]; then
    # Stdin - read to temp file
    tmpfile=$(mktemp --suffix=.ys)
    cat > "$tmpfile"
    convert-file "$tmpfile" "$output" "$format" "$namespace" "$module" "$platform"
    rm -f "$tmpfile"
  else
    die "Invalid input: $input"
  fi

  # Execute compiled output if --run
  if $option_run; then
    [[ -f $output ]] ||
      die "Compilation failed - no output to run"

    case $format in
      bb)
        # Run with babashka
        bb=$(get-make-var BB)
        [[ -x $bb ]] ||
          die "Babashka not found (run 'make shell' to install)"
        "$bb" "$output" "${run_args[@]}"
        rc=$?
        ;;
      bin|lib|wasm|js)
        # Run as binary
        "$output" "${run_args[@]}"
        rc=$?
        ;;
      *)
        die "Format '$format' cannot be executed with --run"
        ;;
    esac

    [[ ${run_tmpdir:-} ]] && rm -rf "$run_tmpdir"
    exit "$rc"
  fi

  print-verbose-footer
)

#------------------------------------------------------------------------------
# Conversion functions
#------------------------------------------------------------------------------

do-version() (
  $option_version || return
  echo "gloat version $VERSION"
  glojure_version=$(get-make-var GLOJURE-VERSION)
  if [[ $glojure_version ]]; then
    echo "glojure version $glojure_version"
  fi
  exit 0
)

# Convert YAMLScript to Clojure
ys-to-clj() (
  input=$1
  output=$2
  namespace=$3

  ys=$(get-make-var YS)

  timer-start

  # Format the output:
  # 1. Join defn/name that are split across lines
  # 2. Join defn name [params] when params are on next line
  # 3. Add blank lines between top-level forms
  body=$(
    "$ys" -c "$input" |
    grep -v '^(apply main ARGS)$' |
    perl -0777 -pe '
      s/\(defn\n (\S+)/\(defn $1/g;
      s/\(defn (\S+)\n (\[)/\(defn $1 $2/g;
      s/\)\n\(defn/\)\n\n\(defn/g;
      s/\)\n\(declare/\)\n\n\(declare/g;
    '
  )

  timer-end "YS→CLJ"

  export body

  # Get absolute path and directory of source file
  # Use GLOAT_SOURCE_FILE if set (from convert-file), otherwise use input
  if [[ ${GLOAT_SOURCE_FILE:-} ]]; then
    source_abs=$GLOAT_SOURCE_FILE
  else
    source_abs=$(realpath "$input")
  fi
  source_dir=$(dirname "$source_abs")

  # Use template with perl substitution for namespace, body, and paths
  perl -pe '
    s/NAMESPACE/'"$namespace"'/;
    s|SOURCE-FILE|'"$source_abs"'|;
    s|SOURCE-DIR|'"$source_dir"'|;
    $_ = $ENV{body} . "\n" if /^BODY$/;
  ' "$TEMPLATE/clojure.clj" > "$output"
)

# Convert Clojure to Glojure
clj-to-glj() (
  input=$1
  output=$2

  bb=$(get-make-var BB)
  glojure_dir=$(get-make-var GLOJURE-DIR)
  rewrite_script=$glojure_dir/scripts/rewrite-core/rewrite.clj

  # Derive namespace-like label from input path
  name=$(basename "$input" .clj)
  parent=$(basename "$(dirname "$input")")
  if [[ $parent == ys || $parent == yamlscript ]]; then
    label="$parent.$name"
  else
    label=$name
  fi

  timer-start
  "$bb" "$rewrite_script" "$input" > "$output"
  timer-end "CLJ→GLJ ($label)"
)

# Compile Glojure to Go
glj-to-go() (
  input=$1
  namespace=$2
  output_dir=$3

  glj=$(get-make-var GLJ)
  ns_path=${namespace//.//}
  ns_dir=${ns_path%/*}
  ns_file=${ns_path##*/}.glj

  timer-start

  # Copy input to namespace structure
  mkdir -p "$output_dir/$ns_dir"
  cp "$input" "$output_dir/$ns_dir/$ns_file"

  # Copy pre-compiled ys runtime and dependencies
  cp -r "$GLOAT_ROOT/ys/glj/"* "$output_dir/"

  # Compile user namespace only
  if $option_quiet; then
    echo "(compile (quote $namespace))" |
      (cd "$output_dir" && "$glj") >/dev/null 2>&1 || true
  else
    echo "(compile (quote $namespace))" |
      (cd "$output_dir" && "$glj") || true
  fi

  timer-end "GLJ→GO"
)

#------------------------------------------------------------------------------
# Convert single file to output
#------------------------------------------------------------------------------
convert-file() (
  input=$1
  output=$2
  format=$3
  namespace=$4
  module=$5
  platform=$6

  input_type=$(get-file-type "$input")

  # For formats that need directory build, delegate
  case $format in
    dir|bin|lib|wasm|js)
      # Preserve original source path for FILE/DIR variables
      original_source=$(realpath "$input")
      tmpdir=$(mktemp -d)
      # Ensure the file has an appropriate extension for directory conversion
      basename=$(basename "$input")
      if [[ ! $basename =~ \.(ys|clj|glj)$ ]]; then
        # No extension - add .ys based on file type detection
        local_input_type=$(get-file-type "$input")
        case $local_input_type in
          ys)  basename=$basename.ys ;;
          clj) basename=$basename.clj ;;
          glj) basename=$basename.glj ;;
        esac
      fi
      cp "$input" "$tmpdir/$basename"
      GLOAT_SOURCE_FILE="$original_source" \
        convert-directory "$tmpdir" "$output" "$format" "$namespace" "$module" "$platform"
      rm -rf "$tmpdir"
      return
      ;;
  esac

  tmpdir=$(mktemp -d)
  trap "rm -rf '$tmpdir'" EXIT

  clj_file=$tmpdir/temp.clj
  glj_file=$tmpdir/temp.glj

  # Determine namespace for .ys files
  if [[ $input_type == ys ]]; then
    ns=${namespace:-$(derive-namespace "$input")}
  fi

  # Stage 1: Convert to Clojure if needed
  case $input_type in
    ys)
      msg "Converting $input (.ys) to Clojure..."
      ys-to-clj "$input" "$clj_file" "$ns"
      ;;
    clj)
      cp "$input" "$clj_file"
      ;;
    glj)
      cp "$input" "$glj_file"
      ;;
    *)
      die "Unknown input file type: $input"
      ;;
  esac

  # Stage 2: Convert based on format
  case $format in
    clj)
      cp "$clj_file" "$output"
      msg "Generated: $output"
      ;;
    bb)
      generate-bb > "$output"
      msg "Generated: $output"
      ;;
    glj)
      if [[ -f $clj_file ]]; then
        msg "Converting Clojure to Glojure..."
        clj-to-glj "$clj_file" "$glj_file"
      fi
      cp "$glj_file" "$output"
      msg "Generated: $output"
      ;;
    go)
      if [[ -f $clj_file ]]; then
        msg "Converting Clojure to Glojure..."
        clj-to-glj "$clj_file" "$glj_file"
      fi
      ns=${ns:-$(resolve-namespace "${clj_file:-$glj_file}" "$namespace")}
      msg "Compiling Glojure to Go..."
      glj-to-go "$glj_file" "$ns" "$tmpdir"
      ns_path=${ns//.//}
      loader_file=$tmpdir/$ns_path/loader.go
      if [[ -f $loader_file ]]; then
        cp "$loader_file" "$output"
        msg "Generated: $output"
      else
        die "glj compile did not produce loader.go at $loader_file"
      fi
      ;;
  esac
)

#------------------------------------------------------------------------------
# Convert directory to output
#------------------------------------------------------------------------------
convert-directory() (
  input_dir=$1
  output=$2
  format=$3
  namespace=$4
  module=$5
  platform=$6

  is_dir_output=false is_binary=false
  output_dir='' binary_name='' build_mode='' goos='' goarch=''

  case $format in
    dir)
      is_dir_output=true
      output_dir=${output%/}
      ;;
    bin|lib|wasm|js)
      is_binary=true
      output_dir=$(mktemp -d)/build
      binary_name=$(basename "$output")
      if [[ $format == lib ]]; then
        build_mode=-buildmode=c-shared
        [[ $output != *.dylib ]] && binary_name=$binary_name.so
      fi
      ;;
    *)
      output_dir=${output%/}
      ;;
  esac

  # Set platform for Wasm formats or parse from -p flag
  if [[ $format == wasm ]]; then
    goos=wasip1
    goarch=wasm
  elif [[ $format == js ]]; then
    goos=js
    goarch=wasm
  elif [[ $platform ]]; then
    goos=${platform%/*}
    goarch=${platform#*/}
  fi

  msg "Converting directory $input_dir to $output_dir"
  mkdir -p "$output_dir"

  # Find source files
  source_files=()
  while IFS= read -r -d '' file; do
    source_files+=("$file")
  done < <(
    find "$input_dir" \
      -maxdepth 1 \
        \( \
          -name "*.ys" -o \
          -name "*.clj" -o \
          -name "*.glj" \
        \) \
      -print0 2>/dev/null
    )

  [[ ${#source_files[@]} -gt 0 ]] ||
    die "No .ys, .clj, or .glj files found in $input_dir"

  msg "Found ${#source_files[@]} source file(s)"

  main_namespace=''
  shared_tmpdir=$(mktemp -d)
  trap "rm -rf '$shared_tmpdir'" EXIT

  all_namespaces=()

  # Convert each file
  for source_file in "${source_files[@]}"; do
    basename=$(basename "$source_file")
    name=${basename%.*}
    input_type=$(get-file-type "$source_file")

    msg "  Converting $basename..."

    clj_file=$shared_tmpdir/$name.clj
    glj_file=$shared_tmpdir/$name.glj

    # Determine namespace for .ys files
    if [[ $input_type == ys ]]; then
      ns=${namespace:-$(derive-namespace "$source_file")}
    fi

    # Convert through pipeline
    case $input_type in
      ys)
        ys-to-clj "$source_file" "$clj_file" "$ns"
        ;;
      clj)
        cp "$source_file" "$clj_file"
        ;;
      glj)
        cp "$source_file" "$glj_file"
        ;;
      *)
        die "Unknown file type: $basename"
        ;;
    esac

    # Clojure to Glojure
    if [[ -f $clj_file ]]; then
      clj-to-glj "$clj_file" "$glj_file"
    fi

    # Resolve namespace
    ns=${ns:-$(resolve-namespace "${clj_file:-$glj_file}" "$namespace")}
    all_namespaces+=("$ns")

    # Copy to namespace structure
    ns_path=${ns//.//}
    ns_dir=${ns_path%/*}
    ns_file_name=${ns_path##*/}.glj

    mkdir -p "$shared_tmpdir/$ns_dir"
    cp "$glj_file" "$shared_tmpdir/$ns_dir/$ns_file_name"

    # First file or file named 'main' becomes main namespace
    if [[ -z $main_namespace || $name == main ]]; then
      main_namespace=$ns
    fi
  done

  # Copy pre-compiled ys runtime and dependencies (GLJ files for compilation)
  cp -r "$GLOAT_ROOT/ys/glj/"* "$shared_tmpdir/"

  glj=$(get-make-var GLJ)

  # Compile all user namespaces
  for ns in "${all_namespaces[@]}"; do
    msg "  Compiling $ns..."
    echo "(compile (quote $ns))" |
      (cd "$shared_tmpdir" && "$glj") >/dev/null 2>&1 || true
  done

  # Copy generated Go files to output directory under pkg/
  mkdir -p "$output_dir/pkg"
  find "$shared_tmpdir" -name "*.go" -type f |
  while read -r gofile; do
    relpath="${gofile#"$shared_tmpdir"/}"
    target="$output_dir/pkg/$relpath"
    mkdir -p "$(dirname "$target")"
    cp "$gofile" "$target"
  done

  # Copy pre-compiled ys packages (with patches) over generated ones
  cp -r "$GLOAT_ROOT/ys/pkg/"* "$output_dir/pkg/"

  [[ $main_namespace ]] ||
    die "Could not determine main namespace"

  msg "Main namespace: $main_namespace"

  # Determine Go module name
  if [[ $module ]]; then
    go_module=$module
  else
    dir_name=$(basename "$output_dir")
    go_module=github.com/gloathub/$dir_name
  fi
  msg "Go module: $go_module"

  # Generate go.mod
  glojure_version=$(get-make-var GLOJURE-VERSION)
  perl -p \
    -e "s|GO-MODULE|$go_module|g;" \
    -e "s|GLOJURE-VERSION|$glojure_version|g;" \
      "$TEMPLATE/go.mod" > "$output_dir/go.mod"
  msg "Generated: $output_dir/go.mod"

  # Generate main.go
  package_path=${main_namespace//.//}
  template=$TEMPLATE/main.go
  [[ $format == lib ]] && template=$TEMPLATE/lib-main.go

  perl -p \
    -e "s|GO-MODULE|$go_module|g;" \
    -e "s|PACKAGE-PATH|$package_path|g;" \
    -e "s/NAMESPACE/$main_namespace/g" \
      "$template" > "$output_dir/main.go"
  msg "Generated: $output_dir/main.go"

  # Generate Makefile for directory output
  if $is_dir_output; then
    bin_name=${binary_name:-$(basename "$output_dir")}
    perl -pe "s/BINARY-NAME/$bin_name/g" \
      "$TEMPLATE/Makefile" > "$output_dir/Makefile"
    msg "Generated: $output_dir/Makefile"
  fi

  # Build binary if needed
  if $is_binary; then
    msg "Building $format..."
    build_env=("GONOSUMCHECK=*")
    go_bin=$(get-make-var GO)

    [[ $goos ]] && build_env+=("GOOS=$goos")
    [[ $goarch ]] && build_env+=("GOARCH=$goarch")

    (cd "$output_dir" && GONOSUMCHECK='*' "$go_bin" mod tidy)

    build_cmd=("$go_bin" build -ldflags "-s -w" -o "$binary_name")
    [[ $build_mode ]] && build_cmd+=("$build_mode")
    build_cmd+=(main.go)

    timer-start
    if [[ ${#build_env[@]} -gt 0 ]]; then
      (cd "$output_dir" && env "${build_env[@]}" "${build_cmd[@]}")
    else
      (cd "$output_dir" && "${build_cmd[@]}")
    fi
    timer-end "GO→BIN"

    if [[ -f $output_dir/$binary_name ]]; then
      cp "$output_dir/$binary_name" "$output"
      msg "Generated: $output"

      # Copy .h file for shared libraries
      if [[ $format == lib ]]; then
        h_file=${binary_name%.so}
        h_file=${h_file%.dylib}.h
        h_output=${output%.so}
        h_output=${h_output%.dylib}.h
        if [[ -f $output_dir/$h_file ]]; then
          cp "$output_dir/$h_file" "$h_output"
          msg "Generated: $h_output"
        fi
      fi

      # Clean up temp build dir
      rm -rf "$(dirname "$output_dir")"
    else
      die "Build failed"
    fi
  elif $is_dir_output; then
    msg "Generated Go module in: $output_dir"
    msg "To build: cd $output_dir && make"
  else
    msg "Generated Go module in: $output_dir"
    msg "To build: cd $output_dir && go build"
  fi
)

generate-bb() (
  # Output ys runtime (with ns declarations)
  cat "$GLOAT_ROOT/ys/src/yamlscript/util.clj"
  echo
  cat "$GLOAT_ROOT/ys/src/yamlscript/common.clj"
  echo
  cat-bb fs
  echo
  cat-bb ipc
  echo
  cat-bb std
  echo
  cat "$GLOAT_ROOT/ys/src/ys/dwim.clj"
  echo
  # Filter v0.clj to remove http/json requires
  perl -p \
    -e 'undef $_ if /^\s*\[yamlscript\.common\]$/;' \
    -e 'undef $_ if /^\s*\[ys\.http\]$/;' \
    -e 'undef $_ if /^\s*\[ys\.json\]$/;' \
    < "$GLOAT_ROOT/ys/src/ys/v0.clj"
  echo
  # Output generated CLJ (keep ns with :require intact)
  # Remove requires for ys.http and ys.json which don't have BB versions
  perl -p \
    -e 'undef $_ if /\[ys\.http :as http\]/;' \
    -e 'undef $_ if /\[ys\.json :as json\]/;' \
    -e 'undef $_ if /^\s*\[ys\.http\]$/;' \
    -e 'undef $_ if /^\s*\[ys\.json\]$/;' \
    < "$clj_file"
  echo
  # Add main invocation
  echo '(apply -main *command-line-args*)'
)

# Helper to cat a BB-patched version of a source file
cat-bb() (
  src=$GLOAT_ROOT/ys/src/ys/$1.clj
  patch=$GLOAT_ROOT/ys/patch/ys-$1-bb.patch
  tmpfile=$(mktemp)

  patch --no-backup-if-mismatch -p0 -o "$tmpfile" \
    "$src" < "$patch" >/dev/null 2>&1

  # Special handling for ys.fs: fix read/write functions to use slurp/spit
  if [[ $1 == "fs" ]]; then
    bash "$GLOAT_ROOT/ys/patch/fix-fs-bb.sh" "$tmpfile"
  elif [[ $1 == "std" ]]; then
    bash "$GLOAT_ROOT/ys/patch/fix-std-bb.sh" "$tmpfile"
  fi

  cat "$tmpfile"
  rm -f "$tmpfile"
)

#------------------------------------------------------------------------------
# Output to stdout
#------------------------------------------------------------------------------
convert-to-stdout() (
  input=$1
  format=$2
  namespace=$3

  tmpdir=$(mktemp -d)
  trap "rm -rf '$tmpdir'" EXIT

  input_type=$(get-file-type "$input")
  clj_file=$tmpdir/temp.clj
  glj_file=$tmpdir/temp.glj

  # Convert to Clojure if needed
  case "$input_type" in
    ys)
      ys-to-clj "$input" "$clj_file" "$namespace"
      ;;
    clj)
      cp "$input" "$clj_file"
      ;;
    glj)
      cp "$input" "$glj_file"
      ;;
  esac

  case $format in
    clj)
      cat "$clj_file"
      ;;
    bb)
      generate-bb
      ;;
    glj)
      if [[ -f $clj_file ]]; then
        clj-to-glj "$clj_file" "$glj_file"
      fi
      cat "$glj_file"
      ;;
    go)
      if [[ -f $clj_file ]]; then
        clj-to-glj "$clj_file" "$glj_file"
      fi
      go_tmpdir=$(mktemp -d)
      ns=$(resolve-namespace "${clj_file:-$glj_file}" '')
      glj-to-go "$glj_file" "$ns" "$go_tmpdir"
      ns_path=${ns//.//}
      loader_file=$go_tmpdir/$ns_path/loader.go
      [[ -f $loader_file ]] ||
        die "glj compile did not produce loader.go"
      cat "$loader_file"
      rm -rf "$go_tmpdir"
      ;;
  esac
)

#------------------------------------------------------------------------------
# Helper functions
#------------------------------------------------------------------------------

init() {
  make --quiet --no-print-directory -C "$GLOAT_ROOT" path-deps
  TEMPLATE=$GLOAT_ROOT/template
  SRC=$GLOAT_ROOT/ys/src

  local has_run arg gloat_argv found_dd

  run_args=()
  has_run=false
  for arg; do
    [[ $arg == -- ]] && break
    if [[ $arg == --run || $arg == -r ]]; then
      has_run=true
      break
    fi
  done

  if $has_run; then
    gloat_argv=()
    found_dd=false
    for arg; do
      if ! $found_dd && [[ $arg == -- ]]; then
        found_dd=true
        continue
      fi
      if $found_dd; then
        run_args+=("$arg")
      else
        gloat_argv+=("$arg")
      fi
    done
    set -- "${gloat_argv[@]}"
  fi

  args=("$@")
}

set-vars() {
  input=${args[0]:-}
  output=${option_out:-}
  namespace=${option_ns:-}
  module=${option_module:-${GLOAT_MODULE:-}}
  platform=${option_platform:-}

  # --run implies quiet (don't mix progress messages with program output)
  if $option_run; then
    option_quiet=true

    # --run only supports a single input file
    [[ ${#args[@]} -le 1 ]] ||
      die "--run does not support multiple input files." \
	        "Use '--' for --run program arguments."
  fi

  # Multiple input files not yet supported
  if [[ ${#args[@]} -gt 1 ]]; then
    die "Multiple input files not supported." \
        "Did you mean: gloat ${args[0]} -o ${args[1]}"
  fi

  # Validate input
  if [[ -z $input ]]; then
    [[ ${option_out:-} ]] ||
      die "Missing input file"
    input=-
  fi

  # Auto-detect file extension if file doesn't exist
  if [[ $input != - && ! -e $input && $input != *.* ]]; then
    for ext in ys clj glj; do
      if [[ -e $input.$ext ]]; then
        input=$input.$ext
        break
      fi
    done
  fi

  [[ $input == - || -e $input ]] ||
    die "Input file/directory does not exist: $input"

  # Validate platform format
  [[ ! $platform || $platform =~ ^[a-z][a-z0-9]*/[a-z0-9]+$ ]] ||
    die "Platform must be in format OS/ARCH (e.g., linux/amd64, wasip1/wasm)"

  # Handle -t .ext shorthand (e.g., -t .glj means -o input.glj)
  to=${option_to:-}
  if [[ $to == .* ]]; then
    ext=${to#.}
    basename=${input##*/}
    basename=${basename%.*}
    output=${output:-$basename.$ext}
    to=$ext
  fi

  # --run without -o: compile to temp file (binary or bb)
  if $option_run && [[ -z $output ]]; then
    run_tmpdir=$(mktemp -d)
    if [[ $to == bb ]]; then
      output=$run_tmpdir/gloat-run.bb
    elif [[ -z $to ]]; then
      output=$run_tmpdir/gloat-run
      to=bin
    else
      output=$run_tmpdir/gloat-run.$to
    fi
  fi

  # Default: no -o and no -t means binary output with input basename
  if [[ -z $output && -z $to ]]; then
    if [[ $input == - ]]; then
      basename=app
    else
      basename=${input##*/}
      basename=${basename%.*}
    fi
    output=$basename
    to=bin
  fi
}

check-exists() (
  # Remove existing output if --force
  if $option_force && [[ $output ]]; then
    if [[ -e $output ]]; then
      if [[ -d $output ]]; then
        msg "Removing $output/..."
      else
        msg "Removing $output..."
      fi
      rm -rf "$output"
    fi
    if [[ $output == */ && -e ${output%/} ]]; then
      msg "Removing ${output%/}/..."
      rm -rf "${output%/}"
    fi
  fi
)

# Get a variable from the Makefile
get-make-var() (
  var=$1
  make -C "$GLOAT_ROOT" --no-print-directory \
    --eval="print-$var: ; @echo \$($var)" \
    "print-$var" 2>/dev/null
)

# Get file extension type
get-file-type() (
  file=$1
  case $file in
    *.ys)     echo ys ;;
    *.clj)    echo clj ;;
    *.glj)    echo glj ;;
    *.go)     echo go ;;
    *.wasm)   echo wasm ;;
    *.so)     echo lib ;;
    *.dylib)  echo lib ;;
    */)       echo dir ;;
    *)
      # Check for YAMLScript shebang (#!/usr/bin/env ys-0 or similar)
      if [[ -f $file ]] && head -n1 "$file" | grep -q '^#!/.*\bys-\?[0-9]'; then
        echo ys
      else
        echo unknown
      fi
      ;;
  esac
)

# Infer output format from -o extension or -t flag
infer-format() (
  out=$1
  to=$2

  # Explicit -t flag takes precedence
  if [[ $to ]]; then
    echo "$to"
    return
  fi

  # No output = stdout with go format
  if [[ ! $out ]]; then
    echo go
    return
  fi

  # Infer from extension
  case $out in
    *.bb)    echo bb ;;
    *.clj)   echo clj ;;
    *.glj)   echo glj ;;
    *.go)    echo go ;;
    *.so)    echo lib ;;
    *.dylib) echo lib ;;
    *.wasm)  echo wasm ;;
    *.js)    echo js ;;
    */)      echo dir ;;
    *)
      # No extension = binary
      if [[ $out != *.* ]]; then
        echo bin
      else
        echo bin
      fi
      ;;
  esac
)

# Derive namespace from filename
derive-namespace() (
  file=$1
  basename=${file##*/}
  name=${basename%.*}
  # Replace hyphens with underscores
  name=${name//-/_}
  # Prefix with _ if starts with digit
  if [[ $name =~ ^[0-9] ]]; then
    name=_$name
  fi
  echo "$name.core"
)

# Parse namespace from Clojure file
parse-namespace() (
  file=$1
  if [[ -f $file ]]; then
    grep -oP '^\(ns\s+\K[^\s)]+' "$file" 2>/dev/null || true
  fi
)

# Resolve namespace with priority
resolve-namespace() (
  file=$1
  ns_override=$2

  if [[ $ns_override ]]; then
    echo "$ns_override"
  elif [[ ${GLOAT_NAMESPACE:-} ]]; then
    echo "$GLOAT_NAMESPACE"
  else
    parsed=$(parse-namespace "$file")
    if [[ $parsed ]]; then
      echo "$parsed"
    else
      derive-namespace "$file"
    fi
  fi
)

print-verbose-header() {
  # Print verbose header
  if $option_verbose && [[ $output ]] && ! $option_quiet; then
    input_name=$(basename "$input")
    echo "Compiling $input_name to $format..." >&2
    _compile_start=$(date +%s%3N)
  fi
}

print-verbose-footer() (
  # Print verbose total time
  if $option_verbose && [[ $output ]] && ! $option_quiet; then
    compile_end=$(date +%s%3N)
    total_time=$(( compile_end - _compile_start ))
    echo "done (${total_time}ms)" >&2
  fi
)

# Helper to print messages (respects quiet mode)
msg() (
  $option_quiet ||
    echo "$@"
)

# Timer for verbose mode
timer-start() {
  if $option_verbose && ! $option_quiet; then
    _timer_start=$(date +%s%3N)
  fi
}

timer-end() (
  if $option_verbose && ! $option_quiet; then
    label=$1
    end=$(date +%s%3N)
    elapsed=$(( end - _timer_start ))
    echo "  $label... done (${elapsed}ms)" >&2
  fi
)

main "$@"
