// Code generated by glojure codegen. DO NOT EDIT.

package std

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
	regexp4 "regexp"
)

func init() {
	runtime.RegisterNSLoader("ys/std", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "ys.std"
func LoadNS() {
	sym__BANG__DASH__DASH__DASH_ := lang.NewSymbol("!---")
	sym__PCT_ := lang.NewSymbol("%")
	sym__AMP_ := lang.NewSymbol("&")
	sym__AMP__AMP__AMP_ := lang.NewSymbol("&&&")
	sym__STAR_ := lang.NewSymbol("*")
	sym__PLUS_ := lang.NewSymbol("+")
	sym__PLUS_concat := lang.NewSymbol("+concat")
	sym__PLUS_merge := lang.NewSymbol("+merge")
	sym__DASH_ := lang.NewSymbol("-")
	sym__SLASH_ := lang.NewSymbol("/")
	sym__LT_ := lang.NewSymbol("<")
	sym__LT__EQ_ := lang.NewSymbol("<=")
	sym__EQ_ := lang.NewSymbol("=")
	sym__EQ__DASH__DASH__DASH_ := lang.NewSymbol("=---")
	sym__GT_ := lang.NewSymbol(">")
	sym__GT__EQ_ := lang.NewSymbol(">=")
	sym_B := lang.NewSymbol("B")
	sym_C := lang.NewSymbol("C")
	sym_F := lang.NewSymbol("F")
	sym_F_QMARK_ := lang.NewSymbol("F?")
	sym_I := lang.NewSymbol("I")
	sym_K := lang.NewSymbol("K")
	sym_L := lang.NewSymbol("L")
	sym_L_PLUS_ := lang.NewSymbol("L+")
	sym_M := lang.NewSymbol("M")
	sym_M_PLUS_ := lang.NewSymbol("M+")
	sym_N := lang.NewSymbol("N")
	sym_O := lang.NewSymbol("O")
	sym_O_PLUS_ := lang.NewSymbol("O+")
	sym_P := lang.NewSymbol("P")
	sym_R := lang.NewSymbol("R")
	sym_S := lang.NewSymbol("S")
	sym_Ss := lang.NewSymbol("Ss")
	sym_T := lang.NewSymbol("T")
	sym_T_QMARK_ := lang.NewSymbol("T?")
	sym_V := lang.NewSymbol("V")
	sym_V_PLUS_ := lang.NewSymbol("V+")
	sym__ := lang.NewSymbol("_")
	sym_a := lang.NewSymbol("a")
	sym_abs := lang.NewSymbol("abs")
	sym_abs_QMARK_ := lang.NewSymbol("abs?")
	sym_add := lang.NewSymbol("add")
	sym_add_PLUS_ := lang.NewSymbol("add+")
	sym_and_QMARK_ := lang.NewSymbol("and?")
	sym_apply := lang.NewSymbol("apply")
	sym_atom := lang.NewSymbol("atom")
	sym_atom_QMARK_ := lang.NewSymbol("atom?")
	sym_basename := lang.NewSymbol("basename")
	sym_bash := lang.NewSymbol("bash")
	sym_bash_DASH_out := lang.NewSymbol("bash-out")
	sym_bindings := lang.NewSymbol("bindings")
	sym_blank_QMARK_ := lang.NewSymbol("blank?")
	sym_body := lang.NewSymbol("body")
	sym_boolean := lang.NewSymbol("boolean")
	sym_boolean_QMARK_ := lang.NewSymbol("boolean?")
	sym_byte := lang.NewSymbol("byte")
	sym_call := lang.NewSymbol("call")
	sym_capitalize := lang.NewSymbol("capitalize")
	sym_cat := lang.NewSymbol("cat")
	sym_char := lang.NewSymbol("char")
	sym_char_QMARK_ := lang.NewSymbol("char?")
	sym_chomp := lang.NewSymbol("chomp")
	sym_chunk := lang.NewSymbol("chunk")
	sym_chunk_DASH_append := lang.NewSymbol("chunk-append")
	sym_chunk_DASH_buffer := lang.NewSymbol("chunk-buffer")
	sym_chunk_DASH_cons := lang.NewSymbol("chunk-cons")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_rest := lang.NewSymbol("chunk-rest")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_class_QMARK_ := lang.NewSymbol("class?")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH__STAR_ns_STAR_ := lang.NewSymbol("clojure.core/*ns*")
	sym_clojure_DOT_core_SLASH_and := lang.NewSymbol("clojure.core/and")
	sym_clojure_DOT_core_SLASH_condp := lang.NewSymbol("clojure.core/condp")
	sym_clojure_DOT_core_SLASH_doall := lang.NewSymbol("clojure.core/doall")
	sym_clojure_DOT_core_SLASH_for := lang.NewSymbol("clojure.core/for")
	sym_clojure_DOT_core_SLASH_hash_DASH_map := lang.NewSymbol("clojure.core/hash-map")
	sym_clojure_DOT_core_SLASH_ifn_QMARK_ := lang.NewSymbol("clojure.core/ifn?")
	sym_clojure_DOT_core_SLASH_let := lang.NewSymbol("clojure.core/let")
	sym_clojure_DOT_core_SLASH_list := lang.NewSymbol("clojure.core/list")
	sym_clojure_DOT_core_SLASH_ns_DASH_resolve := lang.NewSymbol("clojure.core/ns-resolve")
	sym_clojure_DOT_core_SLASH_or := lang.NewSymbol("clojure.core/or")
	sym_clojure_DOT_core_SLASH_pr_DASH_str := lang.NewSymbol("clojure.core/pr-str")
	sym_clojure_DOT_core_SLASH_string_QMARK_ := lang.NewSymbol("clojure.core/string?")
	sym_clojure_DOT_core_SLASH_symbol := lang.NewSymbol("clojure.core/symbol")
	sym_clojure_DOT_core_SLASH_symbol_QMARK_ := lang.NewSymbol("clojure.core/symbol?")
	sym_clojure_DOT_core_SLASH_var_DASH_get := lang.NewSymbol("clojure.core/var-get")
	sym_clojure_DOT_core_SLASH_var_QMARK_ := lang.NewSymbol("clojure.core/var?")
	sym_clojure_DOT_core_SLASH_vector := lang.NewSymbol("clojure.core/vector")
	sym_clojure_DOT_core_SLASH_when := lang.NewSymbol("clojure.core/when")
	sym_clojure_DOT_core_SLASH_when_DASH_not := lang.NewSymbol("clojure.core/when-not")
	sym_clojure_DOT_string := lang.NewSymbol("clojure.string")
	sym_clojure_DOT_string_SLASH_join := lang.NewSymbol("clojure.string/join")
	sym_comp := lang.NewSymbol("comp")
	sym_concat := lang.NewSymbol("concat")
	sym_conj := lang.NewSymbol("conj")
	sym_cons := lang.NewSymbol("cons")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_count := lang.NewSymbol("count")
	sym_d := lang.NewSymbol("d")
	sym_dec := lang.NewSymbol("dec")
	sym_dec_PLUS_ := lang.NewSymbol("dec+")
	sym_default := lang.NewSymbol("default")
	sym_die := lang.NewSymbol("die")
	sym_digits := lang.NewSymbol("digits")
	sym_dirname := lang.NewSymbol("dirname")
	sym_disj := lang.NewSymbol("disj")
	sym_dissoc := lang.NewSymbol("dissoc")
	sym_div := lang.NewSymbol("div")
	sym_div_PLUS_ := lang.NewSymbol("div+")
	sym_do := lang.NewSymbol("do")
	sym_double := lang.NewSymbol("double")
	sym_e := lang.NewSymbol("e")
	sym_each := lang.NewSymbol("each")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_ends_DASH_with_QMARK_ := lang.NewSymbol("ends-with?")
	sym_ends_QMARK_ := lang.NewSymbol("ends?")
	sym_eq := lang.NewSymbol("eq")
	sym_escape := lang.NewSymbol("escape")
	sym_f := lang.NewSymbol("f")
	sym_f__0__auto__ := lang.NewSymbol("f__0__auto__")
	sym_falsey_QMARK_ := lang.NewSymbol("falsey?")
	sym_filename := lang.NewSymbol("filename")
	sym_filter := lang.NewSymbol("filter")
	sym_first := lang.NewSymbol("first")
	sym_flat := lang.NewSymbol("flat")
	sym_flatten := lang.NewSymbol("flatten")
	sym_flip := lang.NewSymbol("flip")
	sym_float_QMARK_ := lang.NewSymbol("float?")
	sym_fn_STAR_ := lang.NewSymbol("fn*")
	sym_fn_QMARK_ := lang.NewSymbol("fn?")
	sym_fs_DASH_abs := lang.NewSymbol("fs-abs")
	sym_fs_DASH_abs_QMARK_ := lang.NewSymbol("fs-abs?")
	sym_fs_DASH_basename := lang.NewSymbol("fs-basename")
	sym_fs_DASH_d := lang.NewSymbol("fs-d")
	sym_fs_DASH_dirname := lang.NewSymbol("fs-dirname")
	sym_fs_DASH_e := lang.NewSymbol("fs-e")
	sym_fs_DASH_f := lang.NewSymbol("fs-f")
	sym_fs_DASH_filename := lang.NewSymbol("fs-filename")
	sym_fs_DASH_glob := lang.NewSymbol("fs-glob")
	sym_fs_DASH_l := lang.NewSymbol("fs-l")
	sym_fs_DASH_ls := lang.NewSymbol("fs-ls")
	sym_fs_DASH_mtime := lang.NewSymbol("fs-mtime")
	sym_fs_DASH_r := lang.NewSymbol("fs-r")
	sym_fs_DASH_rel := lang.NewSymbol("fs-rel")
	sym_fs_DASH_rel_QMARK_ := lang.NewSymbol("fs-rel?")
	sym_fs_DASH_s := lang.NewSymbol("fs-s")
	sym_fs_DASH_w := lang.NewSymbol("fs-w")
	sym_fs_DASH_which := lang.NewSymbol("fs-which")
	sym_fs_DASH_x := lang.NewSymbol("fs-x")
	sym_fs_DASH_z := lang.NewSymbol("fs-z")
	sym_ge := lang.NewSymbol("ge")
	sym_get := lang.NewSymbol("get")
	sym_get_PLUS_ := lang.NewSymbol("get+")
	sym_glob := lang.NewSymbol("glob")
	sym_grep := lang.NewSymbol("grep")
	sym_gt := lang.NewSymbol("gt")
	sym_has_QMARK_ := lang.NewSymbol("has?")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_identity := lang.NewSymbol("identity")
	sym_in_QMARK_ := lang.NewSymbol("in?")
	sym_inc := lang.NewSymbol("inc")
	sym_inc_PLUS_ := lang.NewSymbol("inc+")
	sym_includes_QMARK_ := lang.NewSymbol("includes?")
	sym_index := lang.NewSymbol("index")
	sym_index_DASH_of := lang.NewSymbol("index-of")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_int := lang.NewSymbol("int")
	sym_int_QMARK_ := lang.NewSymbol("int?")
	sym_into := lang.NewSymbol("into")
	sym_join := lang.NewSymbol("join")
	sym_joins := lang.NewSymbol("joins")
	sym_keys := lang.NewSymbol("keys")
	sym_keyword := lang.NewSymbol("keyword")
	sym_keyword_QMARK_ := lang.NewSymbol("keyword?")
	sym_ks := lang.NewSymbol("ks")
	sym_l := lang.NewSymbol("l")
	sym_last := lang.NewSymbol("last")
	sym_last_DASH_index_DASH_of := lang.NewSymbol("last-index-of")
	sym_lc := lang.NewSymbol("lc")
	sym_le := lang.NewSymbol("le")
	sym_len := lang.NewSymbol("len")
	sym_lines := lang.NewSymbol("lines")
	sym_list := lang.NewSymbol("list")
	sym_list_QMARK_ := lang.NewSymbol("list?")
	sym_long := lang.NewSymbol("long")
	sym_lower_DASH_case := lang.NewSymbol("lower-case")
	sym_ls := lang.NewSymbol("ls")
	sym_lt := lang.NewSymbol("lt")
	sym_map := lang.NewSymbol("map")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_mapcat := lang.NewSymbol("mapcat")
	sym_max := lang.NewSymbol("max")
	sym_merge := lang.NewSymbol("merge")
	sym_merge_DASH_with := lang.NewSymbol("merge-with")
	sym_mtime := lang.NewSymbol("mtime")
	sym_mul := lang.NewSymbol("mul")
	sym_mul_PLUS_ := lang.NewSymbol("mul+")
	sym_n := lang.NewSymbol("n")
	sym_ne := lang.NewSymbol("ne")
	sym_neg_QMARK_ := lang.NewSymbol("neg?")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_not := lang.NewSymbol("not")
	sym_not_EQ_ := lang.NewSymbol("not=")
	sym_nth := lang.NewSymbol("nth")
	sym_number_QMARK_ := lang.NewSymbol("number?")
	sym_off := lang.NewSymbol("off")
	sym_omap := lang.NewSymbol("omap")
	sym_op := lang.NewSymbol("op")
	sym_op_DASH_error := lang.NewSymbol("op-error")
	sym_or_QMARK_ := lang.NewSymbol("or?")
	sym_p1__18__1__auto__ := lang.NewSymbol("p1__18__1__auto__")
	sym_p2__19__2__auto__ := lang.NewSymbol("p2__19__2__auto__")
	sym_partial := lang.NewSymbol("partial")
	sym_pr_DASH_str := lang.NewSymbol("pr-str")
	sym_println := lang.NewSymbol("println")
	sym_process := lang.NewSymbol("process")
	sym_q := lang.NewSymbol("q")
	sym_ql := lang.NewSymbol("ql")
	sym_qm := lang.NewSymbol("qm")
	sym_qo := lang.NewSymbol("qo")
	sym_qr := lang.NewSymbol("qr")
	sym_qs := lang.NewSymbol("qs")
	sym_quote := lang.NewSymbol("quote")
	sym_qv := lang.NewSymbol("qv")
	sym_qw := lang.NewSymbol("qw")
	sym_r := lang.NewSymbol("r")
	sym_range := lang.NewSymbol("range")
	sym_ratio_QMARK_ := lang.NewSymbol("ratio?")
	sym_re_DASH_find := lang.NewSymbol("re-find")
	sym_re_DASH_matches := lang.NewSymbol("re-matches")
	sym_re_DASH_pattern := lang.NewSymbol("re-pattern")
	sym_read := lang.NewSymbol("read")
	sym_read_DASH_string := lang.NewSymbol("read-string")
	sym_reduce := lang.NewSymbol("reduce")
	sym_reduce_DASH_kv := lang.NewSymbol("reduce-kv")
	sym_regex_QMARK_ := lang.NewSymbol("regex?")
	sym_rel := lang.NewSymbol("rel")
	sym_rel_QMARK_ := lang.NewSymbol("rel?")
	sym_remove := lang.NewSymbol("remove")
	sym_repeat := lang.NewSymbol("repeat")
	sym_replace := lang.NewSymbol("replace")
	sym_replace_DASH_first := lang.NewSymbol("replace-first")
	sym_replace1 := lang.NewSymbol("replace1")
	sym_reset := lang.NewSymbol("reset")
	sym_reset_BANG_ := lang.NewSymbol("reset!")
	sym_rest := lang.NewSymbol("rest")
	sym_reverse := lang.NewSymbol("reverse")
	sym_rindex := lang.NewSymbol("rindex")
	sym_rng := lang.NewSymbol("rng")
	sym_s := lang.NewSymbol("s")
	sym_say := lang.NewSymbol("say")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_seqable_QMARK_ := lang.NewSymbol("seqable?")
	sym_sequential_QMARK_ := lang.NewSymbol("sequential?")
	sym_set := lang.NewSymbol("set")
	sym_set_QMARK_ := lang.NewSymbol("set?")
	sym_sh := lang.NewSymbol("sh")
	sym_sh_DASH_out := lang.NewSymbol("sh-out")
	sym_shell := lang.NewSymbol("shell")
	sym_slice := lang.NewSymbol("slice")
	sym_slurp := lang.NewSymbol("slurp")
	sym_some := lang.NewSymbol("some")
	sym_source := lang.NewSymbol("source")
	sym_spit := lang.NewSymbol("spit")
	sym_split := lang.NewSymbol("split")
	sym_sqrt := lang.NewSymbol("sqrt")
	sym_starts_DASH_with_QMARK_ := lang.NewSymbol("starts-with?")
	sym_starts_QMARK_ := lang.NewSymbol("starts?")
	sym_str := lang.NewSymbol("str")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_sub := lang.NewSymbol("sub")
	sym_sub_PLUS_ := lang.NewSymbol("sub+")
	sym_subs := lang.NewSymbol("subs")
	sym_substr := lang.NewSymbol("substr")
	sym_sum := lang.NewSymbol("sum")
	sym_swap := lang.NewSymbol("swap")
	sym_swap_BANG_ := lang.NewSymbol("swap!")
	sym_symbol := lang.NewSymbol("symbol")
	sym_symbol_QMARK_ := lang.NewSymbol("symbol?")
	sym_test := lang.NewSymbol("test")
	sym_text := lang.NewSymbol("text")
	sym_to_DASH_bool := lang.NewSymbol("to-bool")
	sym_to_DASH_char := lang.NewSymbol("to-char")
	sym_to_DASH_float := lang.NewSymbol("to-float")
	sym_to_DASH_int := lang.NewSymbol("to-int")
	sym_to_DASH_keyw := lang.NewSymbol("to-keyw")
	sym_to_DASH_list := lang.NewSymbol("to-list")
	sym_to_DASH_map := lang.NewSymbol("to-map")
	sym_to_DASH_num := lang.NewSymbol("to-num")
	sym_to_DASH_omap := lang.NewSymbol("to-omap")
	sym_to_DASH_set := lang.NewSymbol("to-set")
	sym_to_DASH_str := lang.NewSymbol("to-str")
	sym_to_DASH_type := lang.NewSymbol("to-type")
	sym_to_DASH_vec := lang.NewSymbol("to-vec")
	sym_trim := lang.NewSymbol("trim")
	sym_trim_DASH_newline := lang.NewSymbol("trim-newline")
	sym_triml := lang.NewSymbol("triml")
	sym_trimr := lang.NewSymbol("trimr")
	sym_truey_QMARK_ := lang.NewSymbol("truey?")
	sym_type := lang.NewSymbol("type")
	sym_uc := lang.NewSymbol("uc")
	sym_uc1 := lang.NewSymbol("uc1")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_upper_DASH_case := lang.NewSymbol("upper-case")
	sym_value := lang.NewSymbol("value")
	sym_var_QMARK_ := lang.NewSymbol("var?")
	sym_var__0__auto__ := lang.NewSymbol("var__0__auto__")
	sym_vec := lang.NewSymbol("vec")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_w := lang.NewSymbol("w")
	sym_when_PLUS_ := lang.NewSymbol("when+")
	sym_when_DASH_let := lang.NewSymbol("when-let")
	sym_which := lang.NewSymbol("which")
	sym_words := lang.NewSymbol("words")
	sym_write := lang.NewSymbol("write")
	sym_x := lang.NewSymbol("x")
	sym_xs := lang.NewSymbol("xs")
	sym_y := lang.NewSymbol("y")
	sym_yamlscript_DOT_util := lang.NewSymbol("yamlscript.util")
	sym_yamlscript_DOT_util_SLASH_die := lang.NewSymbol("yamlscript.util/die")
	sym_ys_DOT_fs := lang.NewSymbol("ys.fs")
	sym_ys_DOT_ipc := lang.NewSymbol("ys.ipc")
	sym_ys_DOT_std := lang.NewSymbol("ys.std")
	sym_ys_DOT_std_SLASH_and_QMARK_ := lang.NewSymbol("ys.std/and?")
	sym_ys_DOT_std_SLASH_falsey_QMARK_ := lang.NewSymbol("ys.std/falsey?")
	sym_ys_DOT_std_SLASH_omap := lang.NewSymbol("ys.std/omap")
	sym_ys_DOT_std_SLASH_or_QMARK_ := lang.NewSymbol("ys.std/or?")
	sym_ys_DOT_std_SLASH_truey_QMARK_ := lang.NewSymbol("ys.std/truey?")
	sym_ys_DOT_std_SLASH_value := lang.NewSymbol("ys.std/value")
	sym_z := lang.NewSymbol("z")
	sym_zero_QMARK_ := lang.NewSymbol("zero?")
	sym_zipmap := lang.NewSymbol("zipmap")
	sym__U007C__U007C__U007C_ := lang.NewSymbol("|||")
	kw__DASH__LT__LT_ := lang.NewKeyword("-<<")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_err := lang.NewKeyword("err")
	kw_exit := lang.NewKeyword("exit")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_out := lang.NewKeyword("out")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/-
	var_clojure_DOT_core__DASH_ := lang.InternVarName(sym_clojure_DOT_core, sym__DASH_)
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/>
	var_clojure_DOT_core__GT_ := lang.InternVarName(sym_clojure_DOT_core, sym__GT_)
	// var clojure.core/>=
	var_clojure_DOT_core__GT__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__GT__EQ_)
	// var clojure.core/<
	var_clojure_DOT_core__LT_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT_)
	// var clojure.core/<=
	var_clojure_DOT_core__LT__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT__EQ_)
	// var clojure.core/+
	var_clojure_DOT_core__PLUS_ := lang.InternVarName(sym_clojure_DOT_core, sym__PLUS_)
	// var clojure.core//
	var_clojure_DOT_core__SLASH_ := lang.InternVarName(sym_clojure_DOT_core, sym__SLASH_)
	// var clojure.core/*
	var_clojure_DOT_core__STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/atom
	var_clojure_DOT_core_atom := lang.InternVarName(sym_clojure_DOT_core, sym_atom)
	// var clojure.core/boolean
	var_clojure_DOT_core_boolean := lang.InternVarName(sym_clojure_DOT_core, sym_boolean)
	// var clojure.core/boolean?
	var_clojure_DOT_core_boolean_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_boolean_QMARK_)
	// var clojure.core/byte
	var_clojure_DOT_core_byte := lang.InternVarName(sym_clojure_DOT_core, sym_byte)
	// var clojure.core/cat
	var_clojure_DOT_core_cat := lang.InternVarName(sym_clojure_DOT_core, sym_cat)
	// var clojure.core/char
	var_clojure_DOT_core_char := lang.InternVarName(sym_clojure_DOT_core, sym_char)
	// var clojure.core/char?
	var_clojure_DOT_core_char_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_char_QMARK_)
	// var clojure.core/chunk
	var_clojure_DOT_core_chunk := lang.InternVarName(sym_clojure_DOT_core, sym_chunk)
	// var clojure.core/chunk-append
	var_clojure_DOT_core_chunk_DASH_append := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_append)
	// var clojure.core/chunk-buffer
	var_clojure_DOT_core_chunk_DASH_buffer := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_buffer)
	// var clojure.core/chunk-cons
	var_clojure_DOT_core_chunk_DASH_cons := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_cons)
	// var clojure.core/chunk-first
	var_clojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_first)
	// var clojure.core/chunk-rest
	var_clojure_DOT_core_chunk_DASH_rest := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_rest)
	// var clojure.core/chunked-seq?
	var_clojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var clojure.core/class?
	var_clojure_DOT_core_class_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_class_QMARK_)
	// var clojure.core/comp
	var_clojure_DOT_core_comp := lang.InternVarName(sym_clojure_DOT_core, sym_comp)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/conj
	var_clojure_DOT_core_conj := lang.InternVarName(sym_clojure_DOT_core, sym_conj)
	// var clojure.core/cons
	var_clojure_DOT_core_cons := lang.InternVarName(sym_clojure_DOT_core, sym_cons)
	// var clojure.core/contains?
	var_clojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_contains_QMARK_)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/dec
	var_clojure_DOT_core_dec := lang.InternVarName(sym_clojure_DOT_core, sym_dec)
	// var clojure.core/disj
	var_clojure_DOT_core_disj := lang.InternVarName(sym_clojure_DOT_core, sym_disj)
	// var clojure.core/dissoc
	var_clojure_DOT_core_dissoc := lang.InternVarName(sym_clojure_DOT_core, sym_dissoc)
	// var clojure.core/double
	var_clojure_DOT_core_double := lang.InternVarName(sym_clojure_DOT_core, sym_double)
	// var clojure.core/empty?
	var_clojure_DOT_core_empty_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_empty_QMARK_)
	// var clojure.core/filter
	var_clojure_DOT_core_filter := lang.InternVarName(sym_clojure_DOT_core, sym_filter)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/flatten
	var_clojure_DOT_core_flatten := lang.InternVarName(sym_clojure_DOT_core, sym_flatten)
	// var clojure.core/float?
	var_clojure_DOT_core_float_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_float_QMARK_)
	// var clojure.core/fn?
	var_clojure_DOT_core_fn_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_fn_QMARK_)
	// var clojure.core/get
	var_clojure_DOT_core_get := lang.InternVarName(sym_clojure_DOT_core, sym_get)
	// var clojure.core/hash-map
	var_clojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_clojure_DOT_core, sym_hash_DASH_map)
	// var clojure.core/identity
	var_clojure_DOT_core_identity := lang.InternVarName(sym_clojure_DOT_core, sym_identity)
	// var clojure.core/inc
	var_clojure_DOT_core_inc := lang.InternVarName(sym_clojure_DOT_core, sym_inc)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/int
	var_clojure_DOT_core_int := lang.InternVarName(sym_clojure_DOT_core, sym_int)
	// var clojure.core/int?
	var_clojure_DOT_core_int_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_int_QMARK_)
	// var clojure.core/into
	var_clojure_DOT_core_into := lang.InternVarName(sym_clojure_DOT_core, sym_into)
	// var clojure.core/keys
	var_clojure_DOT_core_keys := lang.InternVarName(sym_clojure_DOT_core, sym_keys)
	// var clojure.core/keyword
	var_clojure_DOT_core_keyword := lang.InternVarName(sym_clojure_DOT_core, sym_keyword)
	// var clojure.core/keyword?
	var_clojure_DOT_core_keyword_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_keyword_QMARK_)
	// var clojure.core/last
	var_clojure_DOT_core_last := lang.InternVarName(sym_clojure_DOT_core, sym_last)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/list?
	var_clojure_DOT_core_list_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_list_QMARK_)
	// var clojure.core/long
	var_clojure_DOT_core_long := lang.InternVarName(sym_clojure_DOT_core, sym_long)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/map?
	var_clojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_map_QMARK_)
	// var clojure.core/mapcat
	var_clojure_DOT_core_mapcat := lang.InternVarName(sym_clojure_DOT_core, sym_mapcat)
	// var clojure.core/max
	var_clojure_DOT_core_max := lang.InternVarName(sym_clojure_DOT_core, sym_max)
	// var clojure.core/merge
	var_clojure_DOT_core_merge := lang.InternVarName(sym_clojure_DOT_core, sym_merge)
	// var clojure.core/merge-with
	var_clojure_DOT_core_merge_DASH_with := lang.InternVarName(sym_clojure_DOT_core, sym_merge_DASH_with)
	// var clojure.core/neg?
	var_clojure_DOT_core_neg_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_neg_QMARK_)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/not
	var_clojure_DOT_core_not := lang.InternVarName(sym_clojure_DOT_core, sym_not)
	// var clojure.core/not=
	var_clojure_DOT_core_not_EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym_not_EQ_)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/number?
	var_clojure_DOT_core_number_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_number_QMARK_)
	// var clojure.core/partial
	var_clojure_DOT_core_partial := lang.InternVarName(sym_clojure_DOT_core, sym_partial)
	// var clojure.core/pr-str
	var_clojure_DOT_core_pr_DASH_str := lang.InternVarName(sym_clojure_DOT_core, sym_pr_DASH_str)
	// var clojure.core/println
	var_clojure_DOT_core_println := lang.InternVarName(sym_clojure_DOT_core, sym_println)
	// var clojure.core/range
	var_clojure_DOT_core_range := lang.InternVarName(sym_clojure_DOT_core, sym_range)
	// var clojure.core/ratio?
	var_clojure_DOT_core_ratio_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_ratio_QMARK_)
	// var clojure.core/re-find
	var_clojure_DOT_core_re_DASH_find := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_find)
	// var clojure.core/re-matches
	var_clojure_DOT_core_re_DASH_matches := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_matches)
	// var clojure.core/re-pattern
	var_clojure_DOT_core_re_DASH_pattern := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_pattern)
	// var clojure.core/read-string
	var_clojure_DOT_core_read_DASH_string := lang.InternVarName(sym_clojure_DOT_core, sym_read_DASH_string)
	// var clojure.core/reduce
	var_clojure_DOT_core_reduce := lang.InternVarName(sym_clojure_DOT_core, sym_reduce)
	// var clojure.core/reduce-kv
	var_clojure_DOT_core_reduce_DASH_kv := lang.InternVarName(sym_clojure_DOT_core, sym_reduce_DASH_kv)
	// var clojure.core/remove
	var_clojure_DOT_core_remove := lang.InternVarName(sym_clojure_DOT_core, sym_remove)
	// var clojure.core/repeat
	var_clojure_DOT_core_repeat := lang.InternVarName(sym_clojure_DOT_core, sym_repeat)
	// var clojure.core/replace
	var_clojure_DOT_core_replace := lang.InternVarName(sym_clojure_DOT_core, sym_replace)
	// var clojure.core/reset!
	var_clojure_DOT_core_reset_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_reset_BANG_)
	// var clojure.core/rest
	var_clojure_DOT_core_rest := lang.InternVarName(sym_clojure_DOT_core, sym_rest)
	// var clojure.core/reverse
	var_clojure_DOT_core_reverse := lang.InternVarName(sym_clojure_DOT_core, sym_reverse)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/seq?
	var_clojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seq_QMARK_)
	// var clojure.core/seqable?
	var_clojure_DOT_core_seqable_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seqable_QMARK_)
	// var clojure.core/sequential?
	var_clojure_DOT_core_sequential_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_sequential_QMARK_)
	// var clojure.core/set
	var_clojure_DOT_core_set := lang.InternVarName(sym_clojure_DOT_core, sym_set)
	// var clojure.core/set?
	var_clojure_DOT_core_set_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_set_QMARK_)
	// var clojure.core/slurp
	var_clojure_DOT_core_slurp := lang.InternVarName(sym_clojure_DOT_core, sym_slurp)
	// var clojure.core/some
	var_clojure_DOT_core_some := lang.InternVarName(sym_clojure_DOT_core, sym_some)
	// var clojure.core/spit
	var_clojure_DOT_core_spit := lang.InternVarName(sym_clojure_DOT_core, sym_spit)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/string?
	var_clojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_string_QMARK_)
	// var clojure.core/subs
	var_clojure_DOT_core_subs := lang.InternVarName(sym_clojure_DOT_core, sym_subs)
	// var clojure.core/swap!
	var_clojure_DOT_core_swap_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_swap_BANG_)
	// var clojure.core/symbol
	var_clojure_DOT_core_symbol := lang.InternVarName(sym_clojure_DOT_core, sym_symbol)
	// var clojure.core/symbol?
	var_clojure_DOT_core_symbol_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_symbol_QMARK_)
	// var clojure.core/type
	var_clojure_DOT_core_type := lang.InternVarName(sym_clojure_DOT_core, sym_type)
	// var clojure.core/unchecked-inc
	var_clojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_clojure_DOT_core, sym_unchecked_DASH_inc)
	// var clojure.core/var?
	var_clojure_DOT_core_var_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_var_QMARK_)
	// var clojure.core/vec
	var_clojure_DOT_core_vec := lang.InternVarName(sym_clojure_DOT_core, sym_vec)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/vector?
	var_clojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_vector_QMARK_)
	// var clojure.core/zero?
	var_clojure_DOT_core_zero_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_zero_QMARK_)
	// var clojure.core/zipmap
	var_clojure_DOT_core_zipmap := lang.InternVarName(sym_clojure_DOT_core, sym_zipmap)
	// var clojure.string/blank?
	var_clojure_DOT_string_blank_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_blank_QMARK_)
	// var clojure.string/capitalize
	var_clojure_DOT_string_capitalize := lang.InternVarName(sym_clojure_DOT_string, sym_capitalize)
	// var clojure.string/ends-with?
	var_clojure_DOT_string_ends_DASH_with_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_ends_DASH_with_QMARK_)
	// var clojure.string/escape
	var_clojure_DOT_string_escape := lang.InternVarName(sym_clojure_DOT_string, sym_escape)
	// var clojure.string/includes?
	var_clojure_DOT_string_includes_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_includes_QMARK_)
	// var clojure.string/index-of
	var_clojure_DOT_string_index_DASH_of := lang.InternVarName(sym_clojure_DOT_string, sym_index_DASH_of)
	// var clojure.string/join
	var_clojure_DOT_string_join := lang.InternVarName(sym_clojure_DOT_string, sym_join)
	// var clojure.string/last-index-of
	var_clojure_DOT_string_last_DASH_index_DASH_of := lang.InternVarName(sym_clojure_DOT_string, sym_last_DASH_index_DASH_of)
	// var clojure.string/lower-case
	var_clojure_DOT_string_lower_DASH_case := lang.InternVarName(sym_clojure_DOT_string, sym_lower_DASH_case)
	// var clojure.string/replace
	var_clojure_DOT_string_replace := lang.InternVarName(sym_clojure_DOT_string, sym_replace)
	// var clojure.string/replace-first
	var_clojure_DOT_string_replace_DASH_first := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_first)
	// var clojure.string/reverse
	var_clojure_DOT_string_reverse := lang.InternVarName(sym_clojure_DOT_string, sym_reverse)
	// var clojure.string/split
	var_clojure_DOT_string_split := lang.InternVarName(sym_clojure_DOT_string, sym_split)
	// var clojure.string/starts-with?
	var_clojure_DOT_string_starts_DASH_with_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_starts_DASH_with_QMARK_)
	// var clojure.string/trim
	var_clojure_DOT_string_trim := lang.InternVarName(sym_clojure_DOT_string, sym_trim)
	// var clojure.string/trim-newline
	var_clojure_DOT_string_trim_DASH_newline := lang.InternVarName(sym_clojure_DOT_string, sym_trim_DASH_newline)
	// var clojure.string/triml
	var_clojure_DOT_string_triml := lang.InternVarName(sym_clojure_DOT_string, sym_triml)
	// var clojure.string/trimr
	var_clojure_DOT_string_trimr := lang.InternVarName(sym_clojure_DOT_string, sym_trimr)
	// var clojure.string/upper-case
	var_clojure_DOT_string_upper_DASH_case := lang.InternVarName(sym_clojure_DOT_string, sym_upper_DASH_case)
	// var yamlscript.util/atom?
	var_yamlscript_DOT_util_atom_QMARK_ := lang.InternVarName(sym_yamlscript_DOT_util, sym_atom_QMARK_)
	// var yamlscript.util/die
	var_yamlscript_DOT_util_die := lang.InternVarName(sym_yamlscript_DOT_util, sym_die)
	// var ys.fs/abs
	var_ys_DOT_fs_abs := lang.InternVarName(sym_ys_DOT_fs, sym_abs)
	// var ys.fs/abs?
	var_ys_DOT_fs_abs_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_abs_QMARK_)
	// var ys.fs/basename
	var_ys_DOT_fs_basename := lang.InternVarName(sym_ys_DOT_fs, sym_basename)
	// var ys.fs/d
	var_ys_DOT_fs_d := lang.InternVarName(sym_ys_DOT_fs, sym_d)
	// var ys.fs/dirname
	var_ys_DOT_fs_dirname := lang.InternVarName(sym_ys_DOT_fs, sym_dirname)
	// var ys.fs/e
	var_ys_DOT_fs_e := lang.InternVarName(sym_ys_DOT_fs, sym_e)
	// var ys.fs/f
	var_ys_DOT_fs_f := lang.InternVarName(sym_ys_DOT_fs, sym_f)
	// var ys.fs/filename
	var_ys_DOT_fs_filename := lang.InternVarName(sym_ys_DOT_fs, sym_filename)
	// var ys.fs/glob
	var_ys_DOT_fs_glob := lang.InternVarName(sym_ys_DOT_fs, sym_glob)
	// var ys.fs/l
	var_ys_DOT_fs_l := lang.InternVarName(sym_ys_DOT_fs, sym_l)
	// var ys.fs/ls
	var_ys_DOT_fs_ls := lang.InternVarName(sym_ys_DOT_fs, sym_ls)
	// var ys.fs/mtime
	var_ys_DOT_fs_mtime := lang.InternVarName(sym_ys_DOT_fs, sym_mtime)
	// var ys.fs/r
	var_ys_DOT_fs_r := lang.InternVarName(sym_ys_DOT_fs, sym_r)
	// var ys.fs/rel
	var_ys_DOT_fs_rel := lang.InternVarName(sym_ys_DOT_fs, sym_rel)
	// var ys.fs/rel?
	var_ys_DOT_fs_rel_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_rel_QMARK_)
	// var ys.fs/s
	var_ys_DOT_fs_s := lang.InternVarName(sym_ys_DOT_fs, sym_s)
	// var ys.fs/w
	var_ys_DOT_fs_w := lang.InternVarName(sym_ys_DOT_fs, sym_w)
	// var ys.fs/which
	var_ys_DOT_fs_which := lang.InternVarName(sym_ys_DOT_fs, sym_which)
	// var ys.fs/x
	var_ys_DOT_fs_x := lang.InternVarName(sym_ys_DOT_fs, sym_x)
	// var ys.fs/z
	var_ys_DOT_fs_z := lang.InternVarName(sym_ys_DOT_fs, sym_z)
	// var ys.ipc/process
	var_ys_DOT_ipc_process := lang.InternVarName(sym_ys_DOT_ipc, sym_process)
	// var ys.ipc/sh
	var_ys_DOT_ipc_sh := lang.InternVarName(sym_ys_DOT_ipc, sym_sh)
	// var ys.ipc/shell
	var_ys_DOT_ipc_shell := lang.InternVarName(sym_ys_DOT_ipc, sym_shell)
	// var ys.std/B
	var_ys_DOT_std_B := lang.InternVarName(sym_ys_DOT_std, sym_B)
	// var ys.std/C
	var_ys_DOT_std_C := lang.InternVarName(sym_ys_DOT_std, sym_C)
	// var ys.std/F
	var_ys_DOT_std_F := lang.InternVarName(sym_ys_DOT_std, sym_F)
	// var ys.std/F?
	var_ys_DOT_std_F_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_F_QMARK_)
	// var ys.std/I
	var_ys_DOT_std_I := lang.InternVarName(sym_ys_DOT_std, sym_I)
	// var ys.std/K
	var_ys_DOT_std_K := lang.InternVarName(sym_ys_DOT_std, sym_K)
	// var ys.std/L
	var_ys_DOT_std_L := lang.InternVarName(sym_ys_DOT_std, sym_L)
	// var ys.std/L+
	var_ys_DOT_std_L_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_L_PLUS_)
	// var ys.std/M
	var_ys_DOT_std_M := lang.InternVarName(sym_ys_DOT_std, sym_M)
	// var ys.std/M+
	var_ys_DOT_std_M_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_M_PLUS_)
	// var ys.std/N
	var_ys_DOT_std_N := lang.InternVarName(sym_ys_DOT_std, sym_N)
	// var ys.std/O
	var_ys_DOT_std_O := lang.InternVarName(sym_ys_DOT_std, sym_O)
	// var ys.std/O+
	var_ys_DOT_std_O_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_O_PLUS_)
	// var ys.std/S
	var_ys_DOT_std_S := lang.InternVarName(sym_ys_DOT_std, sym_S)
	// var ys.std/T
	var_ys_DOT_std_T := lang.InternVarName(sym_ys_DOT_std, sym_T)
	// var ys.std/T?
	var_ys_DOT_std_T_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_T_QMARK_)
	// var ys.std/V
	var_ys_DOT_std_V := lang.InternVarName(sym_ys_DOT_std, sym_V)
	// var ys.std/V+
	var_ys_DOT_std_V_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_V_PLUS_)
	// var ys.std/&&&
	var_ys_DOT_std__AMP__AMP__AMP_ := lang.InternVarName(sym_ys_DOT_std, sym__AMP__AMP__AMP_)
	// var ys.std/!---
	var_ys_DOT_std__BANG__DASH__DASH__DASH_ := lang.InternVarName(sym_ys_DOT_std, sym__BANG__DASH__DASH__DASH_)
	// var ys.std/=---
	var_ys_DOT_std__EQ__DASH__DASH__DASH_ := lang.InternVarName(sym_ys_DOT_std, sym__EQ__DASH__DASH__DASH_)
	// var ys.std/%
	var_ys_DOT_std__PCT_ := lang.InternVarName(sym_ys_DOT_std, sym__PCT_)
	// var ys.std/+concat
	var_ys_DOT_std__PLUS_concat := lang.InternVarName(sym_ys_DOT_std, sym__PLUS_concat)
	// var ys.std/+merge
	var_ys_DOT_std__PLUS_merge := lang.InternVarName(sym_ys_DOT_std, sym__PLUS_merge)
	// var ys.std/|||
	var_ys_DOT_std__U007C__U007C__U007C_ := lang.InternVarName(sym_ys_DOT_std, sym__U007C__U007C__U007C_)
	// var ys.std/a
	var_ys_DOT_std_a := lang.InternVarName(sym_ys_DOT_std, sym_a)
	// var ys.std/add
	var_ys_DOT_std_add := lang.InternVarName(sym_ys_DOT_std, sym_add)
	// var ys.std/add+
	var_ys_DOT_std_add_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_add_PLUS_)
	// var ys.std/and?
	var_ys_DOT_std_and_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_and_QMARK_)
	// var ys.std/atom
	var_ys_DOT_std_atom := lang.InternVarName(sym_ys_DOT_std, sym_atom)
	// var ys.std/bash
	var_ys_DOT_std_bash := lang.InternVarName(sym_ys_DOT_std, sym_bash)
	// var ys.std/bash-out
	var_ys_DOT_std_bash_DASH_out := lang.InternVarName(sym_ys_DOT_std, sym_bash_DASH_out)
	// var ys.std/blank?
	var_ys_DOT_std_blank_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_blank_QMARK_)
	// var ys.std/call
	var_ys_DOT_std_call := lang.InternVarName(sym_ys_DOT_std, sym_call)
	// var ys.std/chomp
	var_ys_DOT_std_chomp := lang.InternVarName(sym_ys_DOT_std, sym_chomp)
	// var ys.std/dec+
	var_ys_DOT_std_dec_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_dec_PLUS_)
	// var ys.std/die
	var_ys_DOT_std_die := lang.InternVarName(sym_ys_DOT_std, sym_die)
	// var ys.std/digits
	var_ys_DOT_std_digits := lang.InternVarName(sym_ys_DOT_std, sym_digits)
	// var ys.std/div
	var_ys_DOT_std_div := lang.InternVarName(sym_ys_DOT_std, sym_div)
	// var ys.std/div+
	var_ys_DOT_std_div_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_div_PLUS_)
	// var ys.std/each
	var_ys_DOT_std_each := lang.InternVarName(sym_ys_DOT_std, sym_each)
	// var ys.std/ends?
	var_ys_DOT_std_ends_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_ends_QMARK_)
	// var ys.std/eq
	var_ys_DOT_std_eq := lang.InternVarName(sym_ys_DOT_std, sym_eq)
	// var ys.std/escape
	var_ys_DOT_std_escape := lang.InternVarName(sym_ys_DOT_std, sym_escape)
	// var ys.std/falsey?
	var_ys_DOT_std_falsey_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_falsey_QMARK_)
	// var ys.std/flat
	var_ys_DOT_std_flat := lang.InternVarName(sym_ys_DOT_std, sym_flat)
	// var ys.std/flip
	var_ys_DOT_std_flip := lang.InternVarName(sym_ys_DOT_std, sym_flip)
	// var ys.std/fs-abs
	var_ys_DOT_std_fs_DASH_abs := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_abs)
	// var ys.std/fs-abs?
	var_ys_DOT_std_fs_DASH_abs_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_abs_QMARK_)
	// var ys.std/fs-basename
	var_ys_DOT_std_fs_DASH_basename := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_basename)
	// var ys.std/fs-d
	var_ys_DOT_std_fs_DASH_d := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_d)
	// var ys.std/fs-dirname
	var_ys_DOT_std_fs_DASH_dirname := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_dirname)
	// var ys.std/fs-e
	var_ys_DOT_std_fs_DASH_e := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_e)
	// var ys.std/fs-f
	var_ys_DOT_std_fs_DASH_f := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_f)
	// var ys.std/fs-filename
	var_ys_DOT_std_fs_DASH_filename := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_filename)
	// var ys.std/fs-glob
	var_ys_DOT_std_fs_DASH_glob := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_glob)
	// var ys.std/fs-l
	var_ys_DOT_std_fs_DASH_l := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_l)
	// var ys.std/fs-ls
	var_ys_DOT_std_fs_DASH_ls := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_ls)
	// var ys.std/fs-mtime
	var_ys_DOT_std_fs_DASH_mtime := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_mtime)
	// var ys.std/fs-r
	var_ys_DOT_std_fs_DASH_r := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_r)
	// var ys.std/fs-rel
	var_ys_DOT_std_fs_DASH_rel := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_rel)
	// var ys.std/fs-rel?
	var_ys_DOT_std_fs_DASH_rel_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_rel_QMARK_)
	// var ys.std/fs-s
	var_ys_DOT_std_fs_DASH_s := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_s)
	// var ys.std/fs-w
	var_ys_DOT_std_fs_DASH_w := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_w)
	// var ys.std/fs-which
	var_ys_DOT_std_fs_DASH_which := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_which)
	// var ys.std/fs-x
	var_ys_DOT_std_fs_DASH_x := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_x)
	// var ys.std/fs-z
	var_ys_DOT_std_fs_DASH_z := lang.InternVarName(sym_ys_DOT_std, sym_fs_DASH_z)
	// var ys.std/ge
	var_ys_DOT_std_ge := lang.InternVarName(sym_ys_DOT_std, sym_ge)
	// var ys.std/get+
	var_ys_DOT_std_get_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_get_PLUS_)
	// var ys.std/grep
	var_ys_DOT_std_grep := lang.InternVarName(sym_ys_DOT_std, sym_grep)
	// var ys.std/gt
	var_ys_DOT_std_gt := lang.InternVarName(sym_ys_DOT_std, sym_gt)
	// var ys.std/has?
	var_ys_DOT_std_has_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_has_QMARK_)
	// var ys.std/in?
	var_ys_DOT_std_in_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_in_QMARK_)
	// var ys.std/inc+
	var_ys_DOT_std_inc_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_inc_PLUS_)
	// var ys.std/index
	var_ys_DOT_std_index := lang.InternVarName(sym_ys_DOT_std, sym_index)
	// var ys.std/join
	var_ys_DOT_std_join := lang.InternVarName(sym_ys_DOT_std, sym_join)
	// var ys.std/joins
	var_ys_DOT_std_joins := lang.InternVarName(sym_ys_DOT_std, sym_joins)
	// var ys.std/lc
	var_ys_DOT_std_lc := lang.InternVarName(sym_ys_DOT_std, sym_lc)
	// var ys.std/le
	var_ys_DOT_std_le := lang.InternVarName(sym_ys_DOT_std, sym_le)
	// var ys.std/len
	var_ys_DOT_std_len := lang.InternVarName(sym_ys_DOT_std, sym_len)
	// var ys.std/lines
	var_ys_DOT_std_lines := lang.InternVarName(sym_ys_DOT_std, sym_lines)
	// var ys.std/lt
	var_ys_DOT_std_lt := lang.InternVarName(sym_ys_DOT_std, sym_lt)
	// var ys.std/mul
	var_ys_DOT_std_mul := lang.InternVarName(sym_ys_DOT_std, sym_mul)
	// var ys.std/mul+
	var_ys_DOT_std_mul_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_mul_PLUS_)
	// var ys.std/ne
	var_ys_DOT_std_ne := lang.InternVarName(sym_ys_DOT_std, sym_ne)
	// var ys.std/omap
	var_ys_DOT_std_omap := lang.InternVarName(sym_ys_DOT_std, sym_omap)
	// var ys.std/op-error
	var_ys_DOT_std_op_DASH_error := lang.InternVarName(sym_ys_DOT_std, sym_op_DASH_error)
	// var ys.std/or?
	var_ys_DOT_std_or_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_or_QMARK_)
	// var ys.std/process
	var_ys_DOT_std_process := lang.InternVarName(sym_ys_DOT_std, sym_process)
	// var ys.std/q
	var_ys_DOT_std_q := lang.InternVarName(sym_ys_DOT_std, sym_q)
	// var ys.std/ql
	var_ys_DOT_std_ql := lang.InternVarName(sym_ys_DOT_std, sym_ql)
	// var ys.std/qm
	var_ys_DOT_std_qm := lang.InternVarName(sym_ys_DOT_std, sym_qm)
	// var ys.std/qo
	var_ys_DOT_std_qo := lang.InternVarName(sym_ys_DOT_std, sym_qo)
	// var ys.std/qr
	var_ys_DOT_std_qr := lang.InternVarName(sym_ys_DOT_std, sym_qr)
	// var ys.std/qs
	var_ys_DOT_std_qs := lang.InternVarName(sym_ys_DOT_std, sym_qs)
	// var ys.std/qv
	var_ys_DOT_std_qv := lang.InternVarName(sym_ys_DOT_std, sym_qv)
	// var ys.std/qw
	var_ys_DOT_std_qw := lang.InternVarName(sym_ys_DOT_std, sym_qw)
	// var ys.std/read
	var_ys_DOT_std_read := lang.InternVarName(sym_ys_DOT_std, sym_read)
	// var ys.std/regex?
	var_ys_DOT_std_regex_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_regex_QMARK_)
	// var ys.std/replace
	var_ys_DOT_std_replace := lang.InternVarName(sym_ys_DOT_std, sym_replace)
	// var ys.std/replace1
	var_ys_DOT_std_replace1 := lang.InternVarName(sym_ys_DOT_std, sym_replace1)
	// var ys.std/reset
	var_ys_DOT_std_reset := lang.InternVarName(sym_ys_DOT_std, sym_reset)
	// var ys.std/reverse
	var_ys_DOT_std_reverse := lang.InternVarName(sym_ys_DOT_std, sym_reverse)
	// var ys.std/rindex
	var_ys_DOT_std_rindex := lang.InternVarName(sym_ys_DOT_std, sym_rindex)
	// var ys.std/rng
	var_ys_DOT_std_rng := lang.InternVarName(sym_ys_DOT_std, sym_rng)
	// var ys.std/say
	var_ys_DOT_std_say := lang.InternVarName(sym_ys_DOT_std, sym_say)
	// var ys.std/set
	var_ys_DOT_std_set := lang.InternVarName(sym_ys_DOT_std, sym_set)
	// var ys.std/sh
	var_ys_DOT_std_sh := lang.InternVarName(sym_ys_DOT_std, sym_sh)
	// var ys.std/sh-out
	var_ys_DOT_std_sh_DASH_out := lang.InternVarName(sym_ys_DOT_std, sym_sh_DASH_out)
	// var ys.std/shell
	var_ys_DOT_std_shell := lang.InternVarName(sym_ys_DOT_std, sym_shell)
	// var ys.std/slice
	var_ys_DOT_std_slice := lang.InternVarName(sym_ys_DOT_std, sym_slice)
	// var ys.std/source
	var_ys_DOT_std_source := lang.InternVarName(sym_ys_DOT_std, sym_source)
	// var ys.std/split
	var_ys_DOT_std_split := lang.InternVarName(sym_ys_DOT_std, sym_split)
	// var ys.std/sqrt
	var_ys_DOT_std_sqrt := lang.InternVarName(sym_ys_DOT_std, sym_sqrt)
	// var ys.std/starts?
	var_ys_DOT_std_starts_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_starts_QMARK_)
	// var ys.std/sub
	var_ys_DOT_std_sub := lang.InternVarName(sym_ys_DOT_std, sym_sub)
	// var ys.std/sub+
	var_ys_DOT_std_sub_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_sub_PLUS_)
	// var ys.std/substr
	var_ys_DOT_std_substr := lang.InternVarName(sym_ys_DOT_std, sym_substr)
	// var ys.std/sum
	var_ys_DOT_std_sum := lang.InternVarName(sym_ys_DOT_std, sym_sum)
	// var ys.std/swap
	var_ys_DOT_std_swap := lang.InternVarName(sym_ys_DOT_std, sym_swap)
	// var ys.std/text
	var_ys_DOT_std_text := lang.InternVarName(sym_ys_DOT_std, sym_text)
	// var ys.std/to-bool
	var_ys_DOT_std_to_DASH_bool := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_bool)
	// var ys.std/to-char
	var_ys_DOT_std_to_DASH_char := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_char)
	// var ys.std/to-float
	var_ys_DOT_std_to_DASH_float := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_float)
	// var ys.std/to-int
	var_ys_DOT_std_to_DASH_int := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_int)
	// var ys.std/to-keyw
	var_ys_DOT_std_to_DASH_keyw := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_keyw)
	// var ys.std/to-list
	var_ys_DOT_std_to_DASH_list := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_list)
	// var ys.std/to-map
	var_ys_DOT_std_to_DASH_map := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_map)
	// var ys.std/to-num
	var_ys_DOT_std_to_DASH_num := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_num)
	// var ys.std/to-omap
	var_ys_DOT_std_to_DASH_omap := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_omap)
	// var ys.std/to-set
	var_ys_DOT_std_to_DASH_set := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_set)
	// var ys.std/to-str
	var_ys_DOT_std_to_DASH_str := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_str)
	// var ys.std/to-type
	var_ys_DOT_std_to_DASH_type := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_type)
	// var ys.std/to-vec
	var_ys_DOT_std_to_DASH_vec := lang.InternVarName(sym_ys_DOT_std, sym_to_DASH_vec)
	// var ys.std/trim
	var_ys_DOT_std_trim := lang.InternVarName(sym_ys_DOT_std, sym_trim)
	// var ys.std/triml
	var_ys_DOT_std_triml := lang.InternVarName(sym_ys_DOT_std, sym_triml)
	// var ys.std/trimr
	var_ys_DOT_std_trimr := lang.InternVarName(sym_ys_DOT_std, sym_trimr)
	// var ys.std/truey?
	var_ys_DOT_std_truey_QMARK_ := lang.InternVarName(sym_ys_DOT_std, sym_truey_QMARK_)
	// var ys.std/uc
	var_ys_DOT_std_uc := lang.InternVarName(sym_ys_DOT_std, sym_uc)
	// var ys.std/uc1
	var_ys_DOT_std_uc1 := lang.InternVarName(sym_ys_DOT_std, sym_uc1)
	// var ys.std/value
	var_ys_DOT_std_value := lang.InternVarName(sym_ys_DOT_std, sym_value)
	// var ys.std/when+
	var_ys_DOT_std_when_PLUS_ := lang.InternVarName(sym_ys_DOT_std, sym_when_PLUS_)
	// var ys.std/words
	var_ys_DOT_std_words := lang.InternVarName(sym_ys_DOT_std, sym_words)
	// var ys.std/write
	var_ys_DOT_std_write := lang.InternVarName(sym_ys_DOT_std, sym_write)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_ys_DOT_std)
	_ = ns
	// source
	{
		tmp0 := sym_source.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(1038), kw_column, int(11), kw_end_DASH_line, int(1038), kw_end_DASH_column, int(16), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				return nil
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_source = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_source.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// B
	{
		tmp0 := sym_B.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(755), kw_column, int(18), kw_end_DASH_line, int(755), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_bool)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(755), kw_column, int(20), kw_end_DASH_line, int(755), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_B = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_B.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// C
	{
		tmp0 := sym_C.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(757), kw_column, int(18), kw_end_DASH_line, int(757), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_char)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(757), kw_column, int(20), kw_end_DASH_line, int(757), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_C = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_C.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// F
	{
		tmp0 := sym_F.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(759), kw_column, int(18), kw_end_DASH_line, int(759), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_float)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(759), kw_column, int(20), kw_end_DASH_line, int(759), kw_end_DASH_column, int(40))).(lang.FnFunc)
		var_ys_DOT_std_F = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_F.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// F?
	{
		tmp0 := sym_F_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(799), kw_column, int(11), kw_end_DASH_line, int(799), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp7 := checkDerefVar(var_clojure_DOT_core_list)
			tmp8 := lang.Apply(tmp7, []any{sym_ys_DOT_std_SLASH_falsey_QMARK_})
			tmp9 := checkDerefVar(var_clojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{v4})
			tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10})
			tmp12 := lang.Apply(tmp5, []any{tmp11})
			return tmp12
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_F_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_F_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// I
	{
		tmp0 := sym_I.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(760), kw_column, int(18), kw_end_DASH_line, int(760), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_long)
			tmp4 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_I = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_I.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// K
	{
		tmp0 := sym_K.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(762), kw_column, int(18), kw_end_DASH_line, int(762), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_keyw)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(762), kw_column, int(20), kw_end_DASH_line, int(762), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_K = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_K.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// L
	{
		tmp0 := sym_L.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(764), kw_column, int(18), kw_end_DASH_line, int(764), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_list)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(764), kw_column, int(20), kw_end_DASH_line, int(764), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_L = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_L.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// L+
	{
		tmp0 := sym_L_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(779), kw_column, int(18), kw_end_DASH_line, int(779), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_list)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(779), kw_column, int(21), kw_end_DASH_line, int(779), kw_end_DASH_column, int(51))).(lang.FnFunc)
		var_ys_DOT_std_L_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_L_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// M
	{
		tmp0 := sym_M.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(766), kw_column, int(18), kw_end_DASH_line, int(766), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_map)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(766), kw_column, int(20), kw_end_DASH_line, int(766), kw_end_DASH_column, int(38))).(lang.FnFunc)
		var_ys_DOT_std_M = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_M.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// M+
	{
		tmp0 := sym_M_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(781), kw_column, int(18), kw_end_DASH_line, int(781), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(781), kw_column, int(21), kw_end_DASH_line, int(781), kw_end_DASH_column, int(55))).(lang.FnFunc)
		var_ys_DOT_std_M_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_M_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// N
	{
		tmp0 := sym_N.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(768), kw_column, int(18), kw_end_DASH_line, int(768), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(768), kw_column, int(20), kw_end_DASH_line, int(768), kw_end_DASH_column, int(52))).(lang.FnFunc)
		var_ys_DOT_std_N = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_N.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// O
	{
		tmp0 := sym_O.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(770), kw_column, int(18), kw_end_DASH_line, int(770), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_omap)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(770), kw_column, int(20), kw_end_DASH_line, int(770), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_O = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_O.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// O+
	{
		tmp0 := sym_O_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(783), kw_column, int(18), kw_end_DASH_line, int(783), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_std_omap)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(783), kw_column, int(21), kw_end_DASH_line, int(783), kw_end_DASH_column, int(51))).(lang.FnFunc)
		var_ys_DOT_std_O_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_O_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// S
	{
		tmp0 := sym_S.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(772), kw_column, int(18), kw_end_DASH_line, int(772), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_str)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(772), kw_column, int(20), kw_end_DASH_line, int(772), kw_end_DASH_column, int(38))).(lang.FnFunc)
		var_ys_DOT_std_S = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_S.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// T
	{
		tmp0 := sym_T.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(774), kw_column, int(18), kw_end_DASH_line, int(774), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(774), kw_column, int(20), kw_end_DASH_line, int(774), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_T = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_T.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// T?
	{
		tmp0 := sym_T_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(804), kw_column, int(11), kw_end_DASH_line, int(804), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp7 := checkDerefVar(var_clojure_DOT_core_list)
			tmp8 := lang.Apply(tmp7, []any{sym_ys_DOT_std_SLASH_truey_QMARK_})
			tmp9 := checkDerefVar(var_clojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{v4})
			tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10})
			tmp12 := lang.Apply(tmp5, []any{tmp11})
			return tmp12
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_T_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_T_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// V
	{
		tmp0 := sym_V.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(776), kw_column, int(18), kw_end_DASH_line, int(776), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_vec)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(776), kw_column, int(20), kw_end_DASH_line, int(776), kw_end_DASH_column, int(38))).(lang.FnFunc)
		var_ys_DOT_std_V = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_V.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// V+
	{
		tmp0 := sym_V_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(785), kw_column, int(18), kw_end_DASH_line, int(785), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(785), kw_column, int(21), kw_end_DASH_line, int(785), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_V_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_V_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// &&&
	{
		tmp0 := sym__AMP__AMP__AMP_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(822), kw_column, int(11), kw_end_DASH_line, int(822), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_ys_DOT_std_SLASH_and_QMARK_})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp9, tmp11, v5})
				tmp13 := lang.Apply(tmp6, []any{tmp12})
				return tmp13
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__AMP__AMP__AMP_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__AMP__AMP__AMP_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// !---
	{
		tmp0 := sym__BANG__DASH__DASH__DASH_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(538), kw_column, int(7), kw_end_DASH_line, int(538), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_S, sym_R)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_not)
			tmp5 := checkDerefVar(var_ys_DOT_std__EQ__DASH__DASH__DASH_)
			tmp6 := lang.Apply(tmp5, []any{v2, v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__BANG__DASH__DASH__DASH_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__BANG__DASH__DASH__DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// =---
	{
		tmp0 := sym__EQ__DASH__DASH__DASH_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(535), kw_column, int(7), kw_end_DASH_line, int(535), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_S, sym_R)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
			tmp5 := checkDerefVar(var_clojure_DOT_core_str)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{v3, tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__EQ__DASH__DASH__DASH_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__EQ__DASH__DASH__DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// %
	{
		tmp0 := sym__PCT_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(269), kw_column, int(7), kw_end_DASH_line, int(269), kw_end_DASH_column, int(7), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_std_omap)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__PCT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__PCT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +concat
	{
		tmp0 := sym__PLUS_concat.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(235), kw_column, int(7), kw_end_DASH_line, int(235), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_C)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp5 := checkDerefVar(var_clojure_DOT_core_map)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v7 := args[0]
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v7})
					if lang.IsTruthy(tmp10) {
						tmp8 = v7
					} else {
						var tmp11 any
						var tmp12 any
						{ // let
							// let binding "or__0__auto__"
							tmp13 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
							tmp14 := lang.Apply(tmp13, []any{v7})
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v15
							} else {
								var tmp17 any
								{ // let
									// let binding "or__0__auto__"
									tmp18 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
									tmp19 := lang.Apply(tmp18, []any{v7})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									if lang.IsTruthy(v20) {
										tmp21 = v20
									} else {
										var tmp22 any
										{ // let
											// let binding "or__0__auto__"
											tmp23 := checkDerefVar(var_clojure_DOT_core_boolean_QMARK_)
											tmp24 := lang.Apply(tmp23, []any{v7})
											var v25 any = tmp24
											_ = v25
											var tmp26 any
											if lang.IsTruthy(v25) {
												tmp26 = v25
											} else {
												var tmp27 any
												{ // let
													// let binding "or__0__auto__"
													tmp28 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
													tmp29 := lang.Apply(tmp28, []any{v7})
													var v30 any = tmp29
													_ = v30
													var tmp31 any
													if lang.IsTruthy(v30) {
														tmp31 = v30
													} else {
														tmp32 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
														tmp33 := lang.Apply(tmp32, []any{v7})
														tmp31 = tmp33
													}
													tmp27 = tmp31
												} // end let
												tmp26 = tmp27
											}
											tmp22 = tmp26
										} // end let
										tmp21 = tmp22
									}
									tmp17 = tmp21
								} // end let
								tmp16 = tmp17
							}
							tmp12 = tmp16
						} // end let
						if lang.IsTruthy(tmp12) {
							tmp13 := lang.NewVector(v7)
							tmp14 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(243), kw_column, int(38), kw_end_DASH_line, int(243), kw_end_DASH_column, int(41))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp11 = tmp15
						} else {
							var tmp16 any
							if lang.IsTruthy(kw_else) {
							} else {
							}
							tmp11 = tmp16
						}
						tmp8 = tmp11
					}
					return tmp8
				})
				tmp7 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(236), kw_column, int(22), kw_end_DASH_line, int(244), kw_end_DASH_column, int(34))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8, v2})
				tmp10 := lang.Apply(tmp3, []any{tmp4, tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__PLUS_concat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__PLUS_concat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +merge
	{
		tmp0 := sym__PLUS_merge.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(246), kw_column, int(7), kw_end_DASH_line, int(246), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_M)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := lang.Apply(kw__DASH__LT__LT_, []any{v2})
			if lang.IsTruthy(tmp4) {
				var tmp5 any
				{ // let
					// let binding "m"
					tmp6 := checkDerefVar(var_clojure_DOT_core_dissoc)
					tmp7 := lang.Apply(tmp6, []any{v2, kw__DASH__LT__LT_})
					var v8 any = tmp7
					_ = v8
					// let binding "q"
					tmp9 := checkDerefVar(var_clojure_DOT_core_get)
					tmp10 := lang.Apply(tmp9, []any{v2, kw__DASH__LT__LT_})
					var v11 any = tmp10
					_ = v11
					// let binding "v"
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
					tmp14 := lang.Apply(tmp13, []any{v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_vector)
						tmp16 := lang.Apply(tmp15, []any{v11})
						tmp12 = tmp16
					} else {
						var tmp17 any
						tmp18 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v11})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_clojure_DOT_core_vec)
							tmp21 := lang.Apply(tmp20, []any{v11})
							tmp17 = tmp21
						} else {
							tmp22 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp23 := lang.Apply(tmp22, []any{"Can't merge ", v11})
							tmp17 = tmp23
						}
						tmp12 = tmp17
					}
					var v24 any = tmp12
					_ = v24
					// let binding "M"
					tmp25 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp26 := checkDerefVar(var_clojure_DOT_core_merge_DASH_with)
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v28 := args[0]
						_ = v28
						v29 := args[1]
						_ = v29
						return v28
					})
					tmp28 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(255), kw_column, int(31), kw_end_DASH_line, int(255), kw_end_DASH_column, int(42))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := lang.Apply(tmp25, []any{tmp26, tmp29, v8, v24})
					var v31 any = tmp30
					_ = v31
					tmp32 := checkDerefVar(var_ys_DOT_std__PLUS_merge)
					tmp33 := lang.Apply(tmp32, []any{v31})
					tmp5 = tmp33
				} // end let
				tmp3 = tmp5
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__PLUS_merge = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__PLUS_merge.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// |||
	{
		tmp0 := sym__U007C__U007C__U007C_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(813), kw_column, int(11), kw_end_DASH_line, int(813), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_ys_DOT_std_SLASH_or_QMARK_})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp9, tmp11, v5})
				tmp13 := lang.Apply(tmp6, []any{tmp12})
				return tmp13
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std__U007C__U007C__U007C_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std__U007C__U007C__U007C_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// a
	{
		tmp0 := sym_a.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(577), kw_column, int(18), kw_end_DASH_line, int(577), kw_end_DASH_column, int(18), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_identity)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(577), kw_column, int(20), kw_end_DASH_line, int(577), kw_end_DASH_column, int(40))).(lang.FnFunc)
		var_ys_DOT_std_a = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_a.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add
	{
		tmp0 := sym_add.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(304), kw_column, int(7), kw_end_DASH_line, int(304), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__PLUS_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(306), kw_column, int(8), kw_end_DASH_line, int(306), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_add = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_add.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add+
	{
		tmp0 := sym_add_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(395), kw_column, int(7), kw_end_DASH_line, int(395), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "pred__111"
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v6, []any{v7})
						return tmp8
					})
					var v6 any = tmp5
					_ = v6
					// let binding "expr__112"
					var v7 any = v2
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
					tmp10 := lang.Apply(v6, []any{tmp9, v7})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_clojure_DOT_core__PLUS_)
						tmp12 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
						tmp13 := lang.Apply(tmp12, []any{v2, int64(0)})
						tmp14 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
						tmp15 := lang.Apply(tmp14, []any{v3, int64(0)})
						tmp16 := lang.Apply(tmp11, []any{tmp13, tmp15})
						tmp8 = tmp16
					} else {
						var tmp17 any
						tmp18 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp19 := lang.Apply(v6, []any{tmp18, v7})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_clojure_DOT_core_str)
							tmp21 := lang.Apply(tmp20, []any{v2, v3})
							tmp17 = tmp21
						} else {
							var tmp22 any
							tmp23 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
							tmp24 := lang.Apply(v6, []any{tmp23, v7})
							if lang.IsTruthy(tmp24) {
								tmp25 := checkDerefVar(var_clojure_DOT_core_merge)
								tmp26 := checkDerefVar(var_ys_DOT_std_to_DASH_map)
								tmp27 := lang.Apply(tmp26, []any{v2})
								tmp28 := checkDerefVar(var_ys_DOT_std_to_DASH_map)
								tmp29 := lang.Apply(tmp28, []any{v3})
								tmp30 := lang.Apply(tmp25, []any{tmp27, tmp29})
								tmp22 = tmp30
							} else {
								var tmp31 any
								tmp32 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
								tmp33 := lang.Apply(v6, []any{tmp32, v7})
								if lang.IsTruthy(tmp33) {
									tmp34 := checkDerefVar(var_clojure_DOT_core_into)
									tmp35 := checkDerefVar(var_ys_DOT_std_to_DASH_set)
									tmp36 := lang.Apply(tmp35, []any{v2})
									tmp37 := checkDerefVar(var_ys_DOT_std_to_DASH_set)
									tmp38 := lang.Apply(tmp37, []any{v3})
									tmp39 := lang.Apply(tmp34, []any{tmp36, tmp38})
									tmp31 = tmp39
								} else {
									var tmp40 any
									tmp41 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
									tmp42 := lang.Apply(v6, []any{tmp41, v7})
									if lang.IsTruthy(tmp42) {
										tmp43 := checkDerefVar(var_clojure_DOT_core_vec)
										tmp44 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp45 := checkDerefVar(var_ys_DOT_std_to_DASH_vec)
										tmp46 := lang.Apply(tmp45, []any{v2})
										var tmp47 any
										tmp48 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
										tmp49 := lang.Apply(tmp48, []any{v3})
										if lang.IsTruthy(tmp49) {
											tmp50 := checkDerefVar(var_ys_DOT_std_to_DASH_list)
											tmp51 := lang.Apply(tmp50, []any{v3})
											tmp47 = tmp51
										} else {
											tmp52 := checkDerefVar(var_clojure_DOT_core_list)
											tmp53 := lang.Apply(tmp52, []any{v3})
											tmp47 = tmp53
										}
										tmp54 := lang.Apply(tmp44, []any{tmp46, tmp47})
										tmp55 := lang.Apply(tmp43, []any{tmp54})
										tmp40 = tmp55
									} else {
										var tmp56 any
										tmp57 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
										tmp58 := lang.Apply(v6, []any{tmp57, v7})
										if lang.IsTruthy(tmp58) {
											var tmp59 any
											tmp60 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
											tmp61 := lang.Apply(tmp60, []any{v3})
											if lang.IsTruthy(tmp61) {
												tmp62 := checkDerefVar(var_clojure_DOT_core_char)
												tmp63 := checkDerefVar(var_clojure_DOT_core__PLUS_)
												tmp64 := checkDerefVar(var_clojure_DOT_core_int)
												tmp65 := lang.Apply(tmp64, []any{v2})
												tmp66 := lang.Apply(tmp63, []any{tmp65, v3})
												tmp67 := lang.Apply(tmp62, []any{tmp66})
												tmp59 = tmp67
											} else {
												tmp68 := checkDerefVar(var_clojure_DOT_core_str)
												tmp69 := lang.Apply(tmp68, []any{v2, v3})
												tmp59 = tmp69
											}
											tmp56 = tmp59
										} else {
											var tmp70 any
											tmp71 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
											tmp72 := lang.Apply(v6, []any{tmp71, v7})
											if lang.IsTruthy(tmp72) {
												tmp73 := checkDerefVar(var_clojure_DOT_core_partial)
												tmp74 := lang.Apply(tmp73, []any{v2, v3})
												tmp70 = tmp74
											} else {
												var tmp75 any
												tmp76 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
												tmp77 := lang.Apply(v6, []any{tmp76, v7})
												if lang.IsTruthy(tmp77) {
													tmp78 := checkDerefVar(var_yamlscript_DOT_util_die)
													tmp79 := lang.Apply(tmp78, []any{"Can't add+ to a nil value"})
													tmp75 = tmp79
												} else {
													var tmp80 any
													tmp81 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
													tmp82 := lang.Apply(v6, []any{tmp81, v7})
													if lang.IsTruthy(tmp82) {
														tmp83 := checkDerefVar(var_clojure_DOT_core_concat)
														tmp84 := checkDerefVar(var_ys_DOT_std_to_DASH_list)
														tmp85 := lang.Apply(tmp84, []any{v2})
														var tmp86 any
														tmp87 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
														tmp88 := lang.Apply(tmp87, []any{v3})
														if lang.IsTruthy(tmp88) {
															tmp89 := checkDerefVar(var_ys_DOT_std_to_DASH_list)
															tmp90 := lang.Apply(tmp89, []any{v3})
															tmp86 = tmp90
														} else {
															tmp91 := checkDerefVar(var_clojure_DOT_core_list)
															tmp92 := lang.Apply(tmp91, []any{v3})
															tmp86 = tmp92
														}
														tmp93 := lang.Apply(tmp83, []any{tmp85, tmp86})
														tmp80 = tmp93
													} else {
														tmp94 := checkDerefVar(var_clojure_DOT_core__PLUS_)
														tmp95 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
														tmp96 := lang.Apply(tmp95, []any{v2, int64(0)})
														tmp97 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
														tmp98 := lang.Apply(tmp97, []any{v3, int64(0)})
														tmp99 := lang.Apply(tmp94, []any{tmp96, tmp98})
														tmp80 = tmp99
													}
													tmp75 = tmp80
												}
												tmp70 = tmp75
											}
											tmp56 = tmp70
										}
										tmp40 = tmp56
									}
									tmp31 = tmp40
								}
								tmp22 = tmp31
							}
							tmp17 = tmp22
						}
						tmp8 = tmp17
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_reduce)
				tmp6 := checkDerefVar(var_ys_DOT_std_add_PLUS_)
				tmp7 := checkDerefVar(var_ys_DOT_std_add_PLUS_)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8, v4})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_add_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_add_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// and?
	{
		tmp0 := sym_and_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(815), kw_column, int(11), kw_end_DASH_line, int(815), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return true
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_ys_DOT_std_SLASH_truey_QMARK_})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10})
				tmp12 := lang.Apply(tmp5, []any{tmp11})
				return tmp12
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_and})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_ys_DOT_std_SLASH_truey_QMARK_})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp23 := checkDerefVar(var_clojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_ys_DOT_std_SLASH_and_QMARK_})
				tmp25 := lang.Apply(tmp22, []any{tmp24, v5})
				tmp26 := lang.Apply(tmp21, []any{tmp25})
				tmp27 := lang.Apply(tmp20, []any{tmp26})
				tmp28 := lang.Apply(tmp7, []any{tmp9, tmp19, tmp27})
				tmp29 := lang.Apply(tmp6, []any{tmp28})
				return tmp29
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_and_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_and_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// atom
	{
		tmp0 := sym_atom.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(1022), kw_column, int(7), kw_end_DASH_line, int(1022), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_core_atom)
				tmp3 := lang.Apply(tmp2, []any{nil})
				return tmp3
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_atom)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_atom = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_atom.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bash
	{
		tmp0 := sym_bash.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(962), kw_column, int(7), kw_end_DASH_line, int(962), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					// let binding "cmd"
					tmp4 := checkDerefVar(var_clojure_DOT_string_join)
					tmp5 := lang.Apply(tmp4, []any{" ", v2})
					var v6 any = tmp5
					_ = v6
					tmp7 := checkDerefVar(var_ys_DOT_std_sh)
					tmp8 := lang.Apply(tmp7, []any{"bash", "-c", v6})
					tmp3 = tmp8
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_bash = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_bash.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bash-out
	{
		tmp0 := sym_bash_DASH_out.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(966), kw_column, int(7), kw_end_DASH_line, int(966), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					// let binding "cmd"
					tmp4 := checkDerefVar(var_clojure_DOT_string_join)
					tmp5 := lang.Apply(tmp4, []any{" ", v2})
					var v6 any = tmp5
					_ = v6
					tmp7 := checkDerefVar(var_ys_DOT_std_sh_DASH_out)
					tmp8 := lang.Apply(tmp7, []any{"bash", "-c", v6})
					tmp3 = tmp8
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_bash_DASH_out = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_bash_DASH_out.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// blank?
	{
		tmp0 := sym_blank_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(67), kw_column, int(18), kw_end_DASH_line, int(67), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_blank_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(67), kw_column, int(25), kw_end_DASH_line, int(67), kw_end_DASH_column, int(47))).(lang.FnFunc)
		var_ys_DOT_std_blank_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_blank_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// call
	{
		tmp0 := sym_call.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(470), kw_column, int(11), kw_end_DASH_line, int(470), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_let})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_f__0__auto__})
				tmp17 := checkDerefVar(var_clojure_DOT_core_list)
				tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_clojure_DOT_core_SLASH_or})
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp24 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp25 := checkDerefVar(var_clojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{sym_ys_DOT_std_SLASH_value})
				tmp27 := checkDerefVar(var_clojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{v4})
				tmp29 := lang.Apply(tmp24, []any{tmp26, tmp28})
				tmp30 := lang.Apply(tmp23, []any{tmp29})
				tmp31 := lang.Apply(tmp22, []any{tmp30})
				tmp32 := checkDerefVar(var_clojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{v4})
				tmp34 := lang.Apply(tmp19, []any{tmp21, tmp31, tmp33})
				tmp35 := lang.Apply(tmp18, []any{tmp34})
				tmp36 := lang.Apply(tmp17, []any{tmp35})
				tmp37 := lang.Apply(tmp14, []any{tmp16, tmp36})
				tmp38 := lang.Apply(tmp13, []any{tmp37})
				tmp39 := lang.Apply(tmp11, []any{tmp12, tmp38})
				tmp40 := lang.Apply(tmp10, []any{tmp39})
				tmp41 := checkDerefVar(var_clojure_DOT_core_list)
				tmp42 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp43 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp44 := checkDerefVar(var_clojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{sym_clojure_DOT_core_SLASH_when_DASH_not})
				tmp46 := checkDerefVar(var_clojure_DOT_core_list)
				tmp47 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp48 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp49 := checkDerefVar(var_clojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{sym_clojure_DOT_core_SLASH_ifn_QMARK_})
				tmp51 := checkDerefVar(var_clojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym_f__0__auto__})
				tmp53 := lang.Apply(tmp48, []any{tmp50, tmp52})
				tmp54 := lang.Apply(tmp47, []any{tmp53})
				tmp55 := lang.Apply(tmp46, []any{tmp54})
				tmp56 := checkDerefVar(var_clojure_DOT_core_list)
				tmp57 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp58 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp59 := checkDerefVar(var_clojure_DOT_core_list)
				tmp60 := lang.Apply(tmp59, []any{sym_yamlscript_DOT_util_SLASH_die})
				tmp61 := checkDerefVar(var_clojure_DOT_core_list)
				tmp62 := lang.Apply(tmp61, []any{"Can't call("})
				tmp63 := checkDerefVar(var_clojure_DOT_core_list)
				tmp64 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp65 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp66 := checkDerefVar(var_clojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{sym_clojure_DOT_core_SLASH_pr_DASH_str})
				tmp68 := checkDerefVar(var_clojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{sym_f__0__auto__})
				tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
				tmp71 := lang.Apply(tmp64, []any{tmp70})
				tmp72 := lang.Apply(tmp63, []any{tmp71})
				tmp73 := checkDerefVar(var_clojure_DOT_core_list)
				tmp74 := lang.Apply(tmp73, []any{")"})
				tmp75 := lang.Apply(tmp58, []any{tmp60, tmp62, tmp72, tmp74})
				tmp76 := lang.Apply(tmp57, []any{tmp75})
				tmp77 := lang.Apply(tmp56, []any{tmp76})
				tmp78 := lang.Apply(tmp43, []any{tmp45, tmp55, tmp77})
				tmp79 := lang.Apply(tmp42, []any{tmp78})
				tmp80 := lang.Apply(tmp41, []any{tmp79})
				tmp81 := checkDerefVar(var_clojure_DOT_core_list)
				tmp82 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp83 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp84 := checkDerefVar(var_clojure_DOT_core_list)
				tmp85 := lang.Apply(tmp84, []any{sym_f__0__auto__})
				tmp86 := lang.Apply(tmp83, []any{tmp85, v5})
				tmp87 := lang.Apply(tmp82, []any{tmp86})
				tmp88 := lang.Apply(tmp81, []any{tmp87})
				tmp89 := lang.Apply(tmp7, []any{tmp9, tmp40, tmp80, tmp88})
				tmp90 := lang.Apply(tmp6, []any{tmp89})
				return tmp90
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_call = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_call.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chomp
	{
		tmp0 := sym_chomp.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(69), kw_column, int(18), kw_end_DASH_line, int(69), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_trim_DASH_newline)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(69), kw_column, int(24), kw_end_DASH_line, int(69), kw_end_DASH_column, int(52))).(lang.FnFunc)
		var_ys_DOT_std_chomp = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_chomp.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec+
	{
		tmp0 := sym_dec_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(386), kw_column, int(7), kw_end_DASH_line, int(386), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__107"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__108"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_dec)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp7 = tmp11
				} else {
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
					tmp14 := lang.Apply(v5, []any{tmp13, v6})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_char)
						tmp16 := checkDerefVar(var_clojure_DOT_core_dec)
						tmp17 := checkDerefVar(var_clojure_DOT_core_long)
						tmp18 := lang.Apply(tmp17, []any{v2})
						tmp19 := lang.Apply(tmp16, []any{tmp18})
						tmp20 := lang.Apply(tmp15, []any{tmp19})
						tmp12 = tmp20
					} else {
						var tmp21 any
						{ // let
							// let binding "n"
							tmp22 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
							tmp23 := lang.Apply(tmp22, []any{v2, int64(0)})
							var v24 any = tmp23
							_ = v24
							var tmp25 any
							{ // let
								// let binding "pred__109"
								var tmp26 lang.FnFunc
								tmp26 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v27 := args[0]
									_ = v27
									v28 := args[1]
									_ = v28
									tmp29 := lang.Apply(v27, []any{v28})
									return tmp29
								})
								var v27 any = tmp26
								_ = v27
								// let binding "expr__110"
								var v28 any = v24
								_ = v28
								var tmp29 any
								tmp30 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
								tmp31 := lang.Apply(v27, []any{tmp30, v28})
								if lang.IsTruthy(tmp31) {
									tmp32 := checkDerefVar(var_clojure_DOT_core_dec)
									tmp33 := lang.Apply(tmp32, []any{v24})
									tmp29 = tmp33
								} else {
									tmp34 := checkDerefVar(var_ys_DOT_std_op_DASH_error)
									tmp35 := lang.Apply(tmp34, []any{"dec+", v2})
									tmp29 = tmp35
								}
								tmp25 = tmp29
							} // end let
							tmp21 = tmp25
						} // end let
						tmp12 = tmp21
					}
					tmp7 = tmp12
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_dec_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_dec_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// die
	{
		tmp0 := sym_die.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(476), kw_column, int(18), kw_end_DASH_line, int(476), kw_end_DASH_column, int(20), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_yamlscript_DOT_util_die)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(476), kw_column, int(22), kw_end_DASH_line, int(476), kw_end_DASH_column, int(56))).(lang.FnFunc)
		var_ys_DOT_std_die = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_die.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// digits
	{
		tmp0 := sym_digits.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(331), kw_column, int(7), kw_end_DASH_line, int(331), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "n"
				tmp4 := checkDerefVar(var_clojure_DOT_core_str)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
				tmp9 := lang.Apply(tmp8, []any{regexp4.MustCompile("[0-9]+"), v6})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "iter__0__auto__"
						var tmp11 lang.FnFunc
						{ // function iter__99
							var v12 lang.FnFunc
							tmp11 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v13 := args[0]
								_ = v13
								var tmp14 lang.FnFunc
								tmp14 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 0)
									var tmp15 any
									{ // let
										// let binding "s__100"
										var v16 any = v13
										_ = v16
										for {
											var tmp17 any
											{ // let
												// let binding "temp__0__auto__"
												tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
												tmp19 := lang.Apply(tmp18, []any{v16})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													var tmp22 any
													{ // let
														// let binding "s__100"
														var v23 any = v20
														_ = v23
														var tmp24 any
														tmp25 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp26 := lang.Apply(tmp25, []any{v23})
														if lang.IsTruthy(tmp26) {
															var tmp27 any
															{ // let
																// let binding "c__0__auto__"
																tmp28 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
																tmp29 := lang.Apply(tmp28, []any{v23})
																var v30 any = tmp29
																_ = v30
																// let binding "size__1__auto__"
																tmp31 := checkDerefVar(var_clojure_DOT_core_int)
																tmp32 := checkDerefVar(var_clojure_DOT_core_count)
																tmp33 := lang.Apply(tmp32, []any{v30})
																tmp34 := lang.Apply(tmp31, []any{tmp33})
																var v35 any = tmp34
																_ = v35
																// let binding "b__102"
																tmp36 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_buffer)
																tmp37 := lang.Apply(tmp36, []any{v35})
																var v38 any = tmp37
																_ = v38
																var tmp39 any
																var tmp40 any
																{ // let
																	// let binding "i__101"
																	tmp41 := checkDerefVar(var_clojure_DOT_core_int)
																	tmp42 := lang.Apply(tmp41, []any{int64(0)})
																	var v43 any = tmp42
																	_ = v43
																	for {
																		var tmp44 any
																		tmp45 := checkDerefVar(var_clojure_DOT_core__LT_)
																		tmp46 := lang.Apply(tmp45, []any{v43, v35})
																		if lang.IsTruthy(tmp46) {
																			var tmp47 any
																			{ // let
																				// let binding "d"
																				tmp48, _ := lang.FieldOrMethod(v30, "nth")
																				if reflect.TypeOf(tmp48).Kind() != reflect.Func {
																					panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																				}
																				tmp49 := lang.Apply(tmp48, []any{v43})
																				var v50 any = tmp49
																				_ = v50
																				tmp51 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_append)
																				tmp52 := checkDerefVar(var_clojure_DOT_core__DASH_)
																				tmp53 := checkDerefVar(var_clojure_DOT_core_byte)
																				tmp54 := lang.Apply(tmp53, []any{v50})
																				tmp55 := lang.Apply(tmp52, []any{tmp54, int64(48)})
																				tmp56 := lang.Apply(tmp51, []any{v38, tmp55})
																				_ = tmp56
																				tmp58 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
																				tmp59 := lang.Apply(tmp58, []any{v43})
																				var tmp57 any = tmp59
																				v43 = tmp57
																				continue
																			} // end let
																			tmp44 = tmp47
																		} else {
																			tmp44 = true
																		}
																		tmp40 = tmp44
																		break
																	}
																} // end let
																if lang.IsTruthy(tmp40) {
																	tmp41 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_cons)
																	tmp42 := checkDerefVar(var_clojure_DOT_core_chunk)
																	tmp43 := lang.Apply(tmp42, []any{v38})
																	tmp44 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
																	tmp45 := lang.Apply(tmp44, []any{v23})
																	tmp46 := lang.Apply(v12, []any{tmp45})
																	tmp47 := lang.Apply(tmp41, []any{tmp43, tmp46})
																	tmp39 = tmp47
																} else {
																	tmp48 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_cons)
																	tmp49 := checkDerefVar(var_clojure_DOT_core_chunk)
																	tmp50 := lang.Apply(tmp49, []any{v38})
																	tmp51 := lang.Apply(tmp48, []any{tmp50, nil})
																	tmp39 = tmp51
																}
																tmp27 = tmp39
															} // end let
															tmp24 = tmp27
														} else {
															var tmp28 any
															{ // let
																// let binding "d"
																tmp29 := checkDerefVar(var_clojure_DOT_core_first)
																tmp30 := lang.Apply(tmp29, []any{v23})
																var v31 any = tmp30
																_ = v31
																tmp32 := checkDerefVar(var_clojure_DOT_core_cons)
																tmp33 := checkDerefVar(var_clojure_DOT_core__DASH_)
																tmp34 := checkDerefVar(var_clojure_DOT_core_byte)
																tmp35 := lang.Apply(tmp34, []any{v31})
																tmp36 := lang.Apply(tmp33, []any{tmp35, int64(48)})
																tmp37 := checkDerefVar(var_clojure_DOT_core_rest)
																tmp38 := lang.Apply(tmp37, []any{v23})
																tmp39 := lang.Apply(v12, []any{tmp38})
																tmp40 := lang.Apply(tmp32, []any{tmp36, tmp39})
																tmp28 = tmp40
															} // end let
															tmp24 = tmp28
														}
														tmp22 = tmp24
													} // end let
													tmp21 = tmp22
												} else {
												}
												tmp17 = tmp21
											} // end let
											tmp15 = tmp17
											break
										}
									} // end let
									return tmp15
								})
								tmp15 := lang.Apply(lang.NewLazySeq, []any{tmp14})
								return tmp15
							})
							v12 = tmp11
							_ = v12
						}
						var v12 any = tmp11
						_ = v12
						tmp13 := lang.Apply(v12, []any{v6})
						tmp10 = tmp13
					} // end let
					tmp7 = tmp10
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_digits = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_digits.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// div
	{
		tmp0 := sym_div.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(321), kw_column, int(7), kw_end_DASH_line, int(321), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_ys_DOT_std_div)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(322), kw_column, int(8), kw_end_DASH_line, int(322), kw_end_DASH_column, int(18))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "a"
					tmp5 := checkDerefVar(var_clojure_DOT_core__SLASH_)
					tmp6 := lang.Apply(tmp5, []any{v2, v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_ratio_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v7})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_clojure_DOT_core_double)
						tmp12 := lang.Apply(tmp11, []any{v7})
						tmp8 = tmp12
					} else {
						tmp8 = v7
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_reduce)
				tmp6 := checkDerefVar(var_ys_DOT_std_div)
				tmp7 := checkDerefVar(var_ys_DOT_std_div)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8, v4})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_div = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_div.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// div+
	{
		tmp0 := sym_div_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(420), kw_column, int(7), kw_end_DASH_line, int(420), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_std_div)
				tmp5 := checkDerefVar(var_clojure_DOT_core_map)
				tmp6 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
				tmp8 := lang.Apply(tmp3, []any{tmp4, tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_div_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_div_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// each
	{
		tmp0 := sym_each.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(478), kw_column, int(11), kw_end_DASH_line, int(478), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_doall})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_clojure_DOT_core_SLASH_for})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := checkDerefVar(var_clojure_DOT_core_list)
				tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_do})
				tmp22 := lang.Apply(tmp19, []any{tmp21, v5})
				tmp23 := lang.Apply(tmp18, []any{tmp22})
				tmp24 := lang.Apply(tmp17, []any{tmp23})
				tmp25 := lang.Apply(tmp12, []any{tmp14, tmp16, tmp24})
				tmp26 := lang.Apply(tmp11, []any{tmp25})
				tmp27 := lang.Apply(tmp10, []any{tmp26})
				tmp28 := lang.Apply(tmp7, []any{tmp9, tmp27})
				tmp29 := lang.Apply(tmp6, []any{tmp28})
				return tmp29
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_each = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_each.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ends?
	{
		tmp0 := sym_ends_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(72), kw_column, int(18), kw_end_DASH_line, int(72), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_string_ends_DASH_with_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(72), kw_column, int(24), kw_end_DASH_line, int(72), kw_end_DASH_column, int(54))).(lang.FnFunc)
		var_ys_DOT_std_ends_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_ends_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eq
	{
		tmp0 := sym_eq.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(608), kw_column, int(7), kw_end_DASH_line, int(608), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(609), kw_column, int(8), kw_end_DASH_line, int(609), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_eq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_eq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// escape
	{
		tmp0 := sym_escape.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(74), kw_column, int(18), kw_end_DASH_line, int(74), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_string_escape)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(74), kw_column, int(25), kw_end_DASH_line, int(74), kw_end_DASH_column, int(51))).(lang.FnFunc)
		var_ys_DOT_std_escape = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_escape.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// falsey?
	{
		tmp0 := sym_falsey_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(792), kw_column, int(7), kw_end_DASH_line, int(792), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__135"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__136"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp7 = tmp11
				} else {
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
					tmp14 := lang.Apply(v5, []any{tmp13, v6})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v2})
						tmp12 = tmp16
					} else {
						var tmp17 any
						tmp18 := checkDerefVar(var_clojure_DOT_core_identity)
						tmp19 := lang.Apply(v5, []any{tmp18, v6})
						if lang.IsTruthy(tmp19) {
							tmp17 = false
						} else {
							tmp17 = true
						}
						tmp12 = tmp17
					}
					tmp7 = tmp12
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_falsey_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_falsey_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// truey?
	{
		tmp0 := sym_truey_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(801), kw_column, int(7), kw_end_DASH_line, int(801), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_ys_DOT_std_falsey_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_truey_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_truey_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flat
	{
		tmp0 := sym_flat.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(208), kw_column, int(7), kw_end_DASH_line, int(208), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_C)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_mapcat)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v5})
				if lang.IsTruthy(tmp8) {
					tmp6 = v5
				} else {
					tmp9 := lang.NewVector(v5)
					tmp10 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(210), kw_column, int(32), kw_end_DASH_line, int(210), kw_end_DASH_column, int(34))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp11
				}
				return tmp6
			})
			tmp5 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(210), kw_column, int(5), kw_end_DASH_line, int(210), kw_end_DASH_column, int(36))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_flat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_flat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flip
	{
		tmp0 := sym_flip.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(510), kw_column, int(7), kw_end_DASH_line, int(510), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp4 := lang.Apply(v2, nil)
					return tmp4
				case 1:
					v4 := args[0]
					_ = v4
					tmp5 := lang.Apply(v2, []any{v4})
					return tmp5
				case 2:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					tmp6 := lang.Apply(v2, []any{v5, v4})
					return tmp6
				case 3:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					tmp7 := lang.Apply(v2, []any{v6, v5, v4})
					return tmp7
				case 4:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					v7 := args[3]
					_ = v7
					tmp8 := lang.Apply(v2, []any{v7, v6, v5, v4})
					return tmp8
				default:
					checkArityGTE(args, 4)
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					v7 := args[3]
					_ = v7
					restArgs := args[4:]
					var v8 any
					if len(restArgs) > 0 {
						v8 = lang.NewList(restArgs...)
					}
					_ = v8
					tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp10 := checkDerefVar(var_clojure_DOT_core_reduce)
					tmp11 := checkDerefVar(var_clojure_DOT_core_conj)
					tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp13 := lang.NewVector(v4, v5, v6, v7)
					tmp14 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(518), kw_column, int(19), kw_end_DASH_line, int(518), kw_end_DASH_column, int(27))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp12, []any{tmp15, v8})
					tmp17 := lang.Apply(tmp10, []any{tmp11, lang.NewList(), tmp16})
					tmp18 := lang.Apply(tmp9, []any{v2, tmp17})
					return tmp18
				}
			})
			tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(511), kw_column, int(3), kw_end_DASH_line, int(520), kw_end_DASH_column, int(19))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_flip = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_flip.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-abs
	{
		tmp0 := sym_fs_DASH_abs.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(847), kw_column, int(18), kw_end_DASH_line, int(847), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_abs)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(847), kw_column, int(25), kw_end_DASH_line, int(847), kw_end_DASH_column, int(57))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_abs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_abs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-abs?
	{
		tmp0 := sym_fs_DASH_abs_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(849), kw_column, int(18), kw_end_DASH_line, int(849), kw_end_DASH_column, int(24), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_abs_QMARK_)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(849), kw_column, int(26), kw_end_DASH_line, int(849), kw_end_DASH_column, int(59))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_abs_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_abs_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-basename
	{
		tmp0 := sym_fs_DASH_basename.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(855), kw_column, int(18), kw_end_DASH_line, int(855), kw_end_DASH_column, int(28), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_basename)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(855), kw_column, int(30), kw_end_DASH_line, int(855), kw_end_DASH_column, int(67))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_basename = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_basename.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-d
	{
		tmp0 := sym_fs_DASH_d.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(829), kw_column, int(18), kw_end_DASH_line, int(829), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_d)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(829), kw_column, int(23), kw_end_DASH_line, int(829), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_d = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_d.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-dirname
	{
		tmp0 := sym_fs_DASH_dirname.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(851), kw_column, int(18), kw_end_DASH_line, int(851), kw_end_DASH_column, int(27), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_dirname)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(851), kw_column, int(29), kw_end_DASH_line, int(851), kw_end_DASH_column, int(65))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_dirname = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_dirname.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-e
	{
		tmp0 := sym_fs_DASH_e.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(831), kw_column, int(18), kw_end_DASH_line, int(831), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_e)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(831), kw_column, int(23), kw_end_DASH_line, int(831), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_e = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_e.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-f
	{
		tmp0 := sym_fs_DASH_f.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(833), kw_column, int(18), kw_end_DASH_line, int(833), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_f)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(833), kw_column, int(23), kw_end_DASH_line, int(833), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_f = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_f.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-filename
	{
		tmp0 := sym_fs_DASH_filename.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(853), kw_column, int(18), kw_end_DASH_line, int(853), kw_end_DASH_column, int(28), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_filename)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(853), kw_column, int(30), kw_end_DASH_line, int(853), kw_end_DASH_column, int(67))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_filename = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_filename.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-glob
	{
		tmp0 := sym_fs_DASH_glob.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(857), kw_column, int(18), kw_end_DASH_line, int(857), kw_end_DASH_column, int(24), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_glob)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(857), kw_column, int(26), kw_end_DASH_line, int(857), kw_end_DASH_column, int(59))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_glob = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_glob.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-l
	{
		tmp0 := sym_fs_DASH_l.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(835), kw_column, int(18), kw_end_DASH_line, int(835), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_l)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(835), kw_column, int(23), kw_end_DASH_line, int(835), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_l = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_l.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-ls
	{
		tmp0 := sym_fs_DASH_ls.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(859), kw_column, int(18), kw_end_DASH_line, int(859), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_ls)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(859), kw_column, int(24), kw_end_DASH_line, int(859), kw_end_DASH_column, int(55))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_ls = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_ls.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-mtime
	{
		tmp0 := sym_fs_DASH_mtime.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(861), kw_column, int(18), kw_end_DASH_line, int(861), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_mtime)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(861), kw_column, int(27), kw_end_DASH_line, int(861), kw_end_DASH_column, int(61))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_mtime = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_mtime.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-r
	{
		tmp0 := sym_fs_DASH_r.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(837), kw_column, int(18), kw_end_DASH_line, int(837), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_r)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(837), kw_column, int(23), kw_end_DASH_line, int(837), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_r = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_r.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-rel
	{
		tmp0 := sym_fs_DASH_rel.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(863), kw_column, int(18), kw_end_DASH_line, int(863), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_rel)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(863), kw_column, int(25), kw_end_DASH_line, int(863), kw_end_DASH_column, int(57))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_rel = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_rel.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-rel?
	{
		tmp0 := sym_fs_DASH_rel_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(865), kw_column, int(18), kw_end_DASH_line, int(865), kw_end_DASH_column, int(24), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_rel_QMARK_)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(865), kw_column, int(26), kw_end_DASH_line, int(865), kw_end_DASH_column, int(59))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_rel_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_rel_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-s
	{
		tmp0 := sym_fs_DASH_s.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(839), kw_column, int(18), kw_end_DASH_line, int(839), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_s)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(839), kw_column, int(23), kw_end_DASH_line, int(839), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_s = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_s.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-w
	{
		tmp0 := sym_fs_DASH_w.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(841), kw_column, int(18), kw_end_DASH_line, int(841), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_w)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(841), kw_column, int(23), kw_end_DASH_line, int(841), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_w = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_w.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-which
	{
		tmp0 := sym_fs_DASH_which.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(867), kw_column, int(18), kw_end_DASH_line, int(867), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_which)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(867), kw_column, int(27), kw_end_DASH_line, int(867), kw_end_DASH_column, int(61))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_which = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_which.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-x
	{
		tmp0 := sym_fs_DASH_x.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(843), kw_column, int(18), kw_end_DASH_line, int(843), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_x)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(843), kw_column, int(23), kw_end_DASH_line, int(843), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_x = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_x.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fs-z
	{
		tmp0 := sym_fs_DASH_z.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(845), kw_column, int(18), kw_end_DASH_line, int(845), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_fs_z)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(845), kw_column, int(23), kw_end_DASH_line, int(845), kw_end_DASH_column, int(53))).(lang.FnFunc)
		var_ys_DOT_std_fs_DASH_z = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_fs_DASH_z.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ge
	{
		tmp0 := sym_ge.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(623), kw_column, int(7), kw_end_DASH_line, int(623), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__GT__EQ_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(624), kw_column, int(8), kw_end_DASH_line, int(624), kw_end_DASH_column, int(17))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__GT__EQ_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__GT__EQ_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_ge = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_ge.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get+
	{
		tmp0 := sym_get_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(183), kw_column, int(7), kw_end_DASH_line, int(183), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_C, sym_K)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "pred__81"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v6 := args[0]
					_ = v6
					v7 := args[1]
					_ = v7
					tmp8 := lang.Apply(v6, []any{v7})
					return tmp8
				})
				var v6 any = tmp5
				_ = v6
				// let binding "expr__82"
				var v7 any = v2
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp10 := lang.Apply(v6, []any{tmp9, v7})
				if lang.IsTruthy(tmp10) {
					var tmp11 any
					tmp12 := checkDerefVar(var_clojure_DOT_core_symbol_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v3})
					if lang.IsTruthy(tmp13) {
						var tmp14 any
						{ // let
							// let binding "or__0__auto__"
							tmp15 := checkDerefVar(var_clojure_DOT_core_get)
							tmp16 := lang.Apply(tmp15, []any{v2, v3})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp18 = v17
							} else {
								var tmp19 any
								{ // let
									// let binding "or__0__auto__"
									tmp20 := checkDerefVar(var_clojure_DOT_core_get)
									tmp21 := checkDerefVar(var_clojure_DOT_core_str)
									tmp22 := lang.Apply(tmp21, []any{v3})
									tmp23 := lang.Apply(tmp20, []any{v2, tmp22})
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										tmp25 = v24
									} else {
										tmp26 := checkDerefVar(var_clojure_DOT_core_get)
										tmp27 := checkDerefVar(var_clojure_DOT_core_keyword)
										tmp28 := lang.Apply(tmp27, []any{v3})
										tmp29 := lang.Apply(tmp26, []any{v2, tmp28})
										tmp25 = tmp29
									}
									tmp19 = tmp25
								} // end let
								tmp18 = tmp19
							}
							tmp14 = tmp18
						} // end let
						tmp11 = tmp14
					} else {
						var tmp15 any
						{ // let
							// let binding "or__0__auto__"
							tmp16 := checkDerefVar(var_clojure_DOT_core_get)
							tmp17 := lang.Apply(tmp16, []any{v2, v3})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								tmp19 = v18
							} else {
								tmp20 := checkDerefVar(var_clojure_DOT_core_get)
								tmp21 := checkDerefVar(var_clojure_DOT_core_str)
								tmp22 := lang.Apply(tmp21, []any{v3})
								tmp23 := lang.Apply(tmp20, []any{v2, tmp22})
								tmp19 = tmp23
							}
							tmp15 = tmp19
						} // end let
						tmp11 = tmp15
					}
					tmp8 = tmp11
				} else {
					var tmp16 any
					tmp17 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
					tmp18 := lang.Apply(v6, []any{tmp17, v7})
					if lang.IsTruthy(tmp18) {
						var tmp19 any
						tmp20 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
						tmp21 := lang.Apply(tmp20, []any{v2, v3})
						if lang.IsTruthy(tmp21) {
							tmp19 = v3
						} else {
							var tmp22 any
							tmp23 := checkDerefVar(var_clojure_DOT_core_symbol_QMARK_)
							tmp24 := lang.Apply(tmp23, []any{v3})
							if lang.IsTruthy(tmp24) {
								var tmp25 any
								{ // let
									// let binding "s"
									tmp26 := checkDerefVar(var_clojure_DOT_core_str)
									tmp27 := lang.Apply(tmp26, []any{v3})
									var v28 any = tmp27
									_ = v28
									var tmp29 any
									tmp30 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
									tmp31 := lang.Apply(tmp30, []any{v2, v28})
									if lang.IsTruthy(tmp31) {
										tmp29 = v28
									} else {
									}
									tmp25 = tmp29
								} // end let
								tmp22 = tmp25
							} else {
							}
							tmp19 = tmp22
						}
						tmp16 = tmp19
					} else {
						var tmp26 any
						tmp27 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
						tmp28 := lang.Apply(v6, []any{tmp27, v7})
						if lang.IsTruthy(tmp28) {
						} else {
							var tmp29 any
							tmp30 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
							tmp31 := lang.Apply(v6, []any{tmp30, v7})
							if lang.IsTruthy(tmp31) {
								var tmp32 any
								{ // let
									// let binding "pred__83"
									var tmp33 lang.FnFunc
									tmp33 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 2)
										v34 := args[0]
										_ = v34
										v35 := args[1]
										_ = v35
										tmp36 := lang.Apply(v34, []any{v35})
										return tmp36
									})
									var v34 any = tmp33
									_ = v34
									// let binding "expr__84"
									var v35 any = v3
									_ = v35
									var tmp36 any
									tmp37 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
									tmp38 := lang.Apply(v34, []any{tmp37, v35})
									if lang.IsTruthy(tmp38) {
										tmp39 := checkDerefVar(var_clojure_DOT_core_nth)
										tmp40 := lang.Apply(tmp39, []any{v2, v3, nil})
										tmp36 = tmp40
									} else {
										var tmp41 any
										tmp42 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
										tmp43 := lang.Apply(v34, []any{tmp42, v35})
										if lang.IsTruthy(tmp43) {
										} else {
										}
										tmp36 = tmp41
									}
									tmp32 = tmp36
								} // end let
								tmp29 = tmp32
							} else {
							}
							tmp26 = tmp29
						}
						tmp16 = tmp26
					}
					tmp8 = tmp16
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_get_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_get_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// grep
	{
		tmp0 := sym_grep.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(213), kw_column, int(7), kw_end_DASH_line, int(213), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_P, sym_C)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "vec__85"
				var tmp5 any
				tmp6 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.NewVector(v2, v3)
					tmp9 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(214), kw_column, int(32), kw_end_DASH_line, int(214), kw_end_DASH_column, int(36))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp5 = tmp10
				} else {
					tmp11 := lang.NewVector(v3, v2)
					tmp12 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(214), kw_column, int(38), kw_end_DASH_line, int(214), kw_end_DASH_column, int(42))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp5 = tmp13
				}
				var v14 any = tmp5
				_ = v14
				// let binding "P"
				tmp15 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
				var v17 any = tmp16
				_ = v17
				// let binding "C"
				tmp18 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
				var v20 any = tmp19
				_ = v20
				// let binding "_"
				var tmp21 any
				tmp22 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
				tmp23 := lang.Apply(tmp22, []any{v20})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_yamlscript_DOT_util_die)
					tmp25 := lang.Apply(tmp24, []any{"No seqable arg passed to grep"})
					tmp21 = tmp25
				}
				var v26 any = tmp21
				_ = v26
				var tmp27 any
				{ // let
					// let binding "pred__88"
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v29 := args[0]
						_ = v29
						v30 := args[1]
						_ = v30
						tmp31 := lang.Apply(v29, []any{v30})
						return tmp31
					})
					var v29 any = tmp28
					_ = v29
					// let binding "expr__89"
					var v30 any = v17
					_ = v30
					var tmp31 any
					tmp32 := checkDerefVar(var_ys_DOT_std_regex_QMARK_)
					tmp33 := lang.Apply(v29, []any{tmp32, v30})
					if lang.IsTruthy(tmp33) {
						tmp34 := checkDerefVar(var_clojure_DOT_core_filter)
						var tmp35 lang.FnFunc
						tmp35 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v36 := args[0]
							_ = v36
							tmp37 := checkDerefVar(var_clojure_DOT_core_re_DASH_find)
							tmp38 := lang.Apply(tmp37, []any{v17, v36})
							return tmp38
						})
						tmp36 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(218), kw_column, int(22), kw_end_DASH_line, int(218), kw_end_DASH_column, int(36))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp38 := lang.Apply(tmp34, []any{tmp37, v20})
						tmp31 = tmp38
					} else {
						var tmp39 any
						tmp40 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
						tmp41 := lang.Apply(v29, []any{tmp40, v30})
						if lang.IsTruthy(tmp41) {
							tmp42 := checkDerefVar(var_clojure_DOT_core_filter)
							tmp43 := lang.Apply(tmp42, []any{v17, v20})
							tmp39 = tmp43
						} else {
							tmp44 := checkDerefVar(var_clojure_DOT_core_filter)
							var tmp45 lang.FnFunc
							tmp45 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v46 := args[0]
								_ = v46
								tmp47 := checkDerefVar(var_clojure_DOT_core__EQ_)
								tmp48 := lang.Apply(tmp47, []any{v17, v46})
								return tmp48
							})
							tmp46 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(220), kw_column, int(15), kw_end_DASH_line, int(220), kw_end_DASH_column, int(23))
							tmp47, err := lang.WithMeta(tmp45, tmp46.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp48 := lang.Apply(tmp44, []any{tmp47, v20})
							tmp39 = tmp48
						}
						tmp31 = tmp39
					}
					tmp27 = tmp31
				} // end let
				tmp4 = tmp27
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_grep = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_grep.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gt
	{
		tmp0 := sym_gt.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(618), kw_column, int(7), kw_end_DASH_line, int(618), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__GT_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(619), kw_column, int(8), kw_end_DASH_line, int(619), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__GT_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__GT_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_gt = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_gt.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// has?
	{
		tmp0 := sym_has_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(222), kw_column, int(7), kw_end_DASH_line, int(222), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_C), lang.NewVector(sym_C, sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_ys_DOT_std_has_QMARK_)
					tmp6 := lang.Apply(tmp5, []any{v2, v4})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(223), kw_column, int(8), kw_end_DASH_line, int(223), kw_end_DASH_column, int(19))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_boolean)
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v3})
						tmp10 = tmp12
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_clojure_DOT_string_includes_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v2, v3})
					tmp5 = tmp8
				} else {
					var tmp9 any
					tmp10 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v2})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_ys_DOT_std_get_PLUS_)
						tmp13 := checkDerefVar(var_clojure_DOT_core_symbol)
						tmp14 := lang.Apply(tmp13, []any{v3})
						tmp15 := lang.Apply(tmp12, []any{v2, tmp14})
						tmp9 = tmp15
					} else {
						var tmp16 any
						if lang.IsTruthy(kw_else) {
							tmp17 := checkDerefVar(var_clojure_DOT_core_some)
							var tmp18 lang.FnFunc
							tmp18 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v19 := args[0]
								_ = v19
								tmp20 := checkDerefVar(var_clojure_DOT_core__EQ_)
								tmp21 := lang.Apply(tmp20, []any{v19, v3})
								return tmp21
							})
							tmp19 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(229), kw_column, int(20), kw_end_DASH_line, int(229), kw_end_DASH_column, int(28))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.Apply(tmp17, []any{tmp20, v2})
							tmp16 = tmp21
						} else {
						}
						tmp9 = tmp16
					}
					tmp5 = tmp9
				}
				tmp22 := lang.Apply(tmp4, []any{tmp5})
				return tmp22
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_has_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_has_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// in?
	{
		tmp0 := sym_in_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(231), kw_column, int(7), kw_end_DASH_line, int(231), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_C), lang.NewVector(sym_x, sym_C)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_ys_DOT_std_in_QMARK_)
					tmp6 := lang.Apply(tmp5, []any{v2, v4})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(232), kw_column, int(8), kw_end_DASH_line, int(232), kw_end_DASH_column, int(18))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_ys_DOT_std_has_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v3, v2})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_in_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_in_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc+
	{
		tmp0 := sym_inc_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(377), kw_column, int(7), kw_end_DASH_line, int(377), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__103"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__104"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_inc)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp7 = tmp11
				} else {
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
					tmp14 := lang.Apply(v5, []any{tmp13, v6})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_char)
						tmp16 := checkDerefVar(var_clojure_DOT_core_inc)
						tmp17 := checkDerefVar(var_clojure_DOT_core_long)
						tmp18 := lang.Apply(tmp17, []any{v2})
						tmp19 := lang.Apply(tmp16, []any{tmp18})
						tmp20 := lang.Apply(tmp15, []any{tmp19})
						tmp12 = tmp20
					} else {
						var tmp21 any
						{ // let
							// let binding "n"
							tmp22 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
							tmp23 := lang.Apply(tmp22, []any{v2, int64(0)})
							var v24 any = tmp23
							_ = v24
							var tmp25 any
							{ // let
								// let binding "pred__105"
								var tmp26 lang.FnFunc
								tmp26 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v27 := args[0]
									_ = v27
									v28 := args[1]
									_ = v28
									tmp29 := lang.Apply(v27, []any{v28})
									return tmp29
								})
								var v27 any = tmp26
								_ = v27
								// let binding "expr__106"
								var v28 any = v24
								_ = v28
								var tmp29 any
								tmp30 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
								tmp31 := lang.Apply(v27, []any{tmp30, v28})
								if lang.IsTruthy(tmp31) {
									tmp32 := checkDerefVar(var_clojure_DOT_core_inc)
									tmp33 := lang.Apply(tmp32, []any{v24})
									tmp29 = tmp33
								} else {
									tmp34 := checkDerefVar(var_ys_DOT_std_op_DASH_error)
									tmp35 := lang.Apply(tmp34, []any{"inc+", v2})
									tmp29 = tmp35
								}
								tmp25 = tmp29
							} // end let
							tmp21 = tmp25
						} // end let
						tmp12 = tmp21
					}
					tmp7 = tmp12
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_inc_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_inc_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// index
	{
		tmp0 := sym_index.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(76), kw_column, int(18), kw_end_DASH_line, int(76), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_string_index_DASH_of)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(76), kw_column, int(24), kw_end_DASH_line, int(76), kw_end_DASH_column, int(62))).(lang.FnFunc)
		var_ys_DOT_std_index = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_index.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// join
	{
		tmp0 := sym_join.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(85), kw_column, int(7), kw_end_DASH_line, int(85), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_Ss), lang.NewVector(sym_S, sym_Ss), lang.NewVector(sym_S, sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_ys_DOT_std_join)
				tmp4 := lang.Apply(tmp3, []any{"", v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_clojure_DOT_string_join)
					tmp8 := lang.Apply(tmp7, []any{v2, v3})
					tmp4 = tmp8
				} else {
					tmp9 := checkDerefVar(var_clojure_DOT_string_join)
					tmp10 := lang.Apply(tmp9, []any{v3, v2})
					tmp4 = tmp10
				}
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_string_join)
				tmp6 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				tmp8 := lang.Apply(tmp5, []any{v2, tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_join = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_join.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// joins
	{
		tmp0 := sym_joins.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(94), kw_column, int(7), kw_end_DASH_line, int(94), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_Ss)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_ys_DOT_std_join)
			tmp4 := lang.Apply(tmp3, []any{" ", v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_joins = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_joins.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lc
	{
		tmp0 := sym_lc.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(97), kw_column, int(18), kw_end_DASH_line, int(97), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_lower_DASH_case)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(97), kw_column, int(21), kw_end_DASH_line, int(97), kw_end_DASH_column, int(47))).(lang.FnFunc)
		var_ys_DOT_std_lc = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_lc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// le
	{
		tmp0 := sym_le.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(633), kw_column, int(7), kw_end_DASH_line, int(633), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__LT__EQ_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(634), kw_column, int(8), kw_end_DASH_line, int(634), kw_end_DASH_column, int(17))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__LT__EQ_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__LT__EQ_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_le = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_le.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// len
	{
		tmp0 := sym_len.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(580), kw_column, int(18), kw_end_DASH_line, int(580), kw_end_DASH_column, int(20), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_count)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(580), kw_column, int(22), kw_end_DASH_line, int(580), kw_end_DASH_column, int(39))).(lang.FnFunc)
		var_ys_DOT_std_len = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_len.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lines
	{
		tmp0 := sym_lines.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(99), kw_column, int(7), kw_end_DASH_line, int(99), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_S)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := lang.NewVector()
				tmp7 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(101), kw_column, int(5), kw_end_DASH_line, int(101), kw_end_DASH_column, int(6))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp8
			} else {
				var tmp9 any
				{ // let
					// let binding "S"
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp12 := checkDerefVar(var_clojure_DOT_core_last)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := lang.Apply(tmp11, []any{tmp13, lang.NewChar(10)})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_subs)
						tmp16 := checkDerefVar(var_clojure_DOT_core_dec)
						tmp17 := checkDerefVar(var_clojure_DOT_core_count)
						tmp18 := lang.Apply(tmp17, []any{v2})
						tmp19 := lang.Apply(tmp16, []any{tmp18})
						tmp20 := lang.Apply(tmp15, []any{v2, int64(0), tmp19})
						tmp10 = tmp20
					} else {
						tmp10 = v2
					}
					var v21 any = tmp10
					_ = v21
					tmp22 := checkDerefVar(var_clojure_DOT_string_split)
					tmp23 := lang.Apply(tmp22, []any{v21, regexp4.MustCompile("\\n"), int64(-1)})
					tmp9 = tmp23
				} // end let
				tmp3 = tmp9
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_lines = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_lines.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lt
	{
		tmp0 := sym_lt.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(628), kw_column, int(7), kw_end_DASH_line, int(628), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__LT_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(629), kw_column, int(8), kw_end_DASH_line, int(629), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__LT_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__LT_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_lt = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_lt.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mul
	{
		tmp0 := sym_mul.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(315), kw_column, int(7), kw_end_DASH_line, int(315), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__STAR_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(317), kw_column, int(8), kw_end_DASH_line, int(317), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_mul = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_mul.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mul+
	{
		tmp0 := sym_mul_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(422), kw_column, int(7), kw_end_DASH_line, int(422), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{v2})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						tmp9 = tmp11
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				if lang.IsTruthy(tmp5) {
					tmp6 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp7 := checkDerefVar(var_clojure_DOT_core_str)
					tmp8 := checkDerefVar(var_clojure_DOT_core_repeat)
					tmp9 := lang.Apply(tmp8, []any{v3, v2})
					tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9})
					tmp4 = tmp10
				} else {
					var tmp11 any
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v2})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						if lang.IsTruthy(v15) {
							tmp17 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v3})
							tmp16 = tmp18
						} else {
							tmp16 = v15
						}
						tmp12 = tmp16
					} // end let
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp14 := checkDerefVar(var_clojure_DOT_core_str)
						tmp15 := checkDerefVar(var_clojure_DOT_core_repeat)
						tmp16 := lang.Apply(tmp15, []any{v2, v3})
						tmp17 := lang.Apply(tmp13, []any{tmp14, tmp16})
						tmp11 = tmp17
					} else {
						var tmp18 any
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							tmp20 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
							tmp21 := lang.Apply(tmp20, []any{v2})
							var v22 any = tmp21
							_ = v22
							var tmp23 any
							if lang.IsTruthy(v22) {
								tmp24 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
								tmp25 := lang.Apply(tmp24, []any{v3})
								tmp23 = tmp25
							} else {
								tmp23 = v22
							}
							tmp19 = tmp23
						} // end let
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_clojure_DOT_core_vec)
							tmp21 := checkDerefVar(var_clojure_DOT_core_apply)
							tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp23 := checkDerefVar(var_clojure_DOT_core_repeat)
							tmp24 := lang.Apply(tmp23, []any{v3, v2})
							tmp25 := lang.Apply(tmp21, []any{tmp22, tmp24})
							tmp26 := lang.Apply(tmp20, []any{tmp25})
							tmp18 = tmp26
						} else {
							var tmp27 any
							var tmp28 any
							{ // let
								// let binding "and__0__auto__"
								tmp29 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
								tmp30 := lang.Apply(tmp29, []any{v2})
								var v31 any = tmp30
								_ = v31
								var tmp32 any
								if lang.IsTruthy(v31) {
									tmp33 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
									tmp34 := lang.Apply(tmp33, []any{v3})
									tmp32 = tmp34
								} else {
									tmp32 = v31
								}
								tmp28 = tmp32
							} // end let
							if lang.IsTruthy(tmp28) {
								tmp29 := checkDerefVar(var_clojure_DOT_core_vec)
								tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
								tmp31 := checkDerefVar(var_clojure_DOT_core_concat)
								tmp32 := checkDerefVar(var_clojure_DOT_core_repeat)
								tmp33 := lang.Apply(tmp32, []any{v2, v3})
								tmp34 := lang.Apply(tmp30, []any{tmp31, tmp33})
								tmp35 := lang.Apply(tmp29, []any{tmp34})
								tmp27 = tmp35
							} else {
								var tmp36 any
								var tmp37 any
								{ // let
									// let binding "and__0__auto__"
									tmp38 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
									tmp39 := lang.Apply(tmp38, []any{v2})
									var v40 any = tmp39
									_ = v40
									var tmp41 any
									if lang.IsTruthy(v40) {
										tmp42 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
										tmp43 := lang.Apply(tmp42, []any{v3})
										tmp41 = tmp43
									} else {
										tmp41 = v40
									}
									tmp37 = tmp41
								} // end let
								if lang.IsTruthy(tmp37) {
									tmp38 := checkDerefVar(var_clojure_DOT_core_apply)
									tmp39 := checkDerefVar(var_clojure_DOT_core_concat)
									tmp40 := checkDerefVar(var_clojure_DOT_core_repeat)
									tmp41 := lang.Apply(tmp40, []any{v3, v2})
									tmp42 := lang.Apply(tmp38, []any{tmp39, tmp41})
									tmp36 = tmp42
								} else {
									var tmp43 any
									var tmp44 any
									{ // let
										// let binding "and__0__auto__"
										tmp45 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
										tmp46 := lang.Apply(tmp45, []any{v2})
										var v47 any = tmp46
										_ = v47
										var tmp48 any
										if lang.IsTruthy(v47) {
											tmp49 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
											tmp50 := lang.Apply(tmp49, []any{v3})
											tmp48 = tmp50
										} else {
											tmp48 = v47
										}
										tmp44 = tmp48
									} // end let
									if lang.IsTruthy(tmp44) {
										tmp45 := checkDerefVar(var_clojure_DOT_core_apply)
										tmp46 := checkDerefVar(var_clojure_DOT_core_concat)
										tmp47 := checkDerefVar(var_clojure_DOT_core_repeat)
										tmp48 := lang.Apply(tmp47, []any{v2, v3})
										tmp49 := lang.Apply(tmp45, []any{tmp46, tmp48})
										tmp43 = tmp49
									} else {
										var tmp50 any
										tmp51 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
										tmp52 := lang.Apply(tmp51, []any{v2})
										if lang.IsTruthy(tmp52) {
											tmp53 := checkDerefVar(var_clojure_DOT_core_comp)
											tmp54 := lang.Apply(tmp53, []any{v3, v2})
											tmp50 = tmp54
										} else {
											var tmp55 any
											tmp56 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
											tmp57 := lang.Apply(tmp56, []any{v2})
											if lang.IsTruthy(tmp57) {
												tmp58 := checkDerefVar(var_yamlscript_DOT_util_die)
												tmp59 := lang.Apply(tmp58, []any{"Can't mul+ to a nil value"})
												tmp55 = tmp59
											} else {
												var tmp60 any
												if lang.IsTruthy(kw_else) {
													tmp61 := checkDerefVar(var_clojure_DOT_core__STAR_)
													tmp62 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
													tmp63 := lang.Apply(tmp62, []any{v2, int64(1)})
													tmp64 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
													tmp65 := lang.Apply(tmp64, []any{v3, int64(1)})
													tmp66 := lang.Apply(tmp61, []any{tmp63, tmp65})
													tmp60 = tmp66
												} else {
												}
												tmp55 = tmp60
											}
											tmp50 = tmp55
										}
										tmp43 = tmp50
									}
									tmp36 = tmp43
								}
								tmp27 = tmp36
							}
							tmp18 = tmp27
						}
						tmp11 = tmp18
					}
					tmp4 = tmp11
				}
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_reduce)
				tmp6 := checkDerefVar(var_ys_DOT_std_mul_PLUS_)
				tmp7 := checkDerefVar(var_ys_DOT_std_mul_PLUS_)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8, v4})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_mul_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_mul_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ne
	{
		tmp0 := sym_ne.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(613), kw_column, int(7), kw_end_DASH_line, int(613), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(614), kw_column, int(8), kw_end_DASH_line, int(614), kw_end_DASH_column, int(19))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_ne = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_ne.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// omap
	{
		tmp0 := sym_omap.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(266), kw_column, int(7), kw_end_DASH_line, int(266), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_omap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_omap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// op-error
	{
		tmp0 := sym_op_DASH_error.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(371), kw_column, int(8), kw_end_DASH_line, int(371), kw_end_DASH_column, int(15), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_op, sym_x), lang.NewVector(sym_op, sym_x, sym_y)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_yamlscript_DOT_util_die)
				tmp5 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{"Can't ", v2, "(", tmp6, ")"})
				return tmp7
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_yamlscript_DOT_util_die)
				tmp6 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp10 := lang.Apply(tmp5, []any{"Can't ", v2, "(", tmp7, " ", tmp9, ")"})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_op_DASH_error = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_op_DASH_error.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// or?
	{
		tmp0 := sym_or_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(806), kw_column, int(11), kw_end_DASH_line, int(806), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return nil
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_ys_DOT_std_SLASH_truey_QMARK_})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10})
				tmp12 := lang.Apply(tmp5, []any{tmp11})
				return tmp12
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_or})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_ys_DOT_std_SLASH_truey_QMARK_})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp23 := checkDerefVar(var_clojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_ys_DOT_std_SLASH_or_QMARK_})
				tmp25 := lang.Apply(tmp22, []any{tmp24, v5})
				tmp26 := lang.Apply(tmp21, []any{tmp25})
				tmp27 := lang.Apply(tmp20, []any{tmp26})
				tmp28 := lang.Apply(tmp7, []any{tmp9, tmp19, tmp27})
				tmp29 := lang.Apply(tmp6, []any{tmp28})
				return tmp29
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_or_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_or_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// process
	{
		tmp0 := sym_process.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(946), kw_column, int(7), kw_end_DASH_line, int(946), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_ipc_process)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_process = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_process.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// q
	{
		tmp0 := sym_q.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(587), kw_column, int(11), kw_end_DASH_line, int(587), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_quote})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10})
				tmp12 := lang.Apply(tmp5, []any{tmp11})
				return tmp12
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_quote})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v4})
				tmp15 := lang.Apply(tmp12, []any{tmp14, v5})
				tmp16 := lang.Apply(tmp11, []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp9, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_q = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_q.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ql
	{
		tmp0 := sym_ql.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(591), kw_column, int(11), kw_end_DASH_line, int(591), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_list})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_ql = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_ql.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qm
	{
		tmp0 := sym_qm.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(592), kw_column, int(11), kw_end_DASH_line, int(592), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_hash_DASH_map})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qm = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qm.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qo
	{
		tmp0 := sym_qo.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(593), kw_column, int(11), kw_end_DASH_line, int(593), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_ys_DOT_std_SLASH_omap})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qo = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qo.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qr
	{
		tmp0 := sym_qr.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(598), kw_column, int(7), kw_end_DASH_line, int(598), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_S)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_re_DASH_pattern)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qs
	{
		tmp0 := sym_qs.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(594), kw_column, int(11), kw_end_DASH_line, int(594), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_string_SLASH_join})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{" "})
				tmp11 := checkDerefVar(var_clojure_DOT_core_list)
				tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_quote})
				tmp16 := checkDerefVar(var_clojure_DOT_core_list)
				tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp17, []any{tmp19})
				tmp21 := lang.Apply(tmp16, []any{tmp20})
				tmp22 := lang.Apply(tmp13, []any{tmp15, tmp21})
				tmp23 := lang.Apply(tmp12, []any{tmp22})
				tmp24 := lang.Apply(tmp11, []any{tmp23})
				tmp25 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp24})
				tmp26 := lang.Apply(tmp5, []any{tmp25})
				return tmp26
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qv
	{
		tmp0 := sym_qv.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(596), kw_column, int(11), kw_end_DASH_line, int(596), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_vector})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qw
	{
		tmp0 := sym_qw.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(600), kw_column, int(11), kw_end_DASH_line, int(600), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				var tmp5 any
				{ // let
					// let binding "xs#"
					tmp6 := checkDerefVar(var_clojure_DOT_core_map)
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v8 := args[0]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v8})
						if lang.IsTruthy(tmp11) {
							tmp9 = "nil"
						} else {
							tmp12 := checkDerefVar(var_clojure_DOT_core_str)
							tmp13 := lang.Apply(tmp12, []any{v8})
							tmp9 = tmp13
						}
						return tmp9
					})
					tmp8 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(601), kw_column, int(18), kw_end_DASH_line, int(601), kw_end_DASH_column, int(47))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp10 := lang.Apply(tmp6, []any{tmp9, v4})
					var v11 any = tmp10
					_ = v11
					tmp12 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp13 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp14 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp16 := lang.Apply(tmp15, []any{v11})
					tmp17 := lang.Apply(tmp14, []any{tmp16})
					tmp18 := lang.Apply(tmp12, []any{tmp13, tmp17})
					tmp5 = tmp18
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_qw = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_qw.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read
	{
		tmp0 := sym_read.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(546), kw_column, int(18), kw_end_DASH_line, int(546), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_slurp)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(546), kw_column, int(23), kw_end_DASH_line, int(546), kw_end_DASH_column, int(54))).(lang.FnFunc)
		var_ys_DOT_std_read = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_read.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// regex?
	{
		tmp0 := sym_regex_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(17), kw_column, int(8), kw_end_DASH_line, int(17), kw_end_DASH_column, int(13), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*regexp4.Regexp)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_regex_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_regex_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp0 := sym_replace.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(112), kw_column, int(7), kw_end_DASH_line, int(112), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym_z)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_replace)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := checkDerefVar(var_ys_DOT_std_regex_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp9 = v8
					} else {
						tmp10 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						tmp9 = tmp11
					}
					tmp5 = tmp9
				} // end let
				if lang.IsTruthy(tmp5) {
					tmp6 := checkDerefVar(var_clojure_DOT_string_replace)
					tmp7 := lang.Apply(tmp6, []any{v2, v3, ""})
					tmp4 = tmp7
				} else {
					tmp8 := checkDerefVar(var_clojure_DOT_core_replace)
					tmp9 := lang.Apply(tmp8, []any{v2, v3})
					tmp4 = tmp9
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_string_replace)
				tmp6 := lang.Apply(tmp5, []any{v2, v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace1
	{
		tmp0 := sym_replace1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(120), kw_column, int(18), kw_end_DASH_line, int(120), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_string_replace_DASH_first)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(120), kw_column, int(27), kw_end_DASH_line, int(120), kw_end_DASH_column, int(70))).(lang.FnFunc)
		var_ys_DOT_std_replace1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_replace1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset
	{
		tmp0 := sym_reset.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(1026), kw_column, int(7), kw_end_DASH_line, int(1026), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_reset_BANG_)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_reset = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_reset.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp0 := sym_reverse.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(273), kw_column, int(7), kw_end_DASH_line, int(273), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__90"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__91"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_string_reverse)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp7 = tmp11
				} else {
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
					tmp14 := lang.Apply(v5, []any{tmp13, v6})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_clojure_DOT_core_vec)
						tmp16 := checkDerefVar(var_clojure_DOT_core_reverse)
						tmp17 := lang.Apply(tmp16, []any{v2})
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						tmp12 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
						tmp21 := lang.Apply(v5, []any{tmp20, v6})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(var_clojure_DOT_core_reverse)
							tmp23 := lang.Apply(tmp22, []any{v2})
							tmp19 = tmp23
						} else {
							tmp24 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp25 := lang.Apply(tmp24, []any{"Can't reverse ", v2})
							tmp19 = tmp25
						}
						tmp12 = tmp19
					}
					tmp7 = tmp12
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_reverse = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_reverse.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rindex
	{
		tmp0 := sym_rindex.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(122), kw_column, int(18), kw_end_DASH_line, int(122), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_string_last_DASH_index_DASH_of)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(122), kw_column, int(25), kw_end_DASH_line, int(122), kw_end_DASH_column, int(68))).(lang.FnFunc)
		var_ys_DOT_std_rindex = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_rindex.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rng
	{
		tmp0 := sym_rng.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(280), kw_column, int(7), kw_end_DASH_line, int(280), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "vec__92"
				var tmp5 any
				{ // let
					// let binding "iter__0__auto__"
					var tmp6 lang.FnFunc
					{ // function iter__95
						var v7 lang.FnFunc
						tmp6 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v8 := args[0]
							_ = v8
							var tmp9 lang.FnFunc
							tmp9 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp10 any
								{ // let
									// let binding "s__96"
									var v11 any = v8
									_ = v11
									for {
										var tmp12 any
										{ // let
											// let binding "temp__0__auto__"
											tmp13 := checkDerefVar(var_clojure_DOT_core_seq)
											tmp14 := lang.Apply(tmp13, []any{v11})
											var v15 any = tmp14
											_ = v15
											var tmp16 any
											if lang.IsTruthy(v15) {
												var tmp17 any
												{ // let
													// let binding "s__96"
													var v18 any = v15
													_ = v18
													var tmp19 any
													tmp20 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
													tmp21 := lang.Apply(tmp20, []any{v18})
													if lang.IsTruthy(tmp21) {
														var tmp22 any
														{ // let
															// let binding "c__0__auto__"
															tmp23 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
															tmp24 := lang.Apply(tmp23, []any{v18})
															var v25 any = tmp24
															_ = v25
															// let binding "size__1__auto__"
															tmp26 := checkDerefVar(var_clojure_DOT_core_int)
															tmp27 := checkDerefVar(var_clojure_DOT_core_count)
															tmp28 := lang.Apply(tmp27, []any{v25})
															tmp29 := lang.Apply(tmp26, []any{tmp28})
															var v30 any = tmp29
															_ = v30
															// let binding "b__98"
															tmp31 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_buffer)
															tmp32 := lang.Apply(tmp31, []any{v30})
															var v33 any = tmp32
															_ = v33
															var tmp34 any
															var tmp35 any
															{ // let
																// let binding "i__97"
																tmp36 := checkDerefVar(var_clojure_DOT_core_int)
																tmp37 := lang.Apply(tmp36, []any{int64(0)})
																var v38 any = tmp37
																_ = v38
																for {
																	var tmp39 any
																	tmp40 := checkDerefVar(var_clojure_DOT_core__LT_)
																	tmp41 := lang.Apply(tmp40, []any{v38, v30})
																	if lang.IsTruthy(tmp41) {
																		var tmp42 any
																		{ // let
																			// let binding "n"
																			tmp43, _ := lang.FieldOrMethod(v25, "nth")
																			if reflect.TypeOf(tmp43).Kind() != reflect.Func {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																			}
																			tmp44 := lang.Apply(tmp43, []any{v38})
																			var v45 any = tmp44
																			_ = v45
																			tmp46 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_append)
																			var tmp47 any
																			tmp48 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
																			tmp49 := lang.Apply(tmp48, []any{v45})
																			if lang.IsTruthy(tmp49) {
																				tmp50 := checkDerefVar(var_clojure_DOT_core_long)
																				tmp51 := lang.Apply(tmp50, []any{v45})
																				tmp47 = tmp51
																			} else {
																				tmp47 = v45
																			}
																			tmp52 := lang.Apply(tmp46, []any{v33, tmp47})
																			_ = tmp52
																			tmp54 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
																			tmp55 := lang.Apply(tmp54, []any{v38})
																			var tmp53 any = tmp55
																			v38 = tmp53
																			continue
																		} // end let
																		tmp39 = tmp42
																	} else {
																		tmp39 = true
																	}
																	tmp35 = tmp39
																	break
																}
															} // end let
															if lang.IsTruthy(tmp35) {
																tmp36 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_cons)
																tmp37 := checkDerefVar(var_clojure_DOT_core_chunk)
																tmp38 := lang.Apply(tmp37, []any{v33})
																tmp39 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
																tmp40 := lang.Apply(tmp39, []any{v18})
																tmp41 := lang.Apply(v7, []any{tmp40})
																tmp42 := lang.Apply(tmp36, []any{tmp38, tmp41})
																tmp34 = tmp42
															} else {
																tmp43 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_cons)
																tmp44 := checkDerefVar(var_clojure_DOT_core_chunk)
																tmp45 := lang.Apply(tmp44, []any{v33})
																tmp46 := lang.Apply(tmp43, []any{tmp45, nil})
																tmp34 = tmp46
															}
															tmp22 = tmp34
														} // end let
														tmp19 = tmp22
													} else {
														var tmp23 any
														{ // let
															// let binding "n"
															tmp24 := checkDerefVar(var_clojure_DOT_core_first)
															tmp25 := lang.Apply(tmp24, []any{v18})
															var v26 any = tmp25
															_ = v26
															tmp27 := checkDerefVar(var_clojure_DOT_core_cons)
															var tmp28 any
															tmp29 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
															tmp30 := lang.Apply(tmp29, []any{v26})
															if lang.IsTruthy(tmp30) {
																tmp31 := checkDerefVar(var_clojure_DOT_core_long)
																tmp32 := lang.Apply(tmp31, []any{v26})
																tmp28 = tmp32
															} else {
																tmp28 = v26
															}
															tmp33 := checkDerefVar(var_clojure_DOT_core_rest)
															tmp34 := lang.Apply(tmp33, []any{v18})
															tmp35 := lang.Apply(v7, []any{tmp34})
															tmp36 := lang.Apply(tmp27, []any{tmp28, tmp35})
															tmp23 = tmp36
														} // end let
														tmp19 = tmp23
													}
													tmp17 = tmp19
												} // end let
												tmp16 = tmp17
											} else {
											}
											tmp12 = tmp16
										} // end let
										tmp10 = tmp12
										break
									}
								} // end let
								return tmp10
							})
							tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
							return tmp10
						})
						v7 = tmp6
						_ = v7
					}
					var v7 any = tmp6
					_ = v7
					tmp8 := lang.NewVector(v2, v3)
					tmp9 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(281), kw_column, int(23), kw_end_DASH_line, int(281), kw_end_DASH_column, int(27))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := lang.Apply(v7, []any{tmp10})
					tmp5 = tmp11
				} // end let
				var v6 any = tmp5
				_ = v6
				// let binding "a"
				tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
				var v9 any = tmp8
				_ = v9
				// let binding "b"
				tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				var tmp14 any
				{ // let
					// let binding "and__0__auto__"
					tmp15 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v2})
					var v17 any = tmp16
					_ = v17
					var tmp18 any
					if lang.IsTruthy(v17) {
						tmp19 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
						tmp20 := lang.Apply(tmp19, []any{v3})
						tmp18 = tmp20
					} else {
						tmp18 = v17
					}
					tmp14 = tmp18
				} // end let
				if lang.IsTruthy(tmp14) {
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core__GT_)
					tmp17 := lang.Apply(tmp16, []any{v12, v9})
					if lang.IsTruthy(tmp17) {
						tmp18 := checkDerefVar(var_clojure_DOT_core_range)
						tmp19 := checkDerefVar(var_clojure_DOT_core_inc)
						tmp20 := lang.Apply(tmp19, []any{v12})
						tmp21 := lang.Apply(tmp18, []any{v9, tmp20})
						tmp15 = tmp21
					} else {
						tmp22 := checkDerefVar(var_clojure_DOT_core_range)
						tmp23 := checkDerefVar(var_clojure_DOT_core_dec)
						tmp24 := lang.Apply(tmp23, []any{v12})
						tmp25 := lang.Apply(tmp22, []any{v9, tmp24, int64(-1)})
						tmp15 = tmp25
					}
					tmp13 = tmp15
				} else {
					var tmp26 any
					var tmp27 any
					{ // let
						// let binding "and__0__auto__"
						tmp28 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
						tmp29 := lang.Apply(tmp28, []any{v2})
						var v30 any = tmp29
						_ = v30
						var tmp31 any
						if lang.IsTruthy(v30) {
							tmp32 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
							tmp33 := lang.Apply(tmp32, []any{v3})
							tmp31 = tmp33
						} else {
							tmp31 = v30
						}
						tmp27 = tmp31
					} // end let
					if lang.IsTruthy(tmp27) {
						var tmp28 any
						tmp29 := checkDerefVar(var_clojure_DOT_core__GT_)
						tmp30 := lang.Apply(tmp29, []any{v12, v9})
						if lang.IsTruthy(tmp30) {
							tmp31 := checkDerefVar(var_clojure_DOT_core_map)
							tmp32 := checkDerefVar(var_clojure_DOT_core_char)
							tmp33 := checkDerefVar(var_clojure_DOT_core_range)
							tmp34 := checkDerefVar(var_clojure_DOT_core_inc)
							tmp35 := lang.Apply(tmp34, []any{v12})
							tmp36 := lang.Apply(tmp33, []any{v9, tmp35})
							tmp37 := lang.Apply(tmp31, []any{tmp32, tmp36})
							tmp28 = tmp37
						} else {
							tmp38 := checkDerefVar(var_clojure_DOT_core_map)
							tmp39 := checkDerefVar(var_clojure_DOT_core_char)
							tmp40 := checkDerefVar(var_clojure_DOT_core_range)
							tmp41 := checkDerefVar(var_clojure_DOT_core_dec)
							tmp42 := lang.Apply(tmp41, []any{v12})
							tmp43 := lang.Apply(tmp40, []any{v9, tmp42, int64(-1)})
							tmp44 := lang.Apply(tmp38, []any{tmp39, tmp43})
							tmp28 = tmp44
						}
						tmp26 = tmp28
					} else {
						var tmp45 any
						if lang.IsTruthy(kw_else) {
							tmp46 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp47 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
							tmp48 := lang.Apply(tmp47, []any{v2})
							tmp49 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
							tmp50 := lang.Apply(tmp49, []any{v3})
							tmp51 := lang.Apply(tmp46, []any{"Can't rng(", tmp48, ", ", tmp50, ")"})
							tmp45 = tmp51
						} else {
						}
						tmp26 = tmp45
					}
					tmp13 = tmp26
				}
				tmp4 = tmp13
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_rng = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_rng.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// say
	{
		tmp0 := sym_say.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(563), kw_column, int(7), kw_end_DASH_line, int(563), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_println)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_say = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_say.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := sym_set.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(706), kw_column, int(7), kw_end_DASH_line, int(706), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp3 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(707), kw_column, int(7), kw_end_DASH_line, int(707), kw_end_DASH_column, int(9))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_set)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sh
	{
		tmp0 := sym_sh.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(949), kw_column, int(7), kw_end_DASH_line, int(949), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_ipc_sh)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sh = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sh.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sh-out
	{
		tmp0 := sym_sh_DASH_out.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(955), kw_column, int(7), kw_end_DASH_line, int(955), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					// let binding "ret"
					tmp4 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp5 := checkDerefVar(var_ys_DOT_std_sh)
					tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
					tmp10 := lang.Apply(kw_exit, []any{v7})
					tmp11 := lang.Apply(tmp9, []any{int64(0), tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_yamlscript_DOT_util_die)
						tmp13 := lang.Apply(kw_err, []any{v7})
						tmp14 := lang.Apply(tmp12, []any{tmp13})
						tmp8 = tmp14
					} else {
					}
					_ = tmp8
					tmp15 := checkDerefVar(var_clojure_DOT_string_trim_DASH_newline)
					tmp16 := lang.Apply(kw_out, []any{v7})
					tmp17 := lang.Apply(tmp15, []any{tmp16})
					tmp3 = tmp17
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sh_DASH_out = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sh_DASH_out.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shell
	{
		tmp0 := sym_shell.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(952), kw_column, int(7), kw_end_DASH_line, int(952), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_ys_DOT_ipc_shell)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_shell = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_shell.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// slice
	{
		tmp0 := sym_slice.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(294), kw_column, int(7), kw_end_DASH_line, int(294), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_C, sym__AMP_, sym_ks)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ks"
					tmp5 := checkDerefVar(var_clojure_DOT_core_flatten)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					tmp8 := checkDerefVar(var_clojure_DOT_core_vec)
					tmp9 := checkDerefVar(var_clojure_DOT_core_map)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v11 := args[0]
						_ = v11
						tmp12 := checkDerefVar(var_ys_DOT_std_get_PLUS_)
						tmp13 := lang.Apply(tmp12, []any{v2, v11})
						return tmp13
					})
					tmp11 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(296), kw_column, int(15), kw_end_DASH_line, int(296), kw_end_DASH_column, int(33))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{tmp12, v7})
					tmp14 := lang.Apply(tmp8, []any{tmp13})
					tmp4 = tmp14
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_slice = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_slice.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split
	{
		tmp0 := sym_split.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(124), kw_column, int(7), kw_end_DASH_line, int(124), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_S), lang.NewVector(sym_S, sym_R)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "S"
					tmp4 := checkDerefVar(var_clojure_DOT_core_str)
					tmp5 := lang.Apply(tmp4, []any{v2})
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.NewVector()
						tmp11 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(128), kw_column, int(8), kw_end_DASH_line, int(128), kw_end_DASH_column, int(9))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp7 = tmp12
					} else {
						tmp13 := checkDerefVar(var_clojure_DOT_string_split)
						tmp14 := lang.Apply(tmp13, []any{v6, regexp4.MustCompile("")})
						tmp7 = tmp14
					}
					tmp3 = tmp7
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "vec__70"
					var tmp5 any
					tmp6 := checkDerefVar(var_ys_DOT_std_regex_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{v2})
					if lang.IsTruthy(tmp7) {
						tmp8 := lang.NewVector(v3, v2)
						tmp9 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(131), kw_column, int(31), kw_end_DASH_line, int(131), kw_end_DASH_column, int(35))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp10
					} else {
						tmp11 := lang.NewVector(v2, v3)
						tmp12 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(131), kw_column, int(37), kw_end_DASH_line, int(131), kw_end_DASH_column, int(41))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp13
					}
					var v14 any = tmp5
					_ = v14
					// let binding "S"
					tmp15 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
					var v17 any = tmp16
					_ = v17
					// let binding "R"
					tmp18 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
					var v20 any = tmp19
					_ = v20
					// let binding "S"
					tmp21 := checkDerefVar(var_clojure_DOT_core_str)
					tmp22 := lang.Apply(tmp21, []any{v17})
					var v23 any = tmp22
					_ = v23
					// let binding "R"
					var tmp24 any
					tmp25 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
					tmp26 := lang.Apply(tmp25, []any{v20})
					if lang.IsTruthy(tmp26) {
						tmp27 := checkDerefVar(var_clojure_DOT_core_re_DASH_pattern)
						tmp28 := lang.Apply(tmp27, []any{v20})
						tmp24 = tmp28
					} else {
						tmp24 = v20
					}
					var v29 any = tmp24
					_ = v29
					tmp30 := checkDerefVar(var_clojure_DOT_string_split)
					tmp31 := lang.Apply(tmp30, []any{v23, v29})
					tmp4 = tmp31
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_split = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_split.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sqrt
	{
		tmp0 := sym_sqrt.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(362), kw_column, int(7), kw_end_DASH_line, int(362), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "epsilon"
				var v4 any = float64(1e-15)
				_ = v4
				// let binding "abs-fn"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_clojure_DOT_core__LT_)
					tmp9 := lang.Apply(tmp8, []any{v6, int64(0)})
					if lang.IsTruthy(tmp9) {
						tmp10 := checkDerefVar(var_clojure_DOT_core__DASH_)
						tmp11 := lang.Apply(tmp10, []any{v6})
						tmp7 = tmp11
					} else {
						tmp7 = v6
					}
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(364), kw_column, int(16), kw_end_DASH_line, int(364), kw_end_DASH_column, int(44))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				{ // let
					// let binding "guess"
					var v10 any = float64(1)
					_ = v10
					for {
						var tmp11 any
						{ // let
							// let binding "next-guess"
							tmp12 := checkDerefVar(var_clojure_DOT_core__SLASH_)
							tmp13 := checkDerefVar(var_clojure_DOT_core__PLUS_)
							tmp14 := checkDerefVar(var_clojure_DOT_core__SLASH_)
							tmp15 := lang.Apply(tmp14, []any{v2, v10})
							tmp16 := lang.Apply(tmp13, []any{v10, tmp15})
							tmp17 := lang.Apply(tmp12, []any{tmp16, int64(2)})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							tmp20 := checkDerefVar(var_clojure_DOT_core__LT_)
							tmp21 := checkDerefVar(var_clojure_DOT_core__DASH_)
							tmp22 := lang.Apply(tmp21, []any{v18, v10})
							tmp23 := lang.Apply(v8, []any{tmp22})
							tmp24 := lang.Apply(tmp20, []any{tmp23, v4})
							if lang.IsTruthy(tmp24) {
								tmp19 = v18
							} else {
								var tmp25 any = v18
								v10 = tmp25
								continue
							}
							tmp11 = tmp19
						} // end let
						tmp9 = tmp11
						break
					}
				} // end let
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sqrt = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sqrt.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// starts?
	{
		tmp0 := sym_starts_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(137), kw_column, int(18), kw_end_DASH_line, int(137), kw_end_DASH_column, int(24), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_string_starts_DASH_with_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(137), kw_column, int(26), kw_end_DASH_line, int(137), kw_end_DASH_column, int(58))).(lang.FnFunc)
		var_ys_DOT_std_starts_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_starts_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sub
	{
		tmp0 := sym_sub.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(310), kw_column, int(7), kw_end_DASH_line, int(310), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_clojure_DOT_core__DASH_)
					tmp6 := lang.Apply(tmp5, []any{v4, v2})
					return tmp6
				})
				tmp4 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(311), kw_column, int(8), kw_end_DASH_line, int(311), kw_end_DASH_column, int(16))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sub = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sub.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sub+
	{
		tmp0 := sym_sub_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(438), kw_column, int(7), kw_end_DASH_line, int(438), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "pred__113"
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v6, []any{v7})
						return tmp8
					})
					var v6 any = tmp5
					_ = v6
					// let binding "expr__114"
					var v7 any = v2
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
					tmp10 := lang.Apply(v6, []any{tmp9, v7})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_clojure_DOT_string_replace)
						tmp12 := checkDerefVar(var_clojure_DOT_core_str)
						tmp13 := lang.Apply(tmp12, []any{v3})
						tmp14 := lang.Apply(tmp11, []any{v2, tmp13, ""})
						tmp8 = tmp14
					} else {
						var tmp15 any
						tmp16 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
						tmp17 := lang.Apply(v6, []any{tmp16, v7})
						if lang.IsTruthy(tmp17) {
							tmp18 := checkDerefVar(var_clojure_DOT_core_dissoc)
							tmp19 := lang.Apply(tmp18, []any{v2, v3})
							tmp15 = tmp19
						} else {
							var tmp20 any
							tmp21 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
							tmp22 := lang.Apply(v6, []any{tmp21, v7})
							if lang.IsTruthy(tmp22) {
								tmp23 := checkDerefVar(var_clojure_DOT_core_disj)
								tmp24 := lang.Apply(tmp23, []any{v2, v3})
								tmp20 = tmp24
							} else {
								var tmp25 any
								tmp26 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
								tmp27 := lang.Apply(v6, []any{tmp26, v7})
								if lang.IsTruthy(tmp27) {
									tmp28 := checkDerefVar(var_clojure_DOT_core_vec)
									tmp29 := checkDerefVar(var_clojure_DOT_core_remove)
									var tmp30 lang.FnFunc
									tmp30 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v31 := args[0]
										_ = v31
										tmp32 := checkDerefVar(var_clojure_DOT_core__EQ_)
										tmp33 := lang.Apply(tmp32, []any{v3, v31})
										return tmp33
									})
									tmp31 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(444), kw_column, int(27), kw_end_DASH_line, int(444), kw_end_DASH_column, int(35))
									tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp33 := lang.Apply(tmp29, []any{tmp32, v2})
									tmp34 := lang.Apply(tmp28, []any{tmp33})
									tmp25 = tmp34
								} else {
									var tmp35 any
									tmp36 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
									tmp37 := lang.Apply(v6, []any{tmp36, v7})
									if lang.IsTruthy(tmp37) {
										tmp38 := checkDerefVar(var_clojure_DOT_core__DASH_)
										tmp39 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
										tmp40 := lang.Apply(tmp39, []any{v3, int64(0)})
										tmp41 := lang.Apply(tmp38, []any{v2, tmp40})
										tmp35 = tmp41
									} else {
										var tmp42 any
										tmp43 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
										tmp44 := lang.Apply(v6, []any{tmp43, v7})
										if lang.IsTruthy(tmp44) {
											var tmp45 any
											{ // let
												// let binding "pred__115"
												var tmp46 lang.FnFunc
												tmp46 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 2)
													v47 := args[0]
													_ = v47
													v48 := args[1]
													_ = v48
													tmp49 := lang.Apply(v47, []any{v48})
													return tmp49
												})
												var v47 any = tmp46
												_ = v47
												// let binding "expr__116"
												var v48 any = v3
												_ = v48
												var tmp49 any
												tmp50 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
												tmp51 := lang.Apply(v47, []any{tmp50, v48})
												if lang.IsTruthy(tmp51) {
													tmp52 := checkDerefVar(var_clojure_DOT_core_char)
													tmp53 := checkDerefVar(var_clojure_DOT_core__DASH_)
													tmp54 := checkDerefVar(var_clojure_DOT_core_long)
													tmp55 := lang.Apply(tmp54, []any{v2})
													tmp56 := lang.Apply(tmp53, []any{tmp55, v3})
													tmp57 := lang.Apply(tmp52, []any{tmp56})
													tmp49 = tmp57
												} else {
													var tmp58 any
													tmp59 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
													tmp60 := lang.Apply(v47, []any{tmp59, v48})
													if lang.IsTruthy(tmp60) {
														tmp61 := checkDerefVar(var_clojure_DOT_core__DASH_)
														tmp62 := checkDerefVar(var_clojure_DOT_core_long)
														tmp63 := lang.Apply(tmp62, []any{v2})
														tmp64 := checkDerefVar(var_clojure_DOT_core_long)
														tmp65 := lang.Apply(tmp64, []any{v3})
														tmp66 := lang.Apply(tmp61, []any{tmp63, tmp65})
														tmp58 = tmp66
													} else {
														tmp67 := checkDerefVar(var_ys_DOT_std_op_DASH_error)
														tmp68 := lang.Apply(tmp67, []any{"sub", v2, v3})
														tmp58 = tmp68
													}
													tmp49 = tmp58
												}
												tmp45 = tmp49
											} // end let
											tmp42 = tmp45
										} else {
											var tmp46 any
											tmp47 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
											tmp48 := lang.Apply(v6, []any{tmp47, v7})
											if lang.IsTruthy(tmp48) {
												tmp49 := checkDerefVar(var_yamlscript_DOT_util_die)
												tmp50 := lang.Apply(tmp49, []any{"Can't sub+ to a nil value"})
												tmp46 = tmp50
											} else {
												var tmp51 any
												tmp52 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
												tmp53 := lang.Apply(v6, []any{tmp52, v7})
												if lang.IsTruthy(tmp53) {
													tmp54 := checkDerefVar(var_clojure_DOT_core_remove)
													var tmp55 lang.FnFunc
													tmp55 = lang.NewFnFunc(func(args ...any) any {
														checkArity(args, 1)
														v56 := args[0]
														_ = v56
														tmp57 := checkDerefVar(var_clojure_DOT_core__EQ_)
														tmp58 := lang.Apply(tmp57, []any{v3, v56})
														return tmp58
													})
													tmp56 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(451), kw_column, int(23), kw_end_DASH_line, int(451), kw_end_DASH_column, int(31))
													tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp58 := lang.Apply(tmp54, []any{tmp57, v2})
													tmp51 = tmp58
												} else {
													tmp59 := checkDerefVar(var_clojure_DOT_core__PLUS_)
													tmp60 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
													tmp61 := lang.Apply(tmp60, []any{v2, int64(0)})
													tmp62 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
													tmp63 := lang.Apply(tmp62, []any{v3, int64(0)})
													tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
													tmp51 = tmp64
												}
												tmp46 = tmp51
											}
											tmp42 = tmp46
										}
										tmp35 = tmp42
									}
									tmp25 = tmp35
								}
								tmp20 = tmp25
							}
							tmp15 = tmp20
						}
						tmp8 = tmp15
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_reduce)
				tmp6 := checkDerefVar(var_ys_DOT_std_sub_PLUS_)
				tmp7 := checkDerefVar(var_ys_DOT_std_sub_PLUS_)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8, v4})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sub_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sub_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// substr
	{
		tmp0 := sym_substr.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(139), kw_column, int(7), kw_end_DASH_line, int(139), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_str, sym_off), lang.NewVector(sym_str, sym_off, sym_len)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_ys_DOT_std_substr)
				tmp5 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp6 := checkDerefVar(var_clojure_DOT_core_count)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v3})
				tmp9 := lang.Apply(tmp4, []any{v2, v3, tmp8})
				return tmp9
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "slen"
					tmp6 := checkDerefVar(var_clojure_DOT_core_count)
					tmp7 := lang.Apply(tmp6, []any{v2})
					var v8 any = tmp7
					_ = v8
					// let binding "off"
					var tmp9 any
					tmp10 := checkDerefVar(var_clojure_DOT_core_neg_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v3})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_clojure_DOT_core__PLUS_)
						tmp13 := lang.Apply(tmp12, []any{v8, v3})
						tmp9 = tmp13
					} else {
						tmp9 = v3
					}
					var v14 any = tmp9
					_ = v14
					// let binding "vec__73"
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core_neg_QMARK_)
					tmp17 := lang.Apply(tmp16, []any{v4})
					if lang.IsTruthy(tmp17) {
						var tmp18 any
						{ // let
							// let binding "len"
							tmp19 := checkDerefVar(var_clojure_DOT_core_max)
							tmp20 := checkDerefVar(var_clojure_DOT_core__PLUS_)
							tmp21 := lang.Apply(tmp20, []any{v8, v4})
							tmp22 := lang.Apply(tmp19, []any{int64(0), tmp21})
							var v23 any = tmp22
							_ = v23
							tmp24 := lang.NewVector(v23, v23)
							tmp25 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(146), kw_column, int(25), kw_end_DASH_line, int(146), kw_end_DASH_column, int(33))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp26
						} // end let
						tmp15 = tmp18
					} else {
						tmp19 := lang.NewVector(v4, v8)
						tmp20 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(147), kw_column, int(23), kw_end_DASH_line, int(147), kw_end_DASH_column, int(32))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp15 = tmp21
					}
					var v22 any = tmp15
					_ = v22
					// let binding "len"
					tmp23 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
					var v25 any = tmp24
					_ = v25
					// let binding "slen"
					tmp26 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp27 := lang.Apply(tmp26, []any{v22, int64(1), nil})
					var v28 any = tmp27
					_ = v28
					var tmp29 any
					{ // let
						// let binding "pred__76"
						tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
						var v31 any = tmp30
						_ = v31
						// let binding "expr__77"
						tmp32 := lang.NewVector(v14, v28)
						tmp33 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(148), kw_column, int(19), kw_end_DASH_line, int(148), kw_end_DASH_column, int(28))
						tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v35 any = tmp34
						_ = v35
						var tmp36 any
						tmp37 := checkDerefVar(var_clojure_DOT_core__LT_)
						tmp38 := lang.Apply(v31, []any{tmp37, v35})
						if lang.IsTruthy(tmp38) {
							var tmp39 any
							tmp40 := checkDerefVar(var_clojure_DOT_core__GT__EQ_)
							tmp41 := checkDerefVar(var_clojure_DOT_core__PLUS_)
							tmp42 := lang.Apply(tmp41, []any{v14, v25})
							tmp43 := lang.Apply(tmp40, []any{tmp42, int64(0)})
							if lang.IsTruthy(tmp43) {
								var tmp44 any
								{ // let
									// let binding "vec__78"
									var tmp45 any
									tmp46 := checkDerefVar(var_clojure_DOT_core_neg_QMARK_)
									tmp47 := lang.Apply(tmp46, []any{v14})
									if lang.IsTruthy(tmp47) {
										tmp48 := checkDerefVar(var_clojure_DOT_core__PLUS_)
										tmp49 := lang.Apply(tmp48, []any{v14, v25})
										tmp50 := lang.NewVector(int64(0), tmp49)
										tmp51 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(151), kw_column, int(30), kw_end_DASH_line, int(151), kw_end_DASH_column, int(44))
										tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp45 = tmp52
									} else {
										tmp53 := lang.NewVector(v14, v25)
										tmp54 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(152), kw_column, int(30), kw_end_DASH_line, int(152), kw_end_DASH_column, int(38))
										tmp55, err := lang.WithMeta(tmp53, tmp54.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp45 = tmp55
									}
									var v56 any = tmp45
									_ = v56
									// let binding "off"
									tmp57 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp58 := lang.Apply(tmp57, []any{v56, int64(0), nil})
									var v59 any = tmp58
									_ = v59
									// let binding "len"
									tmp60 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp61 := lang.Apply(tmp60, []any{v56, int64(1), nil})
									var v62 any = tmp61
									_ = v62
									// let binding "len"
									var tmp63 any
									tmp64 := checkDerefVar(var_clojure_DOT_core__GT_)
									tmp65 := checkDerefVar(var_clojure_DOT_core__PLUS_)
									tmp66 := lang.Apply(tmp65, []any{v59, v62})
									tmp67 := lang.Apply(tmp64, []any{tmp66, v28})
									if lang.IsTruthy(tmp67) {
										tmp68 := checkDerefVar(var_clojure_DOT_core__DASH_)
										tmp69 := lang.Apply(tmp68, []any{v28, v59})
										tmp63 = tmp69
									} else {
										tmp63 = v62
									}
									var v70 any = tmp63
									_ = v70
									tmp71 := checkDerefVar(var_clojure_DOT_core_subs)
									tmp72 := checkDerefVar(var_clojure_DOT_core__PLUS_)
									tmp73 := lang.Apply(tmp72, []any{v59, v70})
									tmp74 := lang.Apply(tmp71, []any{v2, v59, tmp73})
									tmp44 = tmp74
								} // end let
								tmp39 = tmp44
							} else {
							}
							tmp36 = tmp39
						} else {
							var tmp45 any
							tmp46 := checkDerefVar(var_clojure_DOT_core__EQ_)
							tmp47 := lang.Apply(v31, []any{tmp46, v35})
							if lang.IsTruthy(tmp47) {
								tmp45 = ""
							} else {
								var tmp48 any
								tmp49 := checkDerefVar(var_clojure_DOT_core__GT_)
								tmp50 := lang.Apply(v31, []any{tmp49, v35})
								if lang.IsTruthy(tmp50) {
								} else {
									tmp51 := checkDerefVar(var_clojure_DOT_core_str)
									tmp52 := lang.Apply(tmp51, []any{"No matching clause: ", v35})
									tmp53 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp52})
									panic(tmp53)
								}
								tmp45 = tmp48
							}
							tmp36 = tmp45
						}
						tmp29 = tmp36
					} // end let
					tmp5 = tmp29
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_substr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_substr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sum
	{
		tmp0 := sym_sum.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(355), kw_column, int(7), kw_end_DASH_line, int(355), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_reduce)
			tmp4 := checkDerefVar(var_clojure_DOT_core__PLUS_)
			tmp5 := checkDerefVar(var_clojure_DOT_core_filter)
			tmp6 := checkDerefVar(var_clojure_DOT_core_identity)
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			tmp8 := lang.Apply(tmp3, []any{tmp4, int64(0), tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_sum = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_sum.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap
	{
		tmp0 := sym_swap.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(1029), kw_column, int(7), kw_end_DASH_line, int(1029), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_f, sym__AMP_, sym_xs)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_clojure_DOT_core_swap_BANG_)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2, v3})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_swap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_swap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// text
	{
		tmp0 := sym_text.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(158), kw_column, int(7), kw_end_DASH_line, int(158), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_Ss)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp3 = ""
			} else {
				tmp6 := checkDerefVar(var_clojure_DOT_string_join)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{""})
				tmp10 := lang.Apply(tmp7, []any{v2, tmp9})
				tmp11 := lang.Apply(tmp6, []any{"\n", tmp10})
				tmp3 = tmp11
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_text = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_text.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-bool
	{
		tmp0 := sym_to_DASH_bool.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(644), kw_column, int(7), kw_end_DASH_line, int(644), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_boolean)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_bool = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_bool.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-char
	{
		tmp0 := sym_to_DASH_char.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(646), kw_column, int(7), kw_end_DASH_line, int(646), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__117"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__118"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp7 = v2
				} else {
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
					tmp12 := lang.Apply(v5, []any{tmp11, v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any
						tmp14 := checkDerefVar(var_clojure_DOT_core__EQ_)
						tmp15 := checkDerefVar(var_clojure_DOT_core_count)
						tmp16 := lang.Apply(tmp15, []any{v2})
						tmp17 := lang.Apply(tmp14, []any{int64(1), tmp16})
						if lang.IsTruthy(tmp17) {
							tmp18 := checkDerefVar(var_clojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v2})
							tmp13 = tmp19
						} else {
							tmp20 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp21 := lang.Apply(tmp20, []any{"Can't convert multi-char string to char"})
							tmp13 = tmp21
						}
						tmp10 = tmp13
					} else {
						var tmp22 any
						tmp23 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
						tmp24 := lang.Apply(v5, []any{tmp23, v6})
						if lang.IsTruthy(tmp24) {
							tmp25 := checkDerefVar(var_clojure_DOT_core_char)
							tmp26 := lang.Apply(tmp25, []any{v2})
							tmp22 = tmp26
						} else {
							tmp27 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp28 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
							tmp29 := lang.Apply(tmp28, []any{v2})
							tmp30 := lang.Apply(tmp27, []any{"Can't convert ", tmp29, " to char"})
							tmp22 = tmp30
						}
						tmp10 = tmp22
					}
					tmp7 = tmp10
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_char = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-float
	{
		tmp0 := sym_to_DASH_float.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(655), kw_column, int(7), kw_end_DASH_line, int(655), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_double)
			tmp4 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_float = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_float.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-int
	{
		tmp0 := sym_to_DASH_int.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(657), kw_column, int(7), kw_end_DASH_line, int(657), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_long)
			tmp4 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_int = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-keyw
	{
		tmp0 := sym_to_DASH_keyw.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(659), kw_column, int(7), kw_end_DASH_line, int(659), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_keyword)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_keyw = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_keyw.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-list
	{
		tmp0 := sym_to_DASH_list.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(661), kw_column, int(7), kw_end_DASH_line, int(661), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__119"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__120"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_reduce_DASH_kv)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v12 := args[0]
						_ = v12
						v13 := args[1]
						_ = v13
						v14 := args[2]
						_ = v14
						tmp15 := checkDerefVar(var_clojure_DOT_core_conj)
						tmp16 := lang.Apply(tmp15, []any{v12, v14, v13})
						return tmp16
					})
					tmp12 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(663), kw_column, int(21), kw_end_DASH_line, int(663), kw_end_DASH_column, int(49))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp10, []any{tmp13, lang.NewList(), v2})
					tmp7 = tmp14
				} else {
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
					tmp17 := lang.Apply(v5, []any{tmp16, v6})
					if lang.IsTruthy(tmp17) {
						var tmp18 any
						tmp19 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
						tmp20 := lang.Apply(tmp19, []any{v2})
						if lang.IsTruthy(tmp20) {
							tmp18 = lang.NewList()
						} else {
							tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp22 := lang.Apply(tmp21, []any{v2})
							tmp18 = tmp22
						}
						tmp15 = tmp18
					} else {
						var tmp23 any
						tmp24 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp25 := lang.Apply(v5, []any{tmp24, v6})
						if lang.IsTruthy(tmp25) {
							var tmp26 any
							tmp27 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
							tmp28 := lang.Apply(tmp27, []any{v2})
							if lang.IsTruthy(tmp28) {
								tmp26 = lang.NewList()
							} else {
								tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp30 := lang.Apply(tmp29, []any{v2})
								tmp26 = tmp30
							}
							tmp23 = tmp26
						} else {
							var tmp31 any
							tmp32 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
							tmp33 := lang.Apply(v5, []any{tmp32, v6})
							if lang.IsTruthy(tmp33) {
								tmp31 = lang.NewList()
							} else {
								tmp34 := checkDerefVar(var_yamlscript_DOT_util_die)
								tmp35 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
								tmp36 := lang.Apply(tmp35, []any{v2})
								tmp37 := lang.Apply(tmp34, []any{"Can't convert ", tmp36, " to list"})
								tmp31 = tmp37
							}
							tmp23 = tmp31
						}
						tmp15 = tmp23
					}
					tmp7 = tmp15
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_list = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_list.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-map
	{
		tmp0 := sym_to_DASH_map.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(669), kw_column, int(7), kw_end_DASH_line, int(669), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__121"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__122"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp7 = v2
				} else {
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
					tmp12 := lang.Apply(v5, []any{tmp11, v6})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_clojure_DOT_core_zipmap)
						tmp14 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp15 := lang.Apply(tmp14, []any{v2})
						tmp16 := checkDerefVar(var_clojure_DOT_core_repeat)
						tmp17 := lang.Apply(tmp16, []any{nil})
						tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
						tmp10 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
						tmp21 := lang.Apply(v5, []any{tmp20, v6})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(var_clojure_DOT_core_apply)
							tmp23 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
							tmp24 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp25 := lang.Apply(tmp24, []any{v2})
							tmp26 := lang.Apply(tmp22, []any{tmp23, tmp25})
							tmp19 = tmp26
						} else {
							var tmp27 any
							tmp28 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
							tmp29 := lang.Apply(v5, []any{tmp28, v6})
							if lang.IsTruthy(tmp29) {
								tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
								tmp31 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
								tmp32 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp33 := lang.Apply(tmp32, []any{v2})
								tmp34 := lang.Apply(tmp30, []any{tmp31, tmp33})
								tmp27 = tmp34
							} else {
								var tmp35 any
								tmp36 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
								tmp37 := lang.Apply(v5, []any{tmp36, v6})
								if lang.IsTruthy(tmp37) {
									tmp38 := lang.NewMap()
									tmp39 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(675), kw_column, int(10), kw_end_DASH_line, int(675), kw_end_DASH_column, int(11))
									tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp35 = tmp40
								} else {
									tmp41 := checkDerefVar(var_yamlscript_DOT_util_die)
									tmp42 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
									tmp43 := lang.Apply(tmp42, []any{v2})
									tmp44 := lang.Apply(tmp41, []any{"Can't convert ", tmp43, " to map"})
									tmp35 = tmp44
								}
								tmp27 = tmp35
							}
							tmp19 = tmp27
						}
						tmp10 = tmp19
					}
					tmp7 = tmp10
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-num
	{
		tmp0 := sym_to_DASH_num.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(678), kw_column, int(7), kw_end_DASH_line, int(678), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_default)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_ys_DOT_std_to_DASH_num)
				tmp4 := lang.Apply(tmp3, []any{v2, nil})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "pred__123"
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v6, []any{v7})
						return tmp8
					})
					var v6 any = tmp5
					_ = v6
					// let binding "expr__124"
					var v7 any = v2
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
					tmp10 := lang.Apply(v6, []any{tmp9, v7})
					if lang.IsTruthy(tmp10) {
						tmp8 = v2
					} else {
						var tmp11 any
						tmp12 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp13 := lang.Apply(v6, []any{tmp12, v7})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							tmp15 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
							tmp16 := lang.Apply(tmp15, []any{regexp4.MustCompile("^[+-]?[0-9]+\\.?[0-9]*([eE][+-]?[0-9]+)?$"), v2})
							if lang.IsTruthy(tmp16) {
								tmp17 := checkDerefVar(var_clojure_DOT_core_read_DASH_string)
								tmp18 := lang.Apply(tmp17, []any{v2})
								tmp14 = tmp18
							} else {
							}
							tmp11 = tmp14
						} else {
							var tmp19 any
							tmp20 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
							tmp21 := lang.Apply(v6, []any{tmp20, v7})
							if lang.IsTruthy(tmp21) {
								tmp22 := checkDerefVar(var_yamlscript_DOT_util_die)
								tmp23 := lang.Apply(tmp22, []any{"Can't convert a nil value to a number"})
								tmp19 = tmp23
							} else {
								var tmp24 any
								tmp25 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
								tmp26 := lang.Apply(v6, []any{tmp25, v7})
								if lang.IsTruthy(tmp26) {
									tmp27 := checkDerefVar(var_clojure_DOT_core_count)
									tmp28 := lang.Apply(tmp27, []any{v2})
									tmp24 = tmp28
								} else {
									var tmp29 any
									tmp30 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
									tmp31 := lang.Apply(v6, []any{tmp30, v7})
									if lang.IsTruthy(tmp31) {
										tmp32 := checkDerefVar(var_clojure_DOT_core_int)
										tmp33 := lang.Apply(tmp32, []any{v2})
										tmp29 = tmp33
									} else {
										var tmp34 any
										tmp35 := checkDerefVar(var_clojure_DOT_core_boolean_QMARK_)
										tmp36 := lang.Apply(v6, []any{tmp35, v7})
										if lang.IsTruthy(tmp36) {
											var tmp37 any
											if lang.IsTruthy(v2) {
												tmp37 = int64(1)
											} else {
												tmp37 = int64(0)
											}
											tmp34 = tmp37
										} else {
											tmp38 := checkDerefVar(var_yamlscript_DOT_util_die)
											tmp39 := checkDerefVar(var_clojure_DOT_core_str)
											tmp40 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
											tmp41 := lang.Apply(tmp40, []any{v2})
											tmp42 := lang.Apply(tmp39, []any{"Can't convert a value of type '", tmp41, "' to a number"})
											tmp43 := lang.Apply(tmp38, []any{tmp42})
											tmp34 = tmp43
										}
										tmp29 = tmp34
									}
									tmp24 = tmp29
								}
								tmp19 = tmp24
							}
							tmp11 = tmp19
						}
						tmp8 = tmp11
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_num = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_num.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-omap
	{
		tmp0 := sym_to_DASH_omap.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(692), kw_column, int(7), kw_end_DASH_line, int(692), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__125"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__126"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp11 := checkDerefVar(var_ys_DOT_std_omap)
					tmp12 := lang.Apply(tmp10, []any{tmp11, v2})
					tmp7 = tmp12
				} else {
					var tmp13 any
					tmp14 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
					tmp15 := lang.Apply(v5, []any{tmp14, v6})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp17 := checkDerefVar(var_ys_DOT_std_omap)
						tmp18 := checkDerefVar(var_clojure_DOT_core_into)
						tmp19 := lang.NewVector()
						tmp20 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(695), kw_column, int(28), kw_end_DASH_line, int(695), kw_end_DASH_column, int(29))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp22 := checkDerefVar(var_clojure_DOT_core_cat)
						tmp23 := lang.Apply(tmp18, []any{tmp21, tmp22, v2})
						tmp24 := lang.Apply(tmp16, []any{tmp17, tmp23})
						tmp13 = tmp24
					} else {
						var tmp25 any
						tmp26 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
						tmp27 := lang.Apply(v5, []any{tmp26, v6})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(var_ys_DOT_std_omap)
							tmp29 := lang.Apply(tmp28, nil)
							tmp25 = tmp29
						} else {
							tmp30 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp31 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
							tmp32 := lang.Apply(tmp31, []any{v2})
							tmp33 := lang.Apply(tmp30, []any{"Can't convert ", tmp32, " to omap"})
							tmp25 = tmp33
						}
						tmp13 = tmp25
					}
					tmp7 = tmp13
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_omap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_omap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-set
	{
		tmp0 := sym_to_DASH_set.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(699), kw_column, int(7), kw_end_DASH_line, int(699), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__127"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__128"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_set)
					tmp11 := checkDerefVar(var_clojure_DOT_core_keys)
					tmp12 := lang.Apply(tmp11, []any{v2})
					tmp13 := lang.Apply(tmp10, []any{tmp12})
					tmp7 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(var_clojure_DOT_core_seqable_QMARK_)
					tmp16 := lang.Apply(v5, []any{tmp15, v6})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(var_clojure_DOT_core_set)
						tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp19 := lang.Apply(tmp18, []any{v2})
						tmp20 := lang.Apply(tmp17, []any{tmp19})
						tmp14 = tmp20
					} else {
						var tmp21 any
						tmp22 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
						tmp23 := lang.Apply(v5, []any{tmp22, v6})
						if lang.IsTruthy(tmp23) {
							tmp24 := checkDerefVar(var_clojure_DOT_core_set)
							tmp25 := lang.Apply(tmp24, []any{nil})
							tmp21 = tmp25
						} else {
							tmp26 := checkDerefVar(var_yamlscript_DOT_util_die)
							tmp27 := checkDerefVar(var_ys_DOT_std_to_DASH_type)
							tmp28 := lang.Apply(tmp27, []any{v2})
							tmp29 := lang.Apply(tmp26, []any{"Can't convert ", tmp28, " to set"})
							tmp21 = tmp29
						}
						tmp14 = tmp21
					}
					tmp7 = tmp14
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-str
	{
		tmp0 := sym_to_DASH_str.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(710), kw_column, int(7), kw_end_DASH_line, int(710), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__129"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__130"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp7 = v2
				} else {
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
					tmp12 := lang.Apply(v5, []any{tmp11, v6})
					if lang.IsTruthy(tmp12) {
						tmp10 = "nil"
					} else {
						tmp13 := checkDerefVar(var_clojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{v2})
						tmp10 = tmp14
					}
					tmp7 = tmp10
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-type
	{
		tmp0 := sym_to_DASH_type.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(716), kw_column, int(7), kw_end_DASH_line, int(716), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__131"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__132"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_yamlscript_DOT_util_atom_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp7 = "atom"
				} else {
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core_boolean_QMARK_)
					tmp12 := lang.Apply(v5, []any{tmp11, v6})
					if lang.IsTruthy(tmp12) {
						tmp10 = "bool"
					} else {
						var tmp13 any
						tmp14 := checkDerefVar(var_clojure_DOT_core_char_QMARK_)
						tmp15 := lang.Apply(v5, []any{tmp14, v6})
						if lang.IsTruthy(tmp15) {
							tmp13 = "char"
						} else {
							var tmp16 any
							tmp17 := checkDerefVar(var_clojure_DOT_core_class_QMARK_)
							tmp18 := lang.Apply(v5, []any{tmp17, v6})
							if lang.IsTruthy(tmp18) {
								tmp16 = "class"
							} else {
								var tmp19 any
								tmp20 := checkDerefVar(var_clojure_DOT_core_float_QMARK_)
								tmp21 := lang.Apply(v5, []any{tmp20, v6})
								if lang.IsTruthy(tmp21) {
									tmp19 = "float"
								} else {
									var tmp22 any
									tmp23 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
									tmp24 := lang.Apply(v5, []any{tmp23, v6})
									if lang.IsTruthy(tmp24) {
										tmp22 = "fun"
									} else {
										var tmp25 any
										tmp26 := checkDerefVar(var_clojure_DOT_core_int_QMARK_)
										tmp27 := lang.Apply(v5, []any{tmp26, v6})
										if lang.IsTruthy(tmp27) {
											tmp25 = "int"
										} else {
											var tmp28 any
											tmp29 := checkDerefVar(var_clojure_DOT_core_keyword_QMARK_)
											tmp30 := lang.Apply(v5, []any{tmp29, v6})
											if lang.IsTruthy(tmp30) {
												tmp28 = "keyw"
											} else {
												var tmp31 any
												tmp32 := checkDerefVar(var_clojure_DOT_core_list_QMARK_)
												tmp33 := lang.Apply(v5, []any{tmp32, v6})
												if lang.IsTruthy(tmp33) {
													tmp31 = "list"
												} else {
													var tmp34 any
													tmp35 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
													tmp36 := lang.Apply(v5, []any{tmp35, v6})
													if lang.IsTruthy(tmp36) {
														tmp34 = "map"
													} else {
														var tmp37 any
														tmp38 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
														tmp39 := lang.Apply(v5, []any{tmp38, v6})
														if lang.IsTruthy(tmp39) {
															tmp37 = "nil"
														} else {
															var tmp40 any
															tmp41 := checkDerefVar(var_clojure_DOT_core_number_QMARK_)
															tmp42 := lang.Apply(v5, []any{tmp41, v6})
															if lang.IsTruthy(tmp42) {
																tmp40 = "num"
															} else {
																var tmp43 any
																tmp44 := checkDerefVar(var_ys_DOT_std_regex_QMARK_)
																tmp45 := lang.Apply(v5, []any{tmp44, v6})
																if lang.IsTruthy(tmp45) {
																	tmp43 = "rgx"
																} else {
																	var tmp46 any
																	tmp47 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
																	tmp48 := lang.Apply(v5, []any{tmp47, v6})
																	if lang.IsTruthy(tmp48) {
																		tmp46 = "seq"
																	} else {
																		var tmp49 any
																		tmp50 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
																		tmp51 := lang.Apply(v5, []any{tmp50, v6})
																		if lang.IsTruthy(tmp51) {
																			tmp49 = "set"
																		} else {
																			var tmp52 any
																			tmp53 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
																			tmp54 := lang.Apply(v5, []any{tmp53, v6})
																			if lang.IsTruthy(tmp54) {
																				tmp52 = "str"
																			} else {
																				var tmp55 any
																				tmp56 := checkDerefVar(var_clojure_DOT_core_symbol_QMARK_)
																				tmp57 := lang.Apply(v5, []any{tmp56, v6})
																				if lang.IsTruthy(tmp57) {
																					tmp55 = "sym"
																				} else {
																					var tmp58 any
																					tmp59 := checkDerefVar(var_clojure_DOT_core_var_QMARK_)
																					tmp60 := lang.Apply(v5, []any{tmp59, v6})
																					if lang.IsTruthy(tmp60) {
																						tmp58 = "var"
																					} else {
																						var tmp61 any
																						tmp62 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
																						tmp63 := lang.Apply(v5, []any{tmp62, v6})
																						if lang.IsTruthy(tmp63) {
																							tmp61 = "vec"
																						} else {
																							tmp64 := checkDerefVar(var_yamlscript_DOT_util_die)
																							tmp65 := checkDerefVar(var_clojure_DOT_core_type)
																							tmp66 := lang.Apply(tmp65, []any{v2})
																							tmp67 := lang.Apply(tmp64, []any{"Can't determine type of '", tmp66, "' value"})
																							tmp61 = tmp67
																						}
																						tmp58 = tmp61
																					}
																					tmp55 = tmp58
																				}
																				tmp52 = tmp55
																			}
																			tmp49 = tmp52
																		}
																		tmp46 = tmp49
																	}
																	tmp43 = tmp46
																}
																tmp40 = tmp43
															}
															tmp37 = tmp40
														}
														tmp34 = tmp37
													}
													tmp31 = tmp34
												}
												tmp28 = tmp31
											}
											tmp25 = tmp28
										}
										tmp22 = tmp25
									}
									tmp19 = tmp22
								}
								tmp16 = tmp19
							}
							tmp13 = tmp16
						}
						tmp10 = tmp13
					}
					tmp7 = tmp10
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-vec
	{
		tmp0 := sym_to_DASH_vec.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(746), kw_column, int(7), kw_end_DASH_line, int(746), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__133"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__134"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_reduce_DASH_kv)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v12 := args[0]
						_ = v12
						v13 := args[1]
						_ = v13
						v14 := args[2]
						_ = v14
						tmp15 := checkDerefVar(var_clojure_DOT_core_conj)
						tmp16 := lang.Apply(tmp15, []any{v12, v13, v14})
						return tmp16
					})
					tmp12 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(748), kw_column, int(21), kw_end_DASH_line, int(748), kw_end_DASH_column, int(49))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.NewVector()
					tmp15 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(748), kw_column, int(51), kw_end_DASH_line, int(748), kw_end_DASH_column, int(52))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.Apply(tmp10, []any{tmp13, tmp16, v2})
					tmp7 = tmp17
				} else {
					var tmp18 any
					tmp19 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
					tmp20 := lang.Apply(v5, []any{tmp19, v6})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(var_clojure_DOT_core_vec)
						tmp22 := lang.Apply(tmp21, []any{v2})
						tmp18 = tmp22
					} else {
						var tmp23 any
						tmp24 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp25 := lang.Apply(v5, []any{tmp24, v6})
						if lang.IsTruthy(tmp25) {
							tmp26 := checkDerefVar(var_clojure_DOT_core_vec)
							tmp27 := lang.Apply(tmp26, []any{v2})
							tmp23 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
							tmp30 := lang.Apply(v5, []any{tmp29, v6})
							if lang.IsTruthy(tmp30) {
								tmp31 := lang.NewVector()
								tmp32 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(751), kw_column, int(10), kw_end_DASH_line, int(751), kw_end_DASH_column, int(11))
								tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp28 = tmp33
							} else {
								tmp34 := checkDerefVar(var_yamlscript_DOT_util_die)
								var tmp35 any
								{ // let
									// let binding "or__0__auto__"
									tmp36 := checkDerefVar(var_clojure_DOT_core_type)
									tmp37 := lang.Apply(tmp36, []any{v2})
									var v38 any = tmp37
									_ = v38
									var tmp39 any
									if lang.IsTruthy(v38) {
										tmp39 = v38
									} else {
										tmp39 = "nil"
									}
									tmp35 = tmp39
								} // end let
								tmp36 := lang.Apply(tmp34, []any{"Can't convert ", tmp35, " to vector"})
								tmp28 = tmp36
							}
							tmp23 = tmp28
						}
						tmp18 = tmp23
					}
					tmp7 = tmp18
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_to_DASH_vec = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_to_DASH_vec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trim
	{
		tmp0 := sym_trim.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(165), kw_column, int(18), kw_end_DASH_line, int(165), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_trim)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(165), kw_column, int(23), kw_end_DASH_line, int(165), kw_end_DASH_column, int(43))).(lang.FnFunc)
		var_ys_DOT_std_trim = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_trim.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// triml
	{
		tmp0 := sym_triml.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(167), kw_column, int(18), kw_end_DASH_line, int(167), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_triml)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(167), kw_column, int(24), kw_end_DASH_line, int(167), kw_end_DASH_column, int(45))).(lang.FnFunc)
		var_ys_DOT_std_triml = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_triml.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trimr
	{
		tmp0 := sym_trimr.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(169), kw_column, int(18), kw_end_DASH_line, int(169), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_trimr)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(169), kw_column, int(24), kw_end_DASH_line, int(169), kw_end_DASH_column, int(45))).(lang.FnFunc)
		var_ys_DOT_std_trimr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_trimr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uc
	{
		tmp0 := sym_uc.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(172), kw_column, int(18), kw_end_DASH_line, int(172), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_upper_DASH_case)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(172), kw_column, int(21), kw_end_DASH_line, int(172), kw_end_DASH_column, int(47))).(lang.FnFunc)
		var_ys_DOT_std_uc = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_uc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uc1
	{
		tmp0 := sym_uc1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(174), kw_column, int(18), kw_end_DASH_line, int(174), kw_end_DASH_column, int(20), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_capitalize)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(174), kw_column, int(22), kw_end_DASH_line, int(174), kw_end_DASH_column, int(48))).(lang.FnFunc)
		var_ys_DOT_std_uc1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_uc1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// value
	{
		tmp0 := sym_value.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(462), kw_column, int(11), kw_end_DASH_line, int(462), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp7 := checkDerefVar(var_clojure_DOT_core_list)
			tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_let})
			tmp9 := checkDerefVar(var_clojure_DOT_core_list)
			tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp11 := checkDerefVar(var_clojure_DOT_core_vector)
			tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp14 := checkDerefVar(var_clojure_DOT_core_list)
			tmp15 := lang.Apply(tmp14, []any{sym_var__0__auto__})
			tmp16 := checkDerefVar(var_clojure_DOT_core_list)
			tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp19 := checkDerefVar(var_clojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{sym_clojure_DOT_core_SLASH_condp})
			tmp21 := checkDerefVar(var_clojure_DOT_core_list)
			tmp22 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp23 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp24 := checkDerefVar(var_clojure_DOT_core_list)
			tmp25 := lang.Apply(tmp24, []any{sym_fn_STAR_})
			tmp26 := checkDerefVar(var_clojure_DOT_core_list)
			tmp27 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp28 := checkDerefVar(var_clojure_DOT_core_vector)
			tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp30 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp31 := checkDerefVar(var_clojure_DOT_core_list)
			tmp32 := lang.Apply(tmp31, []any{sym_p1__18__1__auto__})
			tmp33 := checkDerefVar(var_clojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{sym_p2__19__2__auto__})
			tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
			tmp36 := lang.Apply(tmp29, []any{tmp35})
			tmp37 := lang.Apply(tmp27, []any{tmp28, tmp36})
			tmp38 := lang.Apply(tmp26, []any{tmp37})
			tmp39 := checkDerefVar(var_clojure_DOT_core_list)
			tmp40 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp41 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp42 := checkDerefVar(var_clojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{sym_p1__18__1__auto__})
			tmp44 := checkDerefVar(var_clojure_DOT_core_list)
			tmp45 := lang.Apply(tmp44, []any{sym_p2__19__2__auto__})
			tmp46 := lang.Apply(tmp41, []any{tmp43, tmp45})
			tmp47 := lang.Apply(tmp40, []any{tmp46})
			tmp48 := lang.Apply(tmp39, []any{tmp47})
			tmp49 := lang.Apply(tmp23, []any{tmp25, tmp38, tmp48})
			tmp50 := lang.Apply(tmp22, []any{tmp49})
			tmp51 := lang.Apply(tmp21, []any{tmp50})
			tmp52 := checkDerefVar(var_clojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{v4})
			tmp54 := checkDerefVar(var_clojure_DOT_core_list)
			tmp55 := lang.Apply(tmp54, []any{sym_clojure_DOT_core_SLASH_string_QMARK_})
			tmp56 := checkDerefVar(var_clojure_DOT_core_list)
			tmp57 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp58 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp59 := checkDerefVar(var_clojure_DOT_core_list)
			tmp60 := lang.Apply(tmp59, []any{sym_clojure_DOT_core_SLASH_ns_DASH_resolve})
			tmp61 := checkDerefVar(var_clojure_DOT_core_list)
			tmp62 := lang.Apply(tmp61, []any{sym_clojure_DOT_core_SLASH__STAR_ns_STAR_})
			tmp63 := checkDerefVar(var_clojure_DOT_core_list)
			tmp64 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp65 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp66 := checkDerefVar(var_clojure_DOT_core_list)
			tmp67 := lang.Apply(tmp66, []any{sym_clojure_DOT_core_SLASH_symbol})
			tmp68 := checkDerefVar(var_clojure_DOT_core_list)
			tmp69 := lang.Apply(tmp68, []any{v4})
			tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
			tmp71 := lang.Apply(tmp64, []any{tmp70})
			tmp72 := lang.Apply(tmp63, []any{tmp71})
			tmp73 := lang.Apply(tmp58, []any{tmp60, tmp62, tmp72})
			tmp74 := lang.Apply(tmp57, []any{tmp73})
			tmp75 := lang.Apply(tmp56, []any{tmp74})
			tmp76 := checkDerefVar(var_clojure_DOT_core_list)
			tmp77 := lang.Apply(tmp76, []any{sym_clojure_DOT_core_SLASH_symbol_QMARK_})
			tmp78 := checkDerefVar(var_clojure_DOT_core_list)
			tmp79 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp80 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp81 := checkDerefVar(var_clojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{sym_clojure_DOT_core_SLASH_ns_DASH_resolve})
			tmp83 := checkDerefVar(var_clojure_DOT_core_list)
			tmp84 := lang.Apply(tmp83, []any{sym_clojure_DOT_core_SLASH__STAR_ns_STAR_})
			tmp85 := checkDerefVar(var_clojure_DOT_core_list)
			tmp86 := lang.Apply(tmp85, []any{v4})
			tmp87 := lang.Apply(tmp80, []any{tmp82, tmp84, tmp86})
			tmp88 := lang.Apply(tmp79, []any{tmp87})
			tmp89 := lang.Apply(tmp78, []any{tmp88})
			tmp90 := checkDerefVar(var_clojure_DOT_core_list)
			tmp91 := lang.Apply(tmp90, []any{sym_clojure_DOT_core_SLASH_var_QMARK_})
			tmp92 := checkDerefVar(var_clojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{v4})
			tmp94 := checkDerefVar(var_clojure_DOT_core_list)
			tmp95 := lang.Apply(tmp94, []any{nil})
			tmp96 := lang.Apply(tmp18, []any{tmp20, tmp51, tmp53, tmp55, tmp75, tmp77, tmp89, tmp91, tmp93, tmp95})
			tmp97 := lang.Apply(tmp17, []any{tmp96})
			tmp98 := lang.Apply(tmp16, []any{tmp97})
			tmp99 := lang.Apply(tmp13, []any{tmp15, tmp98})
			tmp100 := lang.Apply(tmp12, []any{tmp99})
			tmp101 := lang.Apply(tmp10, []any{tmp11, tmp100})
			tmp102 := lang.Apply(tmp9, []any{tmp101})
			tmp103 := checkDerefVar(var_clojure_DOT_core_list)
			tmp104 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp105 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp106 := checkDerefVar(var_clojure_DOT_core_list)
			tmp107 := lang.Apply(tmp106, []any{sym_clojure_DOT_core_SLASH_when})
			tmp108 := checkDerefVar(var_clojure_DOT_core_list)
			tmp109 := lang.Apply(tmp108, []any{sym_var__0__auto__})
			tmp110 := checkDerefVar(var_clojure_DOT_core_list)
			tmp111 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp112 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp113 := checkDerefVar(var_clojure_DOT_core_list)
			tmp114 := lang.Apply(tmp113, []any{sym_clojure_DOT_core_SLASH_var_DASH_get})
			tmp115 := checkDerefVar(var_clojure_DOT_core_list)
			tmp116 := lang.Apply(tmp115, []any{sym_var__0__auto__})
			tmp117 := lang.Apply(tmp112, []any{tmp114, tmp116})
			tmp118 := lang.Apply(tmp111, []any{tmp117})
			tmp119 := lang.Apply(tmp110, []any{tmp118})
			tmp120 := lang.Apply(tmp105, []any{tmp107, tmp109, tmp119})
			tmp121 := lang.Apply(tmp104, []any{tmp120})
			tmp122 := lang.Apply(tmp103, []any{tmp121})
			tmp123 := lang.Apply(tmp6, []any{tmp8, tmp102, tmp122})
			tmp124 := lang.Apply(tmp5, []any{tmp123})
			return tmp124
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_value = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_value.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when+
	{
		tmp0 := sym_when_PLUS_.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(502), kw_column, int(11), kw_end_DASH_line, int(502), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_list)
				tmp7 := lang.NewVector(sym__, v4)
				tmp8 := lang.NewMap(kw_file, "ys/std.glj", kw_line, int(503), kw_column, int(19), kw_end_DASH_line, int(503), kw_end_DASH_column, int(27))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{sym_do, v5})
				tmp12 := lang.Apply(tmp6, []any{sym_when_DASH_let, tmp9, tmp11})
				return tmp12
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_when_PLUS_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_when_PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// words
	{
		tmp0 := sym_words.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(176), kw_column, int(7), kw_end_DASH_line, int(176), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_S)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_split)
			tmp4 := lang.Apply(tmp3, []any{v2, regexp4.MustCompile("\\s+")})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_std_words = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_words.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// write
	{
		tmp0 := sym_write.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(548), kw_column, int(18), kw_end_DASH_line, int(548), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_std))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_core_spit)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/std.glj", kw_line, int(548), kw_column, int(24), kw_end_DASH_line, int(548), kw_end_DASH_column, int(54))).(lang.FnFunc)
		var_ys_DOT_std_write = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_std_write.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}
