'\" t
.nh
.TH gloat - Glojure AOT Tool
Gloat compiles Clojure or
YAMLScript to Go code or native
binaries

.PP
.RS

.PP
Cross-compiles to 20+ platforms including Wasm.

.RE

.SH Synopsis
Before using the \fBTry Gloat - Live Demo\fP badge above, read the
Gloat Live Demo section below.

.EX
# Compile to native binary (default)
gloat app.clj                   # Creates ./app binary
gloat app.clj -o myapp          # Creates ./myapp binary

# Output intermediate formats
gloat app.ys -t clj             # Clojure to stdout
gloat app.ys -t glj             # Glojure to stdout
gloat app.ys -t go              # Go to stdout

# Create files with -t .ext shorthand
gloat app.ys -t .clj            # Creates app.clj
gloat app.ys -t .glj            # Creates app.glj
gloat app.ys -t .go             # Creates app.go

# Create a portable Go project directory
gloat app.ys -o build/          # Creates build/ directory

# Cross-compile
gloat app.ys -o app-linux --platform=linux/amd64
gloat app.ys -o app.exe --platform=windows/amd64

# Compile and run
gloat --run app.ys              # Compile and run (no binary kept)
gloat --run app.ys -- <args...> # Pass arguments to program

# WebAssembly targets
gloat app.ys -o app.wasm        # WASI target
gloat app.ys -o app.wasm -t js  # JavaScript target
.EE

.SH Description
Gloat compiles Clojure or YAMLScript source files to any of these forms:
.IP \(bu 2
Native binaries
.RS
.IP \(bu 2
Cross compile to 20+ OS/Arch environments
.RE
.IP \(bu 2
Web Assembly
.RS
.IP \(bu 2
Wasi P1 - Run on server
.IP \(bu 2
JS Wasm - Run in browser
.RE
.IP \(bu 2
Shared libraries (\fB\&.so\fR, \fB\&.dylib\fR, \fB\&.dll\fR)
.RS
.IP \(bu 2
With \fB\&.h\fR header files for FFI binding
.RE
.IP \(bu 2
Go source files
.IP \(bu 2
Standalone Go build directories
.IP \(bu 2
Standalone Babashka (Clojure) files

.EX
\&.ys  →  ys -c   →  .clj
                    ↓
\&.clj  ────────→  rewrite  →  .glj
                              ↓
\&.glj  ──────────────────→  glj compile  →  .go
                                            ↓
                                       go build  →  binary/wasm
.EE

.PP
The tool has \fBzero external dependencies\fP\&.
All required tools (bb, glj, go, ys) are installed the first time you run
\fBgloat\fR via the Makes build system.

.PP
All of these tools will be installed local to the gloat repository under
\fB/path/to/gloat/.cache/.local/\fR and you will be prompted about it first.

.SH Gloat Live Demo
The gloat repository comes with a lot of demo programs.
You can find them in the \fBdemo/clojure/\fR, and \fBdemo/yamlscript/\fR
directories.

.PP
A great way to view the demos is to start the Gloat Demo Webpage Server with:

.EX
$ make serve-demo
\&...some output...
Starting server on http://localhost:8080
Press Ctrl+C to stop
.EE

.PP
That serves a webpage that will let you try all of the examples interactively.

.PP
In the webpage you can choose an example and then click \fBCompile\fP, which
sends it back to the local server, turns it into a Wasm file that can run in
the browser.
It will also show you the Glojure and the Go code that was generated to create
the Wasm.
After a program compiles, you can run it with the \fBRun\fP button.

.SS Run the Demo Now!
At the top of this file, you may have noticed this badge:
GitHub users can click that and see the demo without cloning this repository.
It opens in a GitHub Codespaces session, which starts as an empty VScode editor
session.
If you \fBwait a couple minutes (literally)\fP the demo will start in an editor
pane.

.PP
.RS

.PP
\fBNotes:\fP
The demo page \fBliterally takes 1-2 minutes to start\fP\&.
Use Cmd/Ctrl + Shift + P -> View Creation Log to see full logs.
After the demo starts in the editor, you can pop it out to a separate browser
pane.

.RE

.SS Using \fBgloat --run\fR to run examples
Try these:

.EX
gloat --run demo/yamlscript/dragon-curve.ys
gloat -r demo/clojure/even-or-odd.clj -- 7 42 31337
.EE

.PP
To pass options to a program run with \fBgloat --run\fR, put the after a \fB--\fR arg.

.SH Installation
Clone this repository and source the appropriate rc file for your shell:

.EX
$ git clone https://github.com/gloathub/gloat

# For Bash or Zsh
$ source gloat/.rc

# For Fish
$ source gloat/.fishrc

$ gloat --help
==> Installing gloat dependencies (bb, glj, go, ys) locally into:

    /home/ingy/src/gloat/worktree/clojure-rewrite/.cache/.local/

Press Enter to continue (or Ctrl-C to cancel)...
.EE

.PP
The first time you run the \fBgloat\fR command, all its dependencies will be
installed under the \fB/path/to/gloat/.cache/.local/\fR directory.

.PP
Sourcing the rc file adds \fBgloat\fR to your PATH and automatically loads shell
completions for your shell.

.PP
To make \fBgloat\fR a permanent install, add this to your shell's rc file:

.EX
# For Bash: add to ~/.bashrc
# For Zsh: add to ~/.zshrc
source /absolute/path/to/gloat/.rc

# For Fish: add to ~/.config/fish/config.fish
source /absolute/path/to/gloat/.fishrc
.EE

.SH Output Formats
.TS
allbox;
l l l 
l l l .
\fBFormat\fP	\fBFlag\fP	\fBDescription\fP
\fBbin\fR	\fB-t bin\fR or no extension	Native executable (default)
\fBclj\fR	\fB-t clj\fR	Clojure source
\fBbb\fR	\fB-t bb\fR	Babashka self-contained script
\fBglj\fR	\fB-t glj\fR	Glojure source
\fBgo\fR	\fB-t go\fR	Go source
\fBdir\fR	\fB-o path/\fR	Portable Go project directory
\fBlib\fR	\fB\&.so\fR or \fB\&.dylib\fR extension	Shared library
\fBwasm\fR	\fB\&.wasm\fR extension	WebAssembly (WASI)
\fBjs\fR	\fB-t js\fR with \fB\&.wasm\fR	WebAssembly (JavaScript)
.TE

.PP
The output format is inferred from the \fB-o\fR extension, or can be explicitly
set with \fB-t\fR\&.

.SH Directory Output
When outputting to a directory (\fB-o build/\fR), gloat generates a self-contained
Go project that builds with zero pre-installed dependencies:

.EX
build/
├── Makefile           # Makes-based build (auto-installs Go)
├── go.mod             # Go module definition
├── main.go            # Entry point
└── pkg/app/core/      # Glojure runtime code
.EE

.PP
Anyone can build it with just \fBmake\fR - Go is automatically installed.

.SH Cross-Compilation
Use \fB--platform=OS/ARCH\fR to cross-compile for different platforms:

.EX
# Linux targets
gloat app.ys -o app-linux-amd64 --platform=linux/amd64
gloat app.ys -o app-linux-arm64 --platform=linux/arm64

# macOS targets
gloat app.ys -o app-darwin-amd64 --platform=darwin/amd64
gloat app.ys -o app-darwin-arm64 --platform=darwin/arm64

# Windows targets
gloat app.ys -o app.exe --platform=windows/amd64
gloat app.ys -o app-win-arm64.exe --platform=windows/arm64

# WebAssembly targets
gloat app.ys -o app.wasm --platform=wasip1/wasm    # WASI
gloat app.ys -o app.wasm --platform=js/wasm        # JavaScript
.EE

.PP
Common platform targets:

.TS
allbox;
l l 
l l .
\fBOS\fP	\fBArchitectures\fP
\fBlinux\fR	\fBamd64\fR, \fBarm64\fR, \fB386\fR, \fBarm\fR
\fBdarwin\fR	\fBamd64\fR, \fBarm64\fR
\fBwindows\fR	\fBamd64\fR, \fBarm64\fR, \fBarm\fR, \fB386\fR
\fBfreebsd\fR	\fBamd64\fR, \fBarm64\fR, \fB386\fR
\fBopenbsd\fR	\fBamd64\fR, \fBarm64\fR
\fBnetbsd\fR	\fBamd64\fR, \fBarm64\fR
\fBwasip1\fR	\fBwasm\fR
\fBjs\fR	\fBwasm\fR
.TE

.PP
Less common platform architectures:

.TS
allbox;
l l 
l l .
\fBOS\fP	\fBArchitectures\fP
\fBlinux\fR	\fBppc64le\fR, \fBs390x\fR, \fBriscv64\fR, \fBmips64le\fR
\fBdragonfly\fR	\fBamd64\fR
.TE

.SH Options
.EX
-t, --to=FORMAT         Output format (inferred from -o; see --formats)
-o, --out=FILE          Output file or directory

    --platform=OS/ARCH  Cross-compile (e.g., linux/amd64; see --platforms)
-X, --ext=EXT           Enable a processing extension (see --extensions)

    --ns=NAMESPACE      Override namespace
    --module=NAME       Go module name (e.g., github.com/user/project)

    --formats           List available output formats
    --extensions        List available processing extensions
    --platforms         List available cross-compilation platforms

-r, --run               Compile and run (pass program args after --)
-f, --force             Overwrite existing output files
-v, --verbose           Print timing for each compilation step
-q, --quiet             Suppress progress messages

-h, --help              Show help
    --version           Show version
    --complete=SHELL    Generate shell completion script (bash, zsh, fish)
.EE

.SH Shell Completion
Gloat provides tab completion for all shells.
Completions are automatically loaded when you source \fB\&.rc\fR (bash/zsh) or
\fB\&.fishrc\fR (fish).

.PP
To manually generate or reload completions:

.EX
# Bash
eval "$(gloat --complete=bash)"

# Zsh
eval "$(gloat --complete=zsh)"

# Fish
gloat --complete=fish | source
.EE

.PP
Completions provide:
- All command-line options (short and long forms)
- Available values for \fB--to\fR (output formats)
- Available values for \fB--platform\fR (cross-compilation targets)
- Available values for \fB--ext\fR (processing extensions)
- File completion for source files (\fB\&.ys\fR, \fB\&.clj\fR, \fB\&.glj\fR)
- File completion for \fB--out\fR output paths

.SH The Make Shell
The Makefile is set up so that you don't need to install any dependencies.
They get installed the first time they are needed by a rule invoked by a \fBmake\fR
command that you run.

.PP
However, these tools are only accessible inside the Makefile; to the rules that
get run when you use \fBmake\fR commands.
In other words, they are NOT available for you to run directly in your shell.

.PP
Sometimes you want to run these commands like \fBgo\fR, \fBys\fR and \fBbb\fR directly in
your shell.
In that case, just run: \fBmake shell\fR\&.

.PP
This will put you in a subshell with all of those commands available.
Your \fBPS1\fR shell prompt will be changed so that it will be easy to know you are
in such a subshell.

.PP
To leave this environment and get back to the shell that you started in, just
press Ctrl-D or run the \fBexit\fR command.

.SH Copyright and License
Copyright 2026 - Ingy dot Net

.PP
MIT License - See License file.
