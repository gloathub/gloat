// Code generated by glojure codegen. DO NOT EDIT.

package fs

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	os5 "os"
	exec7 "os/exec"
	filepath4 "path/filepath"
	reflect "reflect"
	time6 "time"
)

func init() {
	runtime.RegisterNSLoader("ys/fs", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "ys.fs"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__DASH_ := lang.NewSymbol("-")
	sym__LT_ := lang.NewSymbol("<")
	sym__EQ_ := lang.NewSymbol("=")
	sym__GT_ := lang.NewSymbol(">")
	sym_abs := lang.NewSymbol("abs")
	sym_abs_QMARK_ := lang.NewSymbol("abs?")
	sym_atom := lang.NewSymbol("atom")
	sym_basename := lang.NewSymbol("basename")
	sym_bit_DASH_and := lang.NewSymbol("bit-and")
	sym_blank_QMARK_ := lang.NewSymbol("blank?")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_rest := lang.NewSymbol("chunk-rest")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_string := lang.NewSymbol("clojure.string")
	sym_conj := lang.NewSymbol("conj")
	sym_count := lang.NewSymbol("count")
	sym_cp := lang.NewSymbol("cp")
	sym_cp_DASH_r := lang.NewSymbol("cp-r")
	sym_ctime := lang.NewSymbol("ctime")
	sym_cwd := lang.NewSymbol("cwd")
	sym_d := lang.NewSymbol("d")
	sym_deref := lang.NewSymbol("deref")
	sym_dir_QMARK_ := lang.NewSymbol("dir?")
	sym_dirname := lang.NewSymbol("dirname")
	sym_dst := lang.NewSymbol("dst")
	sym_e := lang.NewSymbol("e")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_exec_QMARK_ := lang.NewSymbol("exec?")
	sym_exists_QMARK_ := lang.NewSymbol("exists?")
	sym_f := lang.NewSymbol("f")
	sym_file_QMARK_ := lang.NewSymbol("file?")
	sym_filename := lang.NewSymbol("filename")
	sym_find := lang.NewSymbol("find")
	sym_first := lang.NewSymbol("first")
	sym_get_DASH_file_DASH_info := lang.NewSymbol("get-file-info")
	sym_get_DASH_link_DASH_info := lang.NewSymbol("get-link-info")
	sym_glob := lang.NewSymbol("glob")
	sym_inc := lang.NewSymbol("inc")
	sym_includes_QMARK_ := lang.NewSymbol("includes?")
	sym_int := lang.NewSymbol("int")
	sym_l := lang.NewSymbol("l")
	sym_link_QMARK_ := lang.NewSymbol("link?")
	sym_ls := lang.NewSymbol("ls")
	sym_map := lang.NewSymbol("map")
	sym_mkdir := lang.NewSymbol("mkdir")
	sym_mkdir_DASH_p := lang.NewSymbol("mkdir-p")
	sym_mtime := lang.NewSymbol("mtime")
	sym_multi := lang.NewSymbol("multi")
	sym_mv := lang.NewSymbol("mv")
	sym_name := lang.NewSymbol("name")
	sym_next := lang.NewSymbol("next")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_not := lang.NewSymbol("not")
	sym_nth := lang.NewSymbol("nth")
	sym_p := lang.NewSymbol("p")
	sym_path := lang.NewSymbol("path")
	sym_pattern := lang.NewSymbol("pattern")
	sym_patterns := lang.NewSymbol("patterns")
	sym_r := lang.NewSymbol("r")
	sym_read_QMARK_ := lang.NewSymbol("read?")
	sym_readlink := lang.NewSymbol("readlink")
	sym_rel := lang.NewSymbol("rel")
	sym_rel_QMARK_ := lang.NewSymbol("rel?")
	sym_rm := lang.NewSymbol("rm")
	sym_rm_DASH_f := lang.NewSymbol("rm-f")
	sym_rm_DASH_r := lang.NewSymbol("rm-r")
	sym_rmdir := lang.NewSymbol("rmdir")
	sym_s := lang.NewSymbol("s")
	sym_seq := lang.NewSymbol("seq")
	sym_size_QMARK_ := lang.NewSymbol("size?")
	sym_src := lang.NewSymbol("src")
	sym_str := lang.NewSymbol("str")
	sym_subs := lang.NewSymbol("subs")
	sym_swap_BANG_ := lang.NewSymbol("swap!")
	sym_touch := lang.NewSymbol("touch")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_w := lang.NewSymbol("w")
	sym_when_DASH_str := lang.NewSymbol("when-str")
	sym_which := lang.NewSymbol("which")
	sym_write_QMARK_ := lang.NewSymbol("write?")
	sym_x := lang.NewSymbol("x")
	sym_ys_DOT_fs := lang.NewSymbol("ys.fs")
	sym_z := lang.NewSymbol("z")
	sym_zero_QMARK_ := lang.NewSymbol("zero?")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_ns := lang.NewKeyword("ns")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/-
	var_clojure_DOT_core__DASH_ := lang.InternVarName(sym_clojure_DOT_core, sym__DASH_)
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/>
	var_clojure_DOT_core__GT_ := lang.InternVarName(sym_clojure_DOT_core, sym__GT_)
	// var clojure.core/<
	var_clojure_DOT_core__LT_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT_)
	// var clojure.core/atom
	var_clojure_DOT_core_atom := lang.InternVarName(sym_clojure_DOT_core, sym_atom)
	// var clojure.core/bit-and
	var_clojure_DOT_core_bit_DASH_and := lang.InternVarName(sym_clojure_DOT_core, sym_bit_DASH_and)
	// var clojure.core/chunk-first
	var_clojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_first)
	// var clojure.core/chunk-rest
	var_clojure_DOT_core_chunk_DASH_rest := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_rest)
	// var clojure.core/chunked-seq?
	var_clojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var clojure.core/conj
	var_clojure_DOT_core_conj := lang.InternVarName(sym_clojure_DOT_core, sym_conj)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/deref
	var_clojure_DOT_core_deref := lang.InternVarName(sym_clojure_DOT_core, sym_deref)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/inc
	var_clojure_DOT_core_inc := lang.InternVarName(sym_clojure_DOT_core, sym_inc)
	// var clojure.core/int
	var_clojure_DOT_core_int := lang.InternVarName(sym_clojure_DOT_core, sym_int)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/not
	var_clojure_DOT_core_not := lang.InternVarName(sym_clojure_DOT_core, sym_not)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/subs
	var_clojure_DOT_core_subs := lang.InternVarName(sym_clojure_DOT_core, sym_subs)
	// var clojure.core/swap!
	var_clojure_DOT_core_swap_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_swap_BANG_)
	// var clojure.core/unchecked-inc
	var_clojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_clojure_DOT_core, sym_unchecked_DASH_inc)
	// var clojure.core/zero?
	var_clojure_DOT_core_zero_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_zero_QMARK_)
	// var clojure.string/blank?
	var_clojure_DOT_string_blank_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_blank_QMARK_)
	// var clojure.string/includes?
	var_clojure_DOT_string_includes_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_includes_QMARK_)
	// var ys.fs/abs
	var_ys_DOT_fs_abs := lang.InternVarName(sym_ys_DOT_fs, sym_abs)
	// var ys.fs/abs?
	var_ys_DOT_fs_abs_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_abs_QMARK_)
	// var ys.fs/basename
	var_ys_DOT_fs_basename := lang.InternVarName(sym_ys_DOT_fs, sym_basename)
	// var ys.fs/cp
	var_ys_DOT_fs_cp := lang.InternVarName(sym_ys_DOT_fs, sym_cp)
	// var ys.fs/cp-r
	var_ys_DOT_fs_cp_DASH_r := lang.InternVarName(sym_ys_DOT_fs, sym_cp_DASH_r)
	// var ys.fs/ctime
	var_ys_DOT_fs_ctime := lang.InternVarName(sym_ys_DOT_fs, sym_ctime)
	// var ys.fs/cwd
	var_ys_DOT_fs_cwd := lang.InternVarName(sym_ys_DOT_fs, sym_cwd)
	// var ys.fs/d
	var_ys_DOT_fs_d := lang.InternVarName(sym_ys_DOT_fs, sym_d)
	// var ys.fs/dir?
	var_ys_DOT_fs_dir_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_dir_QMARK_)
	// var ys.fs/dirname
	var_ys_DOT_fs_dirname := lang.InternVarName(sym_ys_DOT_fs, sym_dirname)
	// var ys.fs/e
	var_ys_DOT_fs_e := lang.InternVarName(sym_ys_DOT_fs, sym_e)
	// var ys.fs/empty?
	var_ys_DOT_fs_empty_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_empty_QMARK_)
	// var ys.fs/exec?
	var_ys_DOT_fs_exec_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_exec_QMARK_)
	// var ys.fs/exists?
	var_ys_DOT_fs_exists_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_exists_QMARK_)
	// var ys.fs/f
	var_ys_DOT_fs_f := lang.InternVarName(sym_ys_DOT_fs, sym_f)
	// var ys.fs/file?
	var_ys_DOT_fs_file_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_file_QMARK_)
	// var ys.fs/filename
	var_ys_DOT_fs_filename := lang.InternVarName(sym_ys_DOT_fs, sym_filename)
	// var ys.fs/find
	var_ys_DOT_fs_find := lang.InternVarName(sym_ys_DOT_fs, sym_find)
	// var ys.fs/get-file-info
	var_ys_DOT_fs_get_DASH_file_DASH_info := lang.InternVarName(sym_ys_DOT_fs, sym_get_DASH_file_DASH_info)
	// var ys.fs/get-link-info
	var_ys_DOT_fs_get_DASH_link_DASH_info := lang.InternVarName(sym_ys_DOT_fs, sym_get_DASH_link_DASH_info)
	// var ys.fs/glob
	var_ys_DOT_fs_glob := lang.InternVarName(sym_ys_DOT_fs, sym_glob)
	// var ys.fs/l
	var_ys_DOT_fs_l := lang.InternVarName(sym_ys_DOT_fs, sym_l)
	// var ys.fs/link?
	var_ys_DOT_fs_link_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_link_QMARK_)
	// var ys.fs/ls
	var_ys_DOT_fs_ls := lang.InternVarName(sym_ys_DOT_fs, sym_ls)
	// var ys.fs/mkdir
	var_ys_DOT_fs_mkdir := lang.InternVarName(sym_ys_DOT_fs, sym_mkdir)
	// var ys.fs/mkdir-p
	var_ys_DOT_fs_mkdir_DASH_p := lang.InternVarName(sym_ys_DOT_fs, sym_mkdir_DASH_p)
	// var ys.fs/mtime
	var_ys_DOT_fs_mtime := lang.InternVarName(sym_ys_DOT_fs, sym_mtime)
	// var ys.fs/multi
	var_ys_DOT_fs_multi := lang.InternVarName(sym_ys_DOT_fs, sym_multi)
	// var ys.fs/mv
	var_ys_DOT_fs_mv := lang.InternVarName(sym_ys_DOT_fs, sym_mv)
	// var ys.fs/path
	var_ys_DOT_fs_path := lang.InternVarName(sym_ys_DOT_fs, sym_path)
	// var ys.fs/r
	var_ys_DOT_fs_r := lang.InternVarName(sym_ys_DOT_fs, sym_r)
	// var ys.fs/read?
	var_ys_DOT_fs_read_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_read_QMARK_)
	// var ys.fs/readlink
	var_ys_DOT_fs_readlink := lang.InternVarName(sym_ys_DOT_fs, sym_readlink)
	// var ys.fs/rel
	var_ys_DOT_fs_rel := lang.InternVarName(sym_ys_DOT_fs, sym_rel)
	// var ys.fs/rel?
	var_ys_DOT_fs_rel_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_rel_QMARK_)
	// var ys.fs/rm
	var_ys_DOT_fs_rm := lang.InternVarName(sym_ys_DOT_fs, sym_rm)
	// var ys.fs/rm-f
	var_ys_DOT_fs_rm_DASH_f := lang.InternVarName(sym_ys_DOT_fs, sym_rm_DASH_f)
	// var ys.fs/rm-r
	var_ys_DOT_fs_rm_DASH_r := lang.InternVarName(sym_ys_DOT_fs, sym_rm_DASH_r)
	// var ys.fs/rmdir
	var_ys_DOT_fs_rmdir := lang.InternVarName(sym_ys_DOT_fs, sym_rmdir)
	// var ys.fs/s
	var_ys_DOT_fs_s := lang.InternVarName(sym_ys_DOT_fs, sym_s)
	// var ys.fs/size?
	var_ys_DOT_fs_size_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_size_QMARK_)
	// var ys.fs/touch
	var_ys_DOT_fs_touch := lang.InternVarName(sym_ys_DOT_fs, sym_touch)
	// var ys.fs/w
	var_ys_DOT_fs_w := lang.InternVarName(sym_ys_DOT_fs, sym_w)
	// var ys.fs/when-str
	var_ys_DOT_fs_when_DASH_str := lang.InternVarName(sym_ys_DOT_fs, sym_when_DASH_str)
	// var ys.fs/which
	var_ys_DOT_fs_which := lang.InternVarName(sym_ys_DOT_fs, sym_which)
	// var ys.fs/write?
	var_ys_DOT_fs_write_QMARK_ := lang.InternVarName(sym_ys_DOT_fs, sym_write_QMARK_)
	// var ys.fs/x
	var_ys_DOT_fs_x := lang.InternVarName(sym_ys_DOT_fs, sym_x)
	// var ys.fs/z
	var_ys_DOT_fs_z := lang.InternVarName(sym_ys_DOT_fs, sym_z)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_ys_DOT_fs)
	_ = ns
	// abs?
	{
		tmp0 := sym_abs_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(37), kw_column, int(7), kw_end_DASH_line, int(37), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is absolute"
			tmp3 := lang.Apply(filepath4.IsAbs, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_abs_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_abs_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mkdir
	{
		tmp0 := sym_mkdir.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(241), kw_column, int(7), kw_end_DASH_line, int(241), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Create directory"
			tmp3 := lang.Apply(os5.Mkdir, []any{v2, int64(493)})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_mkdir = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_mkdir.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mkdir-p
	{
		tmp0 := sym_mkdir_DASH_p.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(245), kw_column, int(7), kw_end_DASH_line, int(245), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Create directory and parents"
			tmp3 := lang.Apply(os5.MkdirAll, []any{v2, int64(493)})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_mkdir_DASH_p = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_mkdir_DASH_p.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mv
	{
		tmp0 := sym_mv.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(249), kw_column, int(7), kw_end_DASH_line, int(249), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_src, sym_dst)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			_ = "Move/rename file or directory"
			tmp4 := lang.Apply(os5.Rename, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_mv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_mv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rm
	{
		tmp0 := sym_rm.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(253), kw_column, int(7), kw_end_DASH_line, int(253), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Remove file or empty directory"
			tmp3 := lang.Apply(os5.Remove, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rm = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rm.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rm-f
	{
		tmp0 := sym_rm_DASH_f.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(257), kw_column, int(7), kw_end_DASH_line, int(257), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Remove file, ignore errors"
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := lang.Apply(os5.Remove, []any{v2})
				tmp3 = tmp4
			}()
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rm_DASH_f = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rm_DASH_f.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rm-r
	{
		tmp0 := sym_rm_DASH_r.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(263), kw_column, int(7), kw_end_DASH_line, int(263), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Remove directory recursively"
			tmp3 := lang.Apply(os5.RemoveAll, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rm_DASH_r = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rm_DASH_r.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rmdir
	{
		tmp0 := sym_rmdir.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(267), kw_column, int(7), kw_end_DASH_line, int(267), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Remove empty directory"
			tmp3 := lang.Apply(os5.Remove, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rmdir = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rmdir.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	var closed0 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is a directory"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						tmp9, ok := lang.FieldOrMethod(v8, "IsDir")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "IsDir")))
						}
						var tmp10 any
						switch reflect.TypeOf(tmp9).Kind() {
						case reflect.Func:
							tmp10 = lang.Apply(tmp9, nil)
						default:
							tmp10 = tmp9
						}
						tmp7 = tmp10
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed0 = tmp0
	}
	var closed1 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path exists"
			tmp2 := checkDerefVar(var_clojure_DOT_core_not)
			tmp3 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
			tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
			tmp5 := lang.Apply(tmp4, []any{v1})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			tmp7 := lang.Apply(tmp2, []any{tmp6})
			return tmp7
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed1 = tmp0
	}
	var closed2 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is a regular file"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						{ // let
							// let binding "mode"
							tmp10, ok := lang.FieldOrMethod(v8, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Mode")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							var v12 any = tmp11
							_ = v12
							tmp13, ok := lang.FieldOrMethod(v12, "IsRegular")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "IsRegular")))
							}
							var tmp14 any
							switch reflect.TypeOf(tmp13).Kind() {
							case reflect.Func:
								tmp14 = lang.Apply(tmp13, nil)
							default:
								tmp14 = tmp13
							}
							tmp9 = tmp14
						} // end let
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed2 = tmp0
	}
	var closed3 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is a symbolic link"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_link_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						{ // let
							// let binding "mode"
							tmp10, ok := lang.FieldOrMethod(v8, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Mode")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							var v12 any = tmp11
							_ = v12
							// let binding "link-bit"
							tmp13 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp14 := lang.Apply(tmp13, []any{v12, os5.ModeSymlink})
							var v15 any = tmp14
							_ = v15
							tmp16 := checkDerefVar(var_clojure_DOT_core_not)
							tmp17 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v15})
							tmp19 := lang.Apply(tmp16, []any{tmp18})
							tmp9 = tmp19
						} // end let
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed3 = tmp0
	}
	var closed4 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is readable"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						{ // let
							// let binding "mode"
							tmp10, ok := lang.FieldOrMethod(v8, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Mode")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							var v12 any = tmp11
							_ = v12
							// let binding "read-bits"
							tmp13 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp14 := lang.Apply(tmp13, []any{v12, int64(292)})
							var v15 any = tmp14
							_ = v15
							tmp16 := checkDerefVar(var_clojure_DOT_core_not)
							tmp17 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v15})
							tmp19 := lang.Apply(tmp16, []any{tmp18})
							tmp9 = tmp19
						} // end let
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed4 = tmp0
	}
	var closed5 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if file size > 0"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						tmp9 := checkDerefVar(var_clojure_DOT_core__GT_)
						tmp10, ok := lang.FieldOrMethod(v8, "Size")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Size")))
						}
						var tmp11 any
						switch reflect.TypeOf(tmp10).Kind() {
						case reflect.Func:
							tmp11 = lang.Apply(tmp10, nil)
						default:
							tmp11 = tmp10
						}
						tmp12 := lang.Apply(tmp9, []any{tmp11, int64(0)})
						tmp7 = tmp12
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed5 = tmp0
	}
	var closed6 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is writable"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						{ // let
							// let binding "mode"
							tmp10, ok := lang.FieldOrMethod(v8, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Mode")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							var v12 any = tmp11
							_ = v12
							// let binding "write-bits"
							tmp13 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp14 := lang.Apply(tmp13, []any{v12, int64(146)})
							var v15 any = tmp14
							_ = v15
							tmp16 := checkDerefVar(var_clojure_DOT_core_not)
							tmp17 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v15})
							tmp19 := lang.Apply(tmp16, []any{tmp18})
							tmp9 = tmp19
						} // end let
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed6 = tmp0
	}
	var closed7 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if path is executable"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						{ // let
							// let binding "mode"
							tmp10, ok := lang.FieldOrMethod(v8, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Mode")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							var v12 any = tmp11
							_ = v12
							// let binding "exec-bits"
							tmp13 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp14 := lang.Apply(tmp13, []any{v12, int64(73)})
							var v15 any = tmp14
							_ = v15
							tmp16 := checkDerefVar(var_clojure_DOT_core_not)
							tmp17 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v15})
							tmp19 := lang.Apply(tmp16, []any{tmp18})
							tmp9 = tmp19
						} // end let
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed7 = tmp0
	}
	var closed8 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			_ = "True if file size is 0 or directory is empty"
			var tmp2 any
			{ // let
				// let binding "temp__0__auto__"
				tmp3 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp4 := lang.Apply(tmp3, []any{v1})
				var v5 any = tmp4
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					var tmp7 any
					{ // let
						// let binding "info"
						var v8 any = v5
						_ = v8
						var tmp9 any
						tmp10, ok := lang.FieldOrMethod(v8, "IsDir")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "IsDir")))
						}
						var tmp11 any
						switch reflect.TypeOf(tmp10).Kind() {
						case reflect.Func:
							tmp11 = lang.Apply(tmp10, nil)
						default:
							tmp11 = tmp10
						}
						if lang.IsTruthy(tmp11) {
							var tmp12 any
							{ // let
								// let binding "entries"
								tmp13 := lang.Apply(os5.ReadDir, []any{v1})
								var v14 any = tmp13
								_ = v14
								tmp15 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
								tmp16 := checkDerefVar(var_clojure_DOT_core_count)
								tmp17 := lang.Apply(tmp16, []any{v14})
								tmp18 := lang.Apply(tmp15, []any{tmp17})
								tmp12 = tmp18
							} // end let
							tmp9 = tmp12
						} else {
							tmp13 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp14, ok := lang.FieldOrMethod(v8, "Size")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Size")))
							}
							var tmp15 any
							switch reflect.TypeOf(tmp14).Kind() {
							case reflect.Func:
								tmp15 = lang.Apply(tmp14, nil)
							default:
								tmp15 = tmp14
							}
							tmp16 := lang.Apply(tmp13, []any{tmp15})
							tmp9 = tmp16
						}
						tmp7 = tmp9
					} // end let
					tmp6 = tmp7
				} else {
					tmp6 = false
				}
				tmp2 = tmp6
			} // end let
			return tmp2
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed8 = tmp0
	}
	// abs
	{
		tmp0 := sym_abs.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(124), kw_column, int(7), kw_end_DASH_line, int(124), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return absolute path"
			var tmp3 any
			{ // let
				// let binding "vec__7"
				tmp4 := lang.Apply(filepath4.Abs, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "result"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
					tmp12 = v2
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_abs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_abs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// basename
	{
		tmp0 := sym_basename.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(129), kw_column, int(7), kw_end_DASH_line, int(129), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return basename of path (follows symlinks)"
			var tmp3 any
			{ // let
				// let binding "vec__10"
				tmp4 := lang.Apply(filepath4.EvalSymlinks, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "real-path"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
					tmp12 = v2
				}
				tmp15 := lang.Apply(filepath4.Base, []any{tmp12})
				tmp3 = tmp15
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_basename = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_basename.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cp
	{
		tmp0 := sym_cp.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(219), kw_column, int(7), kw_end_DASH_line, int(219), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_src, sym_dst)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			_ = "Copy file from src to dst"
			var tmp4 any
			{ // let
				// let binding "vec__41"
				tmp5 := lang.Apply(os5.ReadFile, []any{v2})
				var v6 any = tmp5
				_ = v6
				// let binding "content"
				tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
				var v9 any = tmp8
				_ = v9
				// let binding "err"
				tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				tmp14 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp15 := lang.Apply(tmp14, []any{v12})
				if lang.IsTruthy(tmp15) {
					tmp16 := lang.Apply(os5.WriteFile, []any{v3, v9, int64(420)})
					tmp13 = tmp16
				} else {
				}
				tmp4 = tmp13
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_cp = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_cp.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cp-r
	{
		tmp0 := sym_cp_DASH_r.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(225), kw_column, int(7), kw_end_DASH_line, int(225), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_src, sym_dst)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			_ = "Recursively copy directory"
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 3)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				v7 := args[2]
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7})
				if lang.IsTruthy(tmp10) {
					var tmp11 any
					{ // let
						// let binding "vec__44"
						tmp12 := lang.Apply(filepath4.Rel, []any{v2, v5})
						var v13 any = tmp12
						_ = v13
						// let binding "rel-path"
						tmp14 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
						var v16 any = tmp15
						_ = v16
						// let binding "_"
						tmp17 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp18 := lang.Apply(tmp17, []any{v13, int64(1), nil})
						var v19 any = tmp18
						_ = v19
						// let binding "dst-path"
						tmp20 := lang.Apply(filepath4.Join, []any{v3, v16})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						tmp23, ok := lang.FieldOrMethod(v6, "IsDir")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "IsDir")))
						}
						var tmp24 any
						switch reflect.TypeOf(tmp23).Kind() {
						case reflect.Func:
							tmp24 = lang.Apply(tmp23, nil)
						default:
							tmp24 = tmp23
						}
						if lang.IsTruthy(tmp24) {
							tmp25 := lang.Apply(os5.MkdirAll, []any{v21, int64(493)})
							tmp22 = tmp25
						} else {
							var tmp26 any
							{ // let
								// let binding "vec__47"
								tmp27 := lang.Apply(os5.ReadFile, []any{v5})
								var v28 any = tmp27
								_ = v28
								// let binding "content"
								tmp29 := checkDerefVar(var_clojure_DOT_core_nth)
								tmp30 := lang.Apply(tmp29, []any{v28, int64(0), nil})
								var v31 any = tmp30
								_ = v31
								// let binding "read-err"
								tmp32 := checkDerefVar(var_clojure_DOT_core_nth)
								tmp33 := lang.Apply(tmp32, []any{v28, int64(1), nil})
								var v34 any = tmp33
								_ = v34
								var tmp35 any
								tmp36 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
								tmp37 := lang.Apply(tmp36, []any{v34})
								if lang.IsTruthy(tmp37) {
									tmp38, ok := lang.FieldOrMethod(v6, "Mode")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "Mode")))
									}
									var tmp39 any
									switch reflect.TypeOf(tmp38).Kind() {
									case reflect.Func:
										tmp39 = lang.Apply(tmp38, nil)
									default:
										tmp39 = tmp38
									}
									tmp40 := lang.Apply(os5.WriteFile, []any{v21, v31, tmp39})
									tmp35 = tmp40
								} else {
								}
								tmp26 = tmp35
							} // end let
							tmp22 = tmp26
						}
						tmp11 = tmp22
					} // end let
					tmp8 = tmp11
				} else {
				}
				_ = tmp8
				return nil
			})
			tmp5 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(229), kw_column, int(5), kw_end_DASH_line, int(238), kw_end_DASH_column, int(10))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(filepath4.Walk, []any{v2, tmp6})
			_ = tmp7
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_cp_DASH_r = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_cp_DASH_r.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ctime
	{
		tmp0 := sym_ctime.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(134), kw_column, int(7), kw_end_DASH_line, int(134), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return creation time in milliseconds (same as mtime in Unix)"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						tmp10, ok := lang.FieldOrMethod(v9, "ModTime")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "ModTime")))
						}
						var tmp11 any
						switch reflect.TypeOf(tmp10).Kind() {
						case reflect.Func:
							tmp11 = lang.Apply(tmp10, nil)
						default:
							tmp11 = tmp10
						}
						tmp12, ok := lang.FieldOrMethod(tmp11, "UnixMilli")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp11, "UnixMilli")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp8 = tmp13
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_ctime = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_ctime.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cwd
	{
		tmp0 := sym_cwd.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(146), kw_column, int(7), kw_end_DASH_line, int(146), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			_ = "Return current working directory"
			var tmp2 any
			{ // let
				// let binding "vec__13"
				tmp3 := lang.Apply(os5.Getwd, nil)
				var v4 any = tmp3
				_ = v4
				// let binding "result"
				tmp5 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp6 := lang.Apply(tmp5, []any{v4, int64(0), nil})
				var v7 any = tmp6
				_ = v7
				// let binding "err"
				tmp8 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp9 := lang.Apply(tmp8, []any{v4, int64(1), nil})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				tmp12 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp13 := lang.Apply(tmp12, []any{v10})
				if lang.IsTruthy(tmp13) {
					tmp11 = v7
				} else {
					tmp11 = "."
				}
				tmp2 = tmp11
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_cwd = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_cwd.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// d
	{
		tmp0 := sym_d.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(110), kw_column, int(6), kw_end_DASH_line, int(110), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed0, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed0, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_d = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_d.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dir?
	{
		tmp0 := sym_dir_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(41), kw_column, int(7), kw_end_DASH_line, int(41), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is a directory"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						tmp10, ok := lang.FieldOrMethod(v9, "IsDir")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "IsDir")))
						}
						var tmp11 any
						switch reflect.TypeOf(tmp10).Kind() {
						case reflect.Func:
							tmp11 = lang.Apply(tmp10, nil)
						default:
							tmp11 = tmp10
						}
						tmp8 = tmp11
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_dir_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_dir_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dirname
	{
		tmp0 := sym_dirname.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(151), kw_column, int(7), kw_end_DASH_line, int(151), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return directory name of path (follows symlinks)"
			var tmp3 any
			{ // let
				// let binding "vec__16"
				tmp4 := lang.Apply(filepath4.EvalSymlinks, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "real-path"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
					tmp12 = v2
				}
				tmp15 := lang.Apply(filepath4.Dir, []any{tmp12})
				tmp3 = tmp15
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_dirname = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_dirname.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// e
	{
		tmp0 := sym_e.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(111), kw_column, int(6), kw_end_DASH_line, int(111), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed1, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed1, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_e = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_e.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty?
	{
		tmp0 := sym_empty_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(47), kw_column, int(7), kw_end_DASH_line, int(47), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if file size is 0 or directory is empty"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						tmp11, ok := lang.FieldOrMethod(v9, "IsDir")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "IsDir")))
						}
						var tmp12 any
						switch reflect.TypeOf(tmp11).Kind() {
						case reflect.Func:
							tmp12 = lang.Apply(tmp11, nil)
						default:
							tmp12 = tmp11
						}
						if lang.IsTruthy(tmp12) {
							var tmp13 any
							{ // let
								// let binding "entries"
								tmp14 := lang.Apply(os5.ReadDir, []any{v2})
								var v15 any = tmp14
								_ = v15
								tmp16 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
								tmp17 := checkDerefVar(var_clojure_DOT_core_count)
								tmp18 := lang.Apply(tmp17, []any{v15})
								tmp19 := lang.Apply(tmp16, []any{tmp18})
								tmp13 = tmp19
							} // end let
							tmp10 = tmp13
						} else {
							tmp14 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp15, ok := lang.FieldOrMethod(v9, "Size")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Size")))
							}
							var tmp16 any
							switch reflect.TypeOf(tmp15).Kind() {
							case reflect.Func:
								tmp16 = lang.Apply(tmp15, nil)
							default:
								tmp16 = tmp15
							}
							tmp17 := lang.Apply(tmp14, []any{tmp16})
							tmp10 = tmp17
						}
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_empty_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_empty_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// exec?
	{
		tmp0 := sym_exec_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(56), kw_column, int(7), kw_end_DASH_line, int(56), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is executable"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "mode"
							tmp11, ok := lang.FieldOrMethod(v9, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Mode")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							var v13 any = tmp12
							_ = v13
							// let binding "exec-bits"
							tmp14 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp15 := lang.Apply(tmp14, []any{v13, int64(73)})
							var v16 any = tmp15
							_ = v16
							tmp17 := checkDerefVar(var_clojure_DOT_core_not)
							tmp18 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp19 := lang.Apply(tmp18, []any{v16})
							tmp20 := lang.Apply(tmp17, []any{tmp19})
							tmp10 = tmp20
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_exec_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_exec_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// exists?
	{
		tmp0 := sym_exists_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(64), kw_column, int(7), kw_end_DASH_line, int(64), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path exists"
			tmp3 := checkDerefVar(var_clojure_DOT_core_not)
			tmp4 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
			tmp5 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := lang.Apply(tmp3, []any{tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_exists_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_exists_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// f
	{
		tmp0 := sym_f.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(112), kw_column, int(6), kw_end_DASH_line, int(112), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed2, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed2, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_f = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_f.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file?
	{
		tmp0 := sym_file_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(68), kw_column, int(7), kw_end_DASH_line, int(68), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is a regular file"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "mode"
							tmp11, ok := lang.FieldOrMethod(v9, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Mode")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							var v13 any = tmp12
							_ = v13
							tmp14, ok := lang.FieldOrMethod(v13, "IsRegular")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "IsRegular")))
							}
							var tmp15 any
							switch reflect.TypeOf(tmp14).Kind() {
							case reflect.Func:
								tmp15 = lang.Apply(tmp14, nil)
							default:
								tmp15 = tmp14
							}
							tmp10 = tmp15
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_file_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_file_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filename
	{
		tmp0 := sym_filename.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(156), kw_column, int(7), kw_end_DASH_line, int(156), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return filename without extension"
			var tmp3 any
			{ // let
				// let binding "base"
				tmp4 := lang.Apply(filepath4.Base, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "ext"
				tmp6 := lang.Apply(filepath4.Ext, []any{v5})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_string_blank_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7})
				if lang.IsTruthy(tmp10) {
					tmp8 = v5
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp12 := checkDerefVar(var_clojure_DOT_core__DASH_)
					tmp13 := checkDerefVar(var_clojure_DOT_core_count)
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := checkDerefVar(var_clojure_DOT_core_count)
					tmp16 := lang.Apply(tmp15, []any{v7})
					tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
					tmp18 := lang.Apply(tmp11, []any{v5, int64(0), tmp17})
					tmp8 = tmp18
				}
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_filename = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_filename.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find
	{
		tmp0 := sym_find.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(164), kw_column, int(7), kw_end_DASH_line, int(164), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path, sym__AMP_, sym_patterns)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				_ = "Walk directory tree and return matching paths"
				var tmp4 any
				{ // let
					// let binding "results"
					tmp5 := checkDerefVar(var_clojure_DOT_core_atom)
					tmp6 := lang.NewVector()
					tmp7 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(166), kw_column, int(23), kw_end_DASH_line, int(166), kw_end_DASH_column, int(24))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v12 := args[0]
						_ = v12
						v13 := args[1]
						_ = v13
						v14 := args[2]
						_ = v14
						var tmp15 any
						tmp16 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v14})
						if lang.IsTruthy(tmp17) {
							var tmp18 any
							tmp19 := checkDerefVar(var_ys_DOT_fs_empty_QMARK_)
							tmp20 := lang.Apply(tmp19, []any{v3})
							if lang.IsTruthy(tmp20) {
								tmp21 := checkDerefVar(var_clojure_DOT_core_swap_BANG_)
								tmp22 := checkDerefVar(var_clojure_DOT_core_conj)
								tmp23 := lang.Apply(tmp21, []any{v10, tmp22, v12})
								tmp18 = tmp23
							} else {
								var tmp24 any
								{ // let
									// let binding "seq_19"
									tmp25 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp26 := lang.Apply(tmp25, []any{v3})
									var v27 any = tmp26
									_ = v27
									// let binding "chunk_20"
									var v28 any = nil
									_ = v28
									// let binding "count_21"
									var v29 any = int64(0)
									_ = v29
									// let binding "i_22"
									var v30 any = int64(0)
									_ = v30
									for {
										var tmp31 any
										tmp32 := checkDerefVar(var_clojure_DOT_core__LT_)
										tmp33 := lang.Apply(tmp32, []any{v30, v29})
										if lang.IsTruthy(tmp33) {
											var tmp34 any
											{ // let
												// let binding "pattern"
												tmp35, _ := lang.FieldOrMethod(v28, "nth")
												if reflect.TypeOf(tmp35).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp36 := lang.Apply(tmp35, []any{v30})
												var v37 any = tmp36
												_ = v37
												var tmp38 any
												tmp39 := checkDerefVar(var_clojure_DOT_string_includes_QMARK_)
												tmp40 := lang.Apply(tmp39, []any{v12, v37})
												if lang.IsTruthy(tmp40) {
													tmp41 := checkDerefVar(var_clojure_DOT_core_swap_BANG_)
													tmp42 := checkDerefVar(var_clojure_DOT_core_conj)
													tmp43 := lang.Apply(tmp41, []any{v10, tmp42, v12})
													tmp38 = tmp43
												} else {
												}
												_ = tmp38
												var tmp44 any = v27
												var tmp45 any = v28
												var tmp46 any = v29
												tmp48 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
												tmp49 := lang.Apply(tmp48, []any{v30})
												var tmp47 any = tmp49
												v27 = tmp44
												v28 = tmp45
												v29 = tmp46
												v30 = tmp47
												continue
											} // end let
											tmp31 = tmp34
										} else {
											var tmp35 any
											{ // let
												// let binding "temp__0__auto__"
												tmp36 := checkDerefVar(var_clojure_DOT_core_seq)
												tmp37 := lang.Apply(tmp36, []any{v27})
												var v38 any = tmp37
												_ = v38
												var tmp39 any
												if lang.IsTruthy(v38) {
													var tmp40 any
													{ // let
														// let binding "seq_19"
														var v41 any = v38
														_ = v41
														var tmp42 any
														tmp43 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp44 := lang.Apply(tmp43, []any{v41})
														if lang.IsTruthy(tmp44) {
															var tmp45 any
															{ // let
																// let binding "c__0__auto__"
																tmp46 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
																tmp47 := lang.Apply(tmp46, []any{v41})
																var v48 any = tmp47
																_ = v48
																tmp50 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
																tmp51 := lang.Apply(tmp50, []any{v41})
																var tmp49 any = tmp51
																var tmp52 any = v48
																tmp54 := checkDerefVar(var_clojure_DOT_core_int)
																tmp55 := checkDerefVar(var_clojure_DOT_core_count)
																tmp56 := lang.Apply(tmp55, []any{v48})
																tmp57 := lang.Apply(tmp54, []any{tmp56})
																var tmp53 any = tmp57
																tmp59 := checkDerefVar(var_clojure_DOT_core_int)
																tmp60 := lang.Apply(tmp59, []any{int64(0)})
																var tmp58 any = tmp60
																v27 = tmp49
																v28 = tmp52
																v29 = tmp53
																v30 = tmp58
																continue
															} // end let
															tmp42 = tmp45
														} else {
															var tmp46 any
															{ // let
																// let binding "pattern"
																tmp47 := checkDerefVar(var_clojure_DOT_core_first)
																tmp48 := lang.Apply(tmp47, []any{v41})
																var v49 any = tmp48
																_ = v49
																var tmp50 any
																tmp51 := checkDerefVar(var_clojure_DOT_string_includes_QMARK_)
																tmp52 := lang.Apply(tmp51, []any{v12, v49})
																if lang.IsTruthy(tmp52) {
																	tmp53 := checkDerefVar(var_clojure_DOT_core_swap_BANG_)
																	tmp54 := checkDerefVar(var_clojure_DOT_core_conj)
																	tmp55 := lang.Apply(tmp53, []any{v10, tmp54, v12})
																	tmp50 = tmp55
																} else {
																}
																_ = tmp50
																tmp57 := checkDerefVar(var_clojure_DOT_core_next)
																tmp58 := lang.Apply(tmp57, []any{v41})
																var tmp56 any = tmp58
																var tmp59 any = nil
																var tmp60 any = int64(0)
																var tmp61 any = int64(0)
																v27 = tmp56
																v28 = tmp59
																v29 = tmp60
																v30 = tmp61
																continue
															} // end let
															tmp42 = tmp46
														}
														tmp40 = tmp42
													} // end let
													tmp39 = tmp40
												} else {
												}
												tmp35 = tmp39
											} // end let
											tmp31 = tmp35
										}
										tmp24 = tmp31
										break
									}
								} // end let
								tmp18 = tmp24
							}
							tmp15 = tmp18
						} else {
						}
						_ = tmp15
						return nil
					})
					tmp12 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(169), kw_column, int(7), kw_end_DASH_line, int(176), kw_end_DASH_column, int(12))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(filepath4.Walk, []any{v2, tmp13})
					_ = tmp14
					tmp15 := checkDerefVar(var_clojure_DOT_core_deref)
					tmp16 := lang.Apply(tmp15, []any{v10})
					tmp4 = tmp16
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_find = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_find.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-file-info
	{
		tmp0 := sym_get_DASH_file_DASH_info.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(19), kw_column, int(8), kw_end_DASH_line, int(19), kw_end_DASH_column, int(20), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Get os.FileInfo for path, returns nil on error"
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
						} else {
							panic(r)
						}
					}
				}()
				var tmp4 any
				{ // let
					// let binding "vec__1"
					tmp5 := lang.Apply(os5.Stat, []any{v2})
					var v6 any = tmp5
					_ = v6
					// let binding "info"
					tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
					var v9 any = tmp8
					_ = v9
					// let binding "err"
					tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					tmp14 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
					tmp15 := lang.Apply(tmp14, []any{v12})
					if lang.IsTruthy(tmp15) {
						tmp13 = v9
					} else {
					}
					tmp4 = tmp13
				} // end let
				tmp3 = tmp4
			}()
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_get_DASH_file_DASH_info = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_get_DASH_file_DASH_info.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mtime
	{
		tmp0 := sym_mtime.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(140), kw_column, int(7), kw_end_DASH_line, int(140), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return modification time in milliseconds"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						tmp10, ok := lang.FieldOrMethod(v9, "ModTime")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "ModTime")))
						}
						var tmp11 any
						switch reflect.TypeOf(tmp10).Kind() {
						case reflect.Func:
							tmp11 = lang.Apply(tmp10, nil)
						default:
							tmp11 = tmp10
						}
						tmp12, ok := lang.FieldOrMethod(tmp11, "UnixMilli")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp11, "UnixMilli")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp8 = tmp13
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_mtime = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_mtime.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-link-info
	{
		tmp0 := sym_get_DASH_link_DASH_info.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(26), kw_column, int(8), kw_end_DASH_line, int(26), kw_end_DASH_column, int(20), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Get os.FileInfo for symlink (don't follow), returns nil on error"
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
						} else {
							panic(r)
						}
					}
				}()
				var tmp4 any
				{ // let
					// let binding "vec__4"
					tmp5 := lang.Apply(os5.Lstat, []any{v2})
					var v6 any = tmp5
					_ = v6
					// let binding "info"
					tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
					var v9 any = tmp8
					_ = v9
					// let binding "err"
					tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					tmp14 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
					tmp15 := lang.Apply(tmp14, []any{v12})
					if lang.IsTruthy(tmp15) {
						tmp13 = v9
					} else {
					}
					tmp4 = tmp13
				} // end let
				tmp3 = tmp4
			}()
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_get_DASH_link_DASH_info = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_get_DASH_link_DASH_info.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// glob
	{
		tmp0 := sym_glob.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(179), kw_column, int(7), kw_end_DASH_line, int(179), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_pattern)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return paths matching glob pattern"
			var tmp3 any
			{ // let
				// let binding "vec__23"
				tmp4 := lang.Apply(filepath4.Glob, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "result"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
					tmp15 := lang.NewVector()
					tmp16 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(182), kw_column, int(27), kw_end_DASH_line, int(182), kw_end_DASH_column, int(28))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 = tmp17
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_glob = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_glob.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// l
	{
		tmp0 := sym_l.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(113), kw_column, int(6), kw_end_DASH_line, int(113), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed3, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed3, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_l = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_l.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// link?
	{
		tmp0 := sym_link_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(75), kw_column, int(7), kw_end_DASH_line, int(75), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is a symbolic link"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_link_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "mode"
							tmp11, ok := lang.FieldOrMethod(v9, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Mode")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							var v13 any = tmp12
							_ = v13
							// let binding "link-bit"
							tmp14 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp15 := lang.Apply(tmp14, []any{v13, os5.ModeSymlink})
							var v16 any = tmp15
							_ = v16
							tmp17 := checkDerefVar(var_clojure_DOT_core_not)
							tmp18 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp19 := lang.Apply(tmp18, []any{v16})
							tmp20 := lang.Apply(tmp17, []any{tmp19})
							tmp10 = tmp20
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_link_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_link_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ls
	{
		tmp0 := sym_ls.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(184), kw_column, int(7), kw_end_DASH_line, int(184), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "List directory contents"
			var tmp3 any
			{ // let
				// let binding "vec__26"
				tmp4 := lang.Apply(os5.ReadDir, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "entries"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					var tmp15 any
					{ // let
						// let binding "i"
						var v16 any = int64(0)
						_ = v16
						// let binding "n"
						tmp17 := checkDerefVar(var_clojure_DOT_core_count)
						tmp18 := lang.Apply(tmp17, []any{v8})
						var v19 any = tmp18
						_ = v19
						// let binding "result"
						tmp20 := lang.NewVector()
						tmp21 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(188), kw_column, int(45), kw_end_DASH_line, int(188), kw_end_DASH_column, int(46))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v23 any = tmp22
						_ = v23
						for {
							var tmp24 any
							tmp25 := checkDerefVar(var_clojure_DOT_core__LT_)
							tmp26 := lang.Apply(tmp25, []any{v16, v19})
							if lang.IsTruthy(tmp26) {
								tmp28 := checkDerefVar(var_clojure_DOT_core_inc)
								tmp29 := lang.Apply(tmp28, []any{v16})
								var tmp27 any = tmp29
								var tmp30 any = v19
								tmp32 := checkDerefVar(var_clojure_DOT_core_conj)
								tmp33 := checkDerefVar(var_clojure_DOT_core_nth)
								tmp34 := lang.Apply(tmp33, []any{v8, v16})
								tmp35, ok := lang.FieldOrMethod(tmp34, "Name")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp34, "Name")))
								}
								var tmp36 any
								switch reflect.TypeOf(tmp35).Kind() {
								case reflect.Func:
									tmp36 = lang.Apply(tmp35, nil)
								default:
									tmp36 = tmp35
								}
								tmp37 := lang.Apply(tmp32, []any{v23, tmp36})
								var tmp31 any = tmp37
								v16 = tmp27
								v19 = tmp30
								v23 = tmp31
								continue
							} else {
								tmp24 = v23
							}
							tmp15 = tmp24
							break
						}
					} // end let
					tmp12 = tmp15
				} else {
					tmp16 := lang.NewVector()
					tmp17 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(192), kw_column, int(7), kw_end_DASH_line, int(192), kw_end_DASH_column, int(8))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 = tmp18
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_ls = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_ls.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// multi
	{
		tmp0 := sym_multi.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(12), kw_column, int(8), kw_end_DASH_line, int(12), kw_end_DASH_column, int(12), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Wrap single-path function to support multiple paths"
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					restArgs := args[0:]
					var v4 any
					if len(restArgs) > 0 {
						v4 = lang.NewList(restArgs...)
					}
					_ = v4
					var tmp5 any
					tmp6 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp7 := checkDerefVar(var_clojure_DOT_core_count)
					tmp8 := lang.Apply(tmp7, []any{v4})
					tmp9 := lang.Apply(tmp6, []any{int64(1), tmp8})
					if lang.IsTruthy(tmp9) {
						tmp10 := checkDerefVar(var_clojure_DOT_core_first)
						tmp11 := lang.Apply(tmp10, []any{v4})
						tmp12 := lang.Apply(v2, []any{tmp11})
						tmp5 = tmp12
					} else {
						tmp13 := checkDerefVar(var_clojure_DOT_core_map)
						tmp14 := lang.Apply(tmp13, []any{v2, v4})
						tmp5 = tmp14
					}
					return tmp5
				}
			})
			tmp4 := lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_multi = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_multi.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// path
	{
		tmp0 := sym_path.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(194), kw_column, int(7), kw_end_DASH_line, int(194), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_p)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return canonical path (follows symlinks)"
			var tmp3 any
			{ // let
				// let binding "vec__29"
				tmp4 := lang.Apply(filepath4.EvalSymlinks, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "result"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
					tmp12 = v2
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_path = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_path.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// r
	{
		tmp0 := sym_r.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(114), kw_column, int(6), kw_end_DASH_line, int(114), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed4, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed4, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_r = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_r.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read?
	{
		tmp0 := sym_read_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(83), kw_column, int(7), kw_end_DASH_line, int(83), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is readable"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "mode"
							tmp11, ok := lang.FieldOrMethod(v9, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Mode")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							var v13 any = tmp12
							_ = v13
							// let binding "read-bits"
							tmp14 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp15 := lang.Apply(tmp14, []any{v13, int64(292)})
							var v16 any = tmp15
							_ = v16
							tmp17 := checkDerefVar(var_clojure_DOT_core_not)
							tmp18 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp19 := lang.Apply(tmp18, []any{v16})
							tmp20 := lang.Apply(tmp17, []any{tmp19})
							tmp10 = tmp20
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_read_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_read_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// readlink
	{
		tmp0 := sym_readlink.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(199), kw_column, int(7), kw_end_DASH_line, int(199), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Read symbolic link target"
			var tmp3 any
			{ // let
				// let binding "vec__32"
				tmp4 := lang.Apply(os5.Readlink, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "result"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_readlink = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_readlink.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rel
	{
		tmp0 := sym_rel.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(204), kw_column, int(7), kw_end_DASH_line, int(204), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Return path relative to current directory"
			var tmp3 any
			{ // let
				// let binding "cwd-path"
				tmp4 := checkDerefVar(var_ys_DOT_fs_cwd)
				tmp5 := lang.Apply(tmp4, nil)
				var v6 any = tmp5
				_ = v6
				// let binding "vec__35"
				tmp7 := lang.Apply(filepath4.Rel, []any{v6, v2})
				var v8 any = tmp7
				_ = v8
				// let binding "result"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v8, int64(0), nil})
				var v11 any = tmp10
				_ = v11
				// let binding "err"
				tmp12 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp13 := lang.Apply(tmp12, []any{v8, int64(1), nil})
				var v14 any = tmp13
				_ = v14
				var tmp15 any
				tmp16 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp17 := lang.Apply(tmp16, []any{v14})
				if lang.IsTruthy(tmp17) {
					tmp15 = v11
				} else {
					tmp15 = v2
				}
				tmp3 = tmp15
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rel = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rel.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rel?
	{
		tmp0 := sym_rel_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(91), kw_column, int(7), kw_end_DASH_line, int(91), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is relative"
			tmp3 := checkDerefVar(var_clojure_DOT_core_not)
			tmp4 := lang.Apply(filepath4.IsAbs, []any{v2})
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_rel_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_rel_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// s
	{
		tmp0 := sym_s.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(115), kw_column, int(6), kw_end_DASH_line, int(115), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed5, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed5, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_s = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_s.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// size?
	{
		tmp0 := sym_size_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(95), kw_column, int(7), kw_end_DASH_line, int(95), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if file size > 0"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						tmp10 := checkDerefVar(var_clojure_DOT_core__GT_)
						tmp11, ok := lang.FieldOrMethod(v9, "Size")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Size")))
						}
						var tmp12 any
						switch reflect.TypeOf(tmp11).Kind() {
						case reflect.Func:
							tmp12 = lang.Apply(tmp11, nil)
						default:
							tmp12 = tmp11
						}
						tmp13 := lang.Apply(tmp10, []any{tmp12, int64(0)})
						tmp8 = tmp13
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_size_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_size_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// touch
	{
		tmp0 := sym_touch.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(271), kw_column, int(7), kw_end_DASH_line, int(271), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Update file timestamp or create if doesn't exist"
			var tmp3 any
			tmp4 := checkDerefVar(var_ys_DOT_fs_exists_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "now"
					tmp7 := lang.Apply(time6.Now, nil)
					var v8 any = tmp7
					_ = v8
					tmp9 := lang.Apply(os5.Chtimes, []any{v2, v8, v8})
					tmp6 = tmp9
				} // end let
				tmp3 = tmp6
			} else {
				var tmp7 any
				{ // let
					// let binding "vec__50"
					tmp8 := lang.Apply(os5.Create, []any{v2})
					var v9 any = tmp8
					_ = v9
					// let binding "f"
					tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp11 := lang.Apply(tmp10, []any{v9, int64(0), nil})
					var v12 any = tmp11
					_ = v12
					// let binding "err"
					tmp13 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp14 := lang.Apply(tmp13, []any{v9, int64(1), nil})
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					tmp17 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
					tmp18 := lang.Apply(tmp17, []any{v15})
					if lang.IsTruthy(tmp18) {
						tmp19, ok := lang.FieldOrMethod(v12, "Close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Close")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp16 = tmp20
					} else {
					}
					tmp7 = tmp16
				} // end let
				tmp3 = tmp7
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_touch = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_touch.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// w
	{
		tmp0 := sym_w.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(116), kw_column, int(6), kw_end_DASH_line, int(116), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed6, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed6, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_w = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_w.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-str
	{
		tmp0 := sym_when_DASH_str.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(8), kw_column, int(8), kw_end_DASH_line, int(8), kw_end_DASH_column, int(15), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Convert to string or return nil"
			var tmp3 any
			if lang.IsTruthy(v2) {
				tmp4 := checkDerefVar(var_clojure_DOT_core_str)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp3 = tmp5
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_when_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_when_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// which
	{
		tmp0 := sym_which.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(210), kw_column, int(7), kw_end_DASH_line, int(210), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_name)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "Find executable in PATH"
			var tmp3 any
			{ // let
				// let binding "vec__38"
				tmp4 := lang.Apply(exec7.LookPath, []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "result"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v8
				} else {
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_which = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_which.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// write?
	{
		tmp0 := sym_write_QMARK_.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(101), kw_column, int(7), kw_end_DASH_line, int(101), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			_ = "True if path is writable"
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_ys_DOT_fs_get_DASH_file_DASH_info)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "info"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "mode"
							tmp11, ok := lang.FieldOrMethod(v9, "Mode")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Mode")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							var v13 any = tmp12
							_ = v13
							// let binding "write-bits"
							tmp14 := checkDerefVar(var_clojure_DOT_core_bit_DASH_and)
							tmp15 := lang.Apply(tmp14, []any{v13, int64(146)})
							var v16 any = tmp15
							_ = v16
							tmp17 := checkDerefVar(var_clojure_DOT_core_not)
							tmp18 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
							tmp19 := lang.Apply(tmp18, []any{v16})
							tmp20 := lang.Apply(tmp17, []any{tmp19})
							tmp10 = tmp20
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = false
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_ys_DOT_fs_write_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_write_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// x
	{
		tmp0 := sym_x.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(117), kw_column, int(6), kw_end_DASH_line, int(117), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed7, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed7, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_x = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_x.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// z
	{
		tmp0 := sym_z.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(118), kw_column, int(6), kw_end_DASH_line, int(118), kw_end_DASH_column, int(6), kw_ns, lang.FindOrCreateNamespace(sym_ys_DOT_fs))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp5 := checkDerefVar(var_clojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{int64(1), tmp6})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10 := lang.Apply(closed8, []any{tmp9})
					tmp3 = tmp10
				} else {
					tmp11 := checkDerefVar(var_clojure_DOT_core_map)
					tmp12 := lang.Apply(tmp11, []any{closed8, v2})
					tmp3 = tmp12
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "ys/fs.glj", kw_line, int(14), kw_column, int(3), kw_end_DASH_line, int(17), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var_ys_DOT_fs_z = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_ys_DOT_fs_z.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}
