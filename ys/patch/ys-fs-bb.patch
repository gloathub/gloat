--- ys/src/ys/fs.clj	2026-02-10 07:58:39.634210986 -0800
+++ ys/bb/ys/fs.clj	2026-02-10 08:04:06.958409369 -0800
@@ -1,14 +1,13 @@
 (ns ys.fs
-  (:require [clojure.string :as str]))
+  (:require
+    [babashka.fs :as fs]
+    [clojure.java.io :as io]
+    [clojure.string :as str]))
 
 ;;------------------------------------------------------------------------------
 ;; Helper functions
 ;;------------------------------------------------------------------------------
 
-(defn- when-str [x]
-  "Convert to string or return nil"
-  (when x (str x)))
-
 (defn- multi [f]
   "Wrap single-path function to support multiple paths"
   (fn [& paths]
@@ -16,95 +15,56 @@
       (f (first paths))
       (map f paths))))
 
-(defn- get-file-info [path]
-  "Get os.FileInfo for path, returns nil on error"
-  (try
-    (let [[info err] (os.Stat path)]
-      (when (nil? err) info))
-    (catch Exception _ nil)))
-
-(defn- get-link-info [path]
-  "Get os.FileInfo for symlink (don't follow), returns nil on error"
-  (try
-    (let [[info err] (os.Lstat path)]
-      (when (nil? err) info))
-    (catch Exception _ nil)))
-
 ;;------------------------------------------------------------------------------
 ;; Predicate functions (single char aliases: d e f l r s w x z)
 ;;------------------------------------------------------------------------------
 
 (defn abs? [path]
   "True if path is absolute"
-  (path:filepath.IsAbs path))
+  (fs/absolute? path))
 
 (defn dir? [path]
   "True if path is a directory"
-  (if-let [info (get-file-info path)]
-    (.IsDir info)
-    false))
+  (fs/directory? path))
 
 (defn empty? [path]
   "True if file size is 0 or directory is empty"
-  (if-let [info (get-file-info path)]
-    (if (.IsDir info)
-      (let [entries (os.ReadDir path)]
-        (zero? (count entries)))
-      (zero? (.Size info)))
-    false))
+  (cond
+    (fs/directory? path) (clojure.core/empty? (fs/list-dir path))
+    (fs/regular-file? path) (zero? (fs/size path))
+    :else false))
 
 (defn exec? [path]
   "True if path is executable"
-  (if-let [info (get-file-info path)]
-    (let [mode (.Mode info)
-          exec-bits (bit-and mode 0111)]
-      (not (zero? exec-bits)))
-    false))
+  (fs/executable? path))
 
 (defn exists? [path]
   "True if path exists"
-  (not (nil? (get-file-info path))))
+  (fs/exists? path))
 
 (defn file? [path]
   "True if path is a regular file"
-  (if-let [info (get-file-info path)]
-    (let [mode (.Mode info)]
-      (.IsRegular mode))
-    false))
+  (fs/regular-file? path))
 
 (defn link? [path]
   "True if path is a symbolic link"
-  (if-let [info (get-link-info path)]
-    (let [mode (.Mode info)
-          link-bit (bit-and mode os.ModeSymlink)]
-      (not (zero? link-bit)))
-    false))
+  (fs/sym-link? path))
 
 (defn read? [path]
   "True if path is readable"
-  (if-let [info (get-file-info path)]
-    (let [mode (.Mode info)
-          read-bits (bit-and mode 0444)]
-      (not (zero? read-bits)))
-    false))
+  (fs/readable? path))
 
 (defn rel? [path]
   "True if path is relative"
-  (not (path:filepath.IsAbs path)))
+  (fs/relative? path))
 
 (defn size? [path]
   "True if file size > 0"
-  (if-let [info (get-file-info path)]
-    (> (.Size info) 0)
-    false))
+  (and (fs/exists? path) (> (fs/size path) 0)))
 
 (defn write? [path]
   "True if path is writable"
-  (if-let [info (get-file-info path)]
-    (let [mode (.Mode info)
-          write-bits (bit-and mode 0222)]
-      (not (zero? write-bits)))
-    false))
+  (fs/writable? path))
 
 ;; Single-char aliases
 (def d (multi dir?))
@@ -123,94 +83,72 @@
 
 (defn abs [path]
   "Return absolute path"
-  (let [[result err] (path:filepath.Abs path)]
-    (if (nil? err) result path)))
+  (str (fs/absolutize path)))
 
 (defn basename [path]
   "Return basename of path (follows symlinks)"
-  (let [[real-path err] (path:filepath.EvalSymlinks path)]
-    (path:filepath.Base (if (nil? err) real-path path))))
+  (str (fs/file-name (fs/canonicalize path))))
 
 (defn ctime [path]
   "Return creation time in milliseconds (same as mtime in Unix)"
-  (if-let [info (get-file-info path)]
-    (.UnixMilli (.ModTime info))
-    nil))
+  (when (fs/exists? path)
+    (.toMillis (fs/creation-time path))))
 
 (defn mtime [path]
   "Return modification time in milliseconds"
-  (if-let [info (get-file-info path)]
-    (.UnixMilli (.ModTime info))
-    nil))
+  (when (fs/exists? path)
+    (.toMillis (fs/last-modified-time path))))
 
 (defn cwd []
   "Return current working directory"
-  (let [[result err] (os.Getwd)]
-    (if (nil? err) result ".")))
+  (str (fs/cwd)))
 
 (defn dirname [path]
   "Return directory name of path (follows symlinks)"
-  (let [[real-path err] (path:filepath.EvalSymlinks path)]
-    (path:filepath.Dir (if (nil? err) real-path path))))
+  (str (fs/parent (fs/canonicalize path))))
 
 (defn filename [path]
   "Return filename without extension"
-  (let [base (path:filepath.Base path)
-        ext (path:filepath.Ext base)]
+  (let [base (str (fs/file-name path))
+        ext (fs/extension path)]
     (if (str/blank? ext)
       base
       (subs base 0 (- (count base) (count ext))))))
 
 (defn find [path & patterns]
   "Walk directory tree and return matching paths"
-  (let [results (atom [])]
-    (path:filepath.Walk
-      path
-      (fn [p info err]
-        (when (nil? err)
-          (if (empty? patterns)
-            (swap! results conj p)
-            (doseq [pattern patterns]
-              (when (str/includes? p pattern)
-                (swap! results conj p)))))
-        nil))
-    @results))
+  (let [all-files (map str (file-seq (io/file path)))]
+    (if (clojure.core/empty? patterns)
+      all-files
+      (filter (fn [p]
+                (some #(str/includes? p %) patterns))
+              all-files))))
 
 (defn glob [pattern]
   "Return paths matching glob pattern"
-  (let [[result err] (path:filepath.Glob pattern)]
-    (if (nil? err) result [])))
+  (mapv str (fs/glob "." pattern)))
 
 (defn ls [path]
   "List directory contents"
-  (let [[entries err] (os.ReadDir path)]
-    (if (nil? err)
-      (loop [i 0, n (count entries), result []]
-        (if (< i n)
-          (recur (inc i) n (conj result (.Name (nth entries i))))
-          result))
-      [])))
+  (mapv #(str (fs/file-name %)) (fs/list-dir path)))
 
 (defn path [p]
   "Return canonical path (follows symlinks)"
-  (let [[result err] (path:filepath.EvalSymlinks p)]
-    (if (nil? err) result p)))
+  (str (fs/canonicalize p)))
 
 (defn readlink [path]
   "Read symbolic link target"
-  (let [[result err] (os.Readlink path)]
-    (if (nil? err) result nil)))
+  (when (fs/sym-link? path)
+    (str (fs/read-link path))))
 
 (defn rel [path]
   "Return path relative to current directory"
-  (let [cwd-path (cwd)
-        [result err] (path:filepath.Rel cwd-path path)]
-    (if (nil? err) result path)))
+  (str (fs/relativize (fs/cwd) path)))
 
 (defn which [name]
   "Find executable in PATH"
-  (let [[result err] (os:exec.LookPath name)]
-    (if (nil? err) result nil)))
+  (when-let [result (fs/which name)]
+    (str result)))
 
 ;;------------------------------------------------------------------------------
 ;; File operation functions
@@ -218,79 +156,70 @@
 
 (defn cp [src dst]
   "Copy file from src to dst"
-  (let [[content err] (os.ReadFile src)]
-    (when (nil? err)
-      (os.WriteFile dst content 0644))))
+  (fs/copy src dst {:replace-existing true})
+  nil)
 
 (defn cp-r [src dst]
   "Recursively copy directory"
-  (path:filepath.Walk
-    src
-    (fn [p info err]
-      (when (nil? err)
-        (let [[rel-path _] (path:filepath.Rel src p)
-              dst-path (path:filepath.Join dst rel-path)]
-          (if (.IsDir info)
-            (os.MkdirAll dst-path 0755)
-            (let [[content read-err] (os.ReadFile p)]
-              (when (nil? read-err)
-                (os.WriteFile dst-path content (.Mode info)))))))
-      nil))
+  (fs/copy-tree src dst {:replace-existing true})
   nil)
 
 (defn mkdir [path]
   "Create directory"
-  (os.Mkdir path 0755))
+  (fs/create-dir path)
+  nil)
 
 (defn mkdir-p [path]
   "Create directory and parents"
-  (os.MkdirAll path 0755))
+  (fs/create-dirs path)
+  nil)
 
 (defn mv [src dst]
   "Move/rename file or directory"
-  (os.Rename src dst))
+  (fs/move src dst {:replace-existing true})
+  nil)
 
 (defn rm [path]
   "Remove file or empty directory"
-  (os.Remove path))
+  (fs/delete path)
+  nil)
 
 (defn rm-f [path]
   "Remove file, ignore errors"
-  (try
-    (os.Remove path)
-    (catch Exception _ nil)))
+  (fs/delete-if-exists path)
+  nil)
 
 (defn rm-r [path]
   "Remove directory recursively"
-  (os.RemoveAll path))
+  (fs/delete-tree path)
+  nil)
 
 (defn rmdir [path]
   "Remove empty directory"
-  (os.Remove path))
+  (fs/delete path)
+  nil)
 
 (defn touch [path]
   "Update file timestamp or create if doesn't exist"
-  (if (exists? path)
-    (let [now (time.Now)]
-      (os.Chtimes path now now))
-    (let [[f err] (os.Create path)]
-      (when (nil? err)
-        (.Close f)))))
+  (if (fs/exists? path)
+    (fs/set-last-modified-time path (java.time.Instant/now))
+    (spit path ""))
+  nil)
 
 (defn mktemp
   "Create temporary file and return path"
-  ([] (mktemp "" "ys-"))
-  ([prefix] (mktemp "" prefix))
+  ([] (mktemp "ys-"))
+  ([prefix] (mktemp nil prefix))
   ([dir prefix]
-    (let [[f err] (os.CreateTemp dir prefix)]
-      (when (nil? err)
-        (.Close f)
-        (str (.Name f))))))
+    (let [opts (cond-> {:prefix prefix}
+                 dir (assoc :dir dir))]
+      (str (fs/create-temp-file opts)))))
 
 (defn mktemp-d
   "Create temporary directory and return path"
-  ([] (mktemp-d "" "ys-"))
-  ([prefix] (mktemp-d "" prefix))
+  ([] (mktemp-d "ys-"))
+  ([prefix] (mktemp-d nil prefix))
   ([dir prefix]
-    (let [[path err] (os.MkdirTemp dir prefix)]
-      (when (nil? err) path))))
+    (let [opts (cond-> {:prefix prefix}
+                 dir (assoc :dir dir))]
+      (str (fs/create-temp-dir opts)))))
