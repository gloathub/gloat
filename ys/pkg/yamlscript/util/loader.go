// Code generated by glojure codegen. DO NOT EDIT.

package util

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("yamlscript/util", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "yamlscript.util"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__STAR_err_STAR_ := lang.NewSymbol("*err*")
	sym__STAR_out_STAR_ := lang.NewSymbol("*out*")
	sym_apply := lang.NewSymbol("apply")
	sym_atom_QMARK_ := lang.NewSymbol("atom?")
	sym_bindings := lang.NewSymbol("bindings")
	sym_body := lang.NewSymbol("body")
	sym_clauses := lang.NewSymbol("clauses")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH_condp := lang.NewSymbol("clojure.core/condp")
	sym_clojure_DOT_core_SLASH_fn := lang.NewSymbol("clojure.core/fn")
	sym_clojure_DOT_core_SLASH_if_DASH_let := lang.NewSymbol("clojure.core/if-let")
	sym_clojure_DOT_core_SLASH_when_DASH_let := lang.NewSymbol("clojure.core/when-let")
	sym_concat := lang.NewSymbol("concat")
	sym_cond_DASH_lets := lang.NewSymbol("cond-lets")
	sym_condf := lang.NewSymbol("condf")
	sym_die := lang.NewSymbol("die")
	sym_do := lang.NewSymbol("do")
	sym_drop := lang.NewSymbol("drop")
	sym_else := lang.NewSymbol("else")
	sym_eprint := lang.NewSymbol("eprint")
	sym_eprintln := lang.NewSymbol("eprintln")
	sym_f__0__auto__ := lang.NewSymbol("f__0__auto__")
	sym_first := lang.NewSymbol("first")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_if_DASH_lets := lang.NewSymbol("if-lets")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_list := lang.NewSymbol("list")
	sym_list_QMARK_ := lang.NewSymbol("list?")
	sym_macro_QMARK_ := lang.NewSymbol("macro?")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_meta := lang.NewSymbol("meta")
	sym_msg := lang.NewSymbol("msg")
	sym_next := lang.NewSymbol("next")
	sym_nnext := lang.NewSymbol("nnext")
	sym_pop_DASH_thread_DASH_bindings := lang.NewSymbol("pop-thread-bindings")
	sym_print := lang.NewSymbol("print")
	sym_println := lang.NewSymbol("println")
	sym_push_DASH_thread_DASH_bindings := lang.NewSymbol("push-thread-bindings")
	sym_resolve := lang.NewSymbol("resolve")
	sym_second := lang.NewSymbol("second")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_set_QMARK_ := lang.NewSymbol("set?")
	sym_str := lang.NewSymbol("str")
	sym_symbol_QMARK_ := lang.NewSymbol("symbol?")
	sym_then := lang.NewSymbol("then")
	sym_type := lang.NewSymbol("type")
	sym_type_DASH_name := lang.NewSymbol("type-name")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_when_DASH_lets := lang.NewSymbol("when-lets")
	sym_x := lang.NewSymbol("x")
	sym_x__1__auto__ := lang.NewSymbol("x__1__auto__")
	sym_xs := lang.NewSymbol("xs")
	sym_yamlscript_DOT_util := lang.NewSymbol("yamlscript.util")
	sym_yamlscript_DOT_util_SLASH_cond_DASH_lets := lang.NewSymbol("yamlscript.util/cond-lets")
	sym_yamlscript_DOT_util_SLASH_if_DASH_lets := lang.NewSymbol("yamlscript.util/if-lets")
	sym_yamlscript_DOT_util_SLASH_when_DASH_lets := lang.NewSymbol("yamlscript.util/when-lets")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	kw_style_SLASH_indent := lang.NewKeyword("style/indent")
	// var clojure.core/*err*
	var_clojure_DOT_core__STAR_err_STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_err_STAR_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/drop
	var_clojure_DOT_core_drop := lang.InternVarName(sym_clojure_DOT_core, sym_drop)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/hash-map
	var_clojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_clojure_DOT_core, sym_hash_DASH_map)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/list?
	var_clojure_DOT_core_list_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_list_QMARK_)
	// var clojure.core/map?
	var_clojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_map_QMARK_)
	// var clojure.core/meta
	var_clojure_DOT_core_meta := lang.InternVarName(sym_clojure_DOT_core, sym_meta)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/nnext
	var_clojure_DOT_core_nnext := lang.InternVarName(sym_clojure_DOT_core, sym_nnext)
	// var clojure.core/pop-thread-bindings
	var_clojure_DOT_core_pop_DASH_thread_DASH_bindings := lang.InternVarName(sym_clojure_DOT_core, sym_pop_DASH_thread_DASH_bindings)
	// var clojure.core/print
	var_clojure_DOT_core_print := lang.InternVarName(sym_clojure_DOT_core, sym_print)
	// var clojure.core/println
	var_clojure_DOT_core_println := lang.InternVarName(sym_clojure_DOT_core, sym_println)
	// var clojure.core/push-thread-bindings
	var_clojure_DOT_core_push_DASH_thread_DASH_bindings := lang.InternVarName(sym_clojure_DOT_core, sym_push_DASH_thread_DASH_bindings)
	// var clojure.core/resolve
	var_clojure_DOT_core_resolve := lang.InternVarName(sym_clojure_DOT_core, sym_resolve)
	// var clojure.core/second
	var_clojure_DOT_core_second := lang.InternVarName(sym_clojure_DOT_core, sym_second)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/seq?
	var_clojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seq_QMARK_)
	// var clojure.core/set?
	var_clojure_DOT_core_set_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_set_QMARK_)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/symbol?
	var_clojure_DOT_core_symbol_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_symbol_QMARK_)
	// var clojure.core/type
	var_clojure_DOT_core_type := lang.InternVarName(sym_clojure_DOT_core, sym_type)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/vector?
	var_clojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_vector_QMARK_)
	// var yamlscript.util/atom?
	var_yamlscript_DOT_util_atom_QMARK_ := lang.InternVarName(sym_yamlscript_DOT_util, sym_atom_QMARK_)
	// var yamlscript.util/cond-lets
	var_yamlscript_DOT_util_cond_DASH_lets := lang.InternVarName(sym_yamlscript_DOT_util, sym_cond_DASH_lets)
	// var yamlscript.util/condf
	var_yamlscript_DOT_util_condf := lang.InternVarName(sym_yamlscript_DOT_util, sym_condf)
	// var yamlscript.util/die
	var_yamlscript_DOT_util_die := lang.InternVarName(sym_yamlscript_DOT_util, sym_die)
	// var yamlscript.util/eprint
	var_yamlscript_DOT_util_eprint := lang.InternVarName(sym_yamlscript_DOT_util, sym_eprint)
	// var yamlscript.util/eprintln
	var_yamlscript_DOT_util_eprintln := lang.InternVarName(sym_yamlscript_DOT_util, sym_eprintln)
	// var yamlscript.util/if-lets
	var_yamlscript_DOT_util_if_DASH_lets := lang.InternVarName(sym_yamlscript_DOT_util, sym_if_DASH_lets)
	// var yamlscript.util/macro?
	var_yamlscript_DOT_util_macro_QMARK_ := lang.InternVarName(sym_yamlscript_DOT_util, sym_macro_QMARK_)
	// var yamlscript.util/type-name
	var_yamlscript_DOT_util_type_DASH_name := lang.InternVarName(sym_yamlscript_DOT_util, sym_type_DASH_name)
	// var yamlscript.util/when-lets
	var_yamlscript_DOT_util_when_DASH_lets := lang.InternVarName(sym_yamlscript_DOT_util, sym_when_DASH_lets)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_yamlscript_DOT_util)
	_ = ns
	// atom?
	{
		tmp0 := sym_atom_QMARK_.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(6), kw_column, int(7), kw_end_DASH_line, int(6), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is an Atom", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_atom_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_atom_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond-lets
	{
		tmp0 := sym_cond_DASH_lets.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_clauses)), kw_doc, "Like cond-let but with more than one binding", kw_file, "yamlscript/util.glj", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(23), kw_end_DASH_line, int(23), kw_style_SLASH_indent, lang.NewVector(int64(0)))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v4) {
					tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp8 := checkDerefVar(var_clojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_yamlscript_DOT_util_SLASH_if_DASH_lets})
					tmp10 := checkDerefVar(var_clojure_DOT_core_list)
					tmp11 := checkDerefVar(var_clojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp13 := lang.Apply(tmp10, []any{tmp12})
					tmp14 := checkDerefVar(var_clojure_DOT_core_list)
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core_next)
					tmp17 := lang.Apply(tmp16, []any{v4})
					if lang.IsTruthy(tmp17) {
						tmp18 := checkDerefVar(var_clojure_DOT_core_second)
						tmp19 := lang.Apply(tmp18, []any{v4})
						tmp15 = tmp19
					} else {
						tmp20 := checkDerefVar(var_yamlscript_DOT_util_die)
						tmp21 := lang.Apply(tmp20, []any{"Odd number of forms"})
						tmp15 = tmp21
					}
					tmp22 := lang.Apply(tmp14, []any{tmp15})
					tmp23 := checkDerefVar(var_clojure_DOT_core_list)
					tmp24 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp25 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp26 := checkDerefVar(var_clojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{sym_yamlscript_DOT_util_SLASH_cond_DASH_lets})
					tmp28 := checkDerefVar(var_clojure_DOT_core_nnext)
					tmp29 := lang.Apply(tmp28, []any{v4})
					tmp30 := lang.Apply(tmp25, []any{tmp27, tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp30})
					tmp32 := lang.Apply(tmp23, []any{tmp31})
					tmp33 := lang.Apply(tmp7, []any{tmp9, tmp13, tmp22, tmp32})
					tmp34 := lang.Apply(tmp6, []any{tmp33})
					tmp5 = tmp34
				} else {
				}
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_cond_DASH_lets = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_cond_DASH_lets.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// condf
	{
		tmp0 := sym_condf.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_clauses)), kw_doc, "Like condp but with a function", kw_file, "yamlscript/util.glj", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(18), kw_end_DASH_line, int(18))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_condp})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_clojure_DOT_core_SLASH_fn})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_f__0__auto__})
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_x__1__auto__})
				tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
				tmp25 := lang.Apply(tmp18, []any{tmp24})
				tmp26 := lang.Apply(tmp16, []any{tmp17, tmp25})
				tmp27 := lang.Apply(tmp15, []any{tmp26})
				tmp28 := checkDerefVar(var_clojure_DOT_core_list)
				tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp30 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp31 := checkDerefVar(var_clojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{sym_f__0__auto__})
				tmp33 := checkDerefVar(var_clojure_DOT_core_list)
				tmp34 := lang.Apply(tmp33, []any{sym_x__1__auto__})
				tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
				tmp36 := lang.Apply(tmp29, []any{tmp35})
				tmp37 := lang.Apply(tmp28, []any{tmp36})
				tmp38 := lang.Apply(tmp12, []any{tmp14, tmp27, tmp37})
				tmp39 := lang.Apply(tmp11, []any{tmp38})
				tmp40 := lang.Apply(tmp10, []any{tmp39})
				tmp41 := checkDerefVar(var_clojure_DOT_core_list)
				tmp42 := lang.Apply(tmp41, []any{v4})
				tmp43 := lang.Apply(tmp7, []any{tmp9, tmp40, tmp42, v5})
				tmp44 := lang.Apply(tmp6, []any{tmp43})
				return tmp44
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_condf = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_condf.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// die
	{
		tmp0 := sym_die.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(12), kw_column, int(7), kw_end_DASH_line, int(12), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_msg), lang.NewVector(sym_x, sym__AMP_, sym_xs)), kw_doc, "Throw a string as an exception", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.Apply(lang.NewError, []any{"Died"})
				panic(tmp2)
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_str)
				tmp4 := lang.Apply(tmp3, []any{v2, "\n"})
				tmp5 := lang.Apply(lang.NewError, []any{tmp4})
				panic(tmp5)
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				tmp4 := checkDerefVar(var_yamlscript_DOT_util_die)
				tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_clojure_DOT_core_str)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3})
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_die = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_die.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eprint
	{
		tmp0 := sym_eprint.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(34), kw_column, int(7), kw_end_DASH_line, int(34), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "Print to stderr", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					tmp4 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp5 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
					tmp6 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
					tmp7 := checkDerefVar(var_clojure_DOT_core__STAR_err_STAR_)
					tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7})
					tmp9 := lang.Apply(tmp4, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp14 := checkDerefVar(var_clojure_DOT_core_print)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
						tmp10 = tmp15
					}()
					tmp3 = tmp10
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_eprint = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_eprint.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eprintln
	{
		tmp0 := sym_eprintln.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(40), kw_column, int(7), kw_end_DASH_line, int(40), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "Print to stderr with a newline", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					tmp4 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp5 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
					tmp6 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
					tmp7 := checkDerefVar(var_clojure_DOT_core__STAR_err_STAR_)
					tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7})
					tmp9 := lang.Apply(tmp4, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp14 := checkDerefVar(var_clojure_DOT_core_println)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
						tmp10 = tmp15
					}()
					tmp3 = tmp10
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_eprintln = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_eprintln.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-lets
	{
		tmp0 := sym_if_DASH_lets.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym_then), lang.NewVector(sym_bindings, sym_then, sym_else)), kw_doc, "Like if-let but with more than one binding", kw_file, "yamlscript/util.glj", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(46), kw_end_DASH_line, int(46))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_yamlscript_DOT_util_SLASH_if_DASH_lets})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_clojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{nil})
				tmp16 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13, tmp15})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				return tmp17
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp11 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp12 := checkDerefVar(var_clojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_clojure_DOT_core_SLASH_if_DASH_let})
					tmp14 := checkDerefVar(var_clojure_DOT_core_list)
					tmp15 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp19 := checkDerefVar(var_clojure_DOT_core_list)
					tmp20 := checkDerefVar(var_clojure_DOT_core_first)
					tmp21 := lang.Apply(tmp20, []any{v4})
					tmp22 := lang.Apply(tmp19, []any{tmp21})
					tmp23 := checkDerefVar(var_clojure_DOT_core_list)
					tmp24 := checkDerefVar(var_clojure_DOT_core_second)
					tmp25 := lang.Apply(tmp24, []any{v4})
					tmp26 := lang.Apply(tmp23, []any{tmp25})
					tmp27 := lang.Apply(tmp18, []any{tmp22, tmp26})
					tmp28 := lang.Apply(tmp17, []any{tmp27})
					tmp29 := lang.Apply(tmp15, []any{tmp16, tmp28})
					tmp30 := lang.Apply(tmp14, []any{tmp29})
					tmp31 := checkDerefVar(var_clojure_DOT_core_list)
					tmp32 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp33 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp34 := checkDerefVar(var_clojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{sym_yamlscript_DOT_util_SLASH_if_DASH_lets})
					tmp36 := checkDerefVar(var_clojure_DOT_core_list)
					tmp37 := checkDerefVar(var_clojure_DOT_core_drop)
					tmp38 := lang.Apply(tmp37, []any{int64(2), v4})
					tmp39 := lang.Apply(tmp36, []any{tmp38})
					tmp40 := checkDerefVar(var_clojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{v5})
					tmp42 := checkDerefVar(var_clojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{v6})
					tmp44 := lang.Apply(tmp33, []any{tmp35, tmp39, tmp41, tmp43})
					tmp45 := lang.Apply(tmp32, []any{tmp44})
					tmp46 := lang.Apply(tmp31, []any{tmp45})
					tmp47 := checkDerefVar(var_clojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{v6})
					tmp49 := lang.Apply(tmp11, []any{tmp13, tmp30, tmp46, tmp48})
					tmp50 := lang.Apply(tmp10, []any{tmp49})
					tmp7 = tmp50
				} else {
					tmp7 = v5
				}
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_if_DASH_lets = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_if_DASH_lets.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macro?
	{
		tmp0 := sym_macro_QMARK_.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(57), kw_column, int(7), kw_end_DASH_line, int(57), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Check if a symbol is a macro", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_clojure_DOT_core_symbol_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := checkDerefVar(var_clojure_DOT_core_resolve)
						tmp10 := lang.Apply(tmp9, []any{v2})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "x"
								var v14 any = v11
								_ = v14
								tmp15 := checkDerefVar(var_clojure_DOT_core_meta)
								tmp16 := lang.Apply(tmp15, []any{v14})
								tmp17 := lang.Apply(kw_macro, []any{tmp16})
								tmp13 = tmp17
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp8 = tmp12
					} // end let
					tmp7 = tmp8
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_macro_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_macro_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// type-name
	{
		tmp0 := sym_type_DASH_name.WithMeta(lang.NewMap(kw_file, "yamlscript/util.glj", kw_line, int(65), kw_column, int(7), kw_end_DASH_line, int(65), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Get the name of a type", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pred__1"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.Apply(v5, []any{v6})
					return tmp7
				})
				var v5 any = tmp4
				_ = v5
				// let binding "expr__2"
				var v6 any = v2
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
				tmp9 := lang.Apply(v5, []any{tmp8, v6})
				if lang.IsTruthy(tmp9) {
					tmp7 = "Map"
				} else {
					var tmp10 any
					tmp11 := checkDerefVar(var_clojure_DOT_core_set_QMARK_)
					tmp12 := lang.Apply(v5, []any{tmp11, v6})
					if lang.IsTruthy(tmp12) {
						tmp10 = "Set"
					} else {
						var tmp13 any
						tmp14 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
						tmp15 := lang.Apply(v5, []any{tmp14, v6})
						if lang.IsTruthy(tmp15) {
							tmp13 = "Vector"
						} else {
							var tmp16 any
							tmp17 := checkDerefVar(var_clojure_DOT_core_list_QMARK_)
							tmp18 := lang.Apply(v5, []any{tmp17, v6})
							if lang.IsTruthy(tmp18) {
								tmp16 = "List"
							} else {
								var tmp19 any
								tmp20 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
								tmp21 := lang.Apply(v5, []any{tmp20, v6})
								if lang.IsTruthy(tmp21) {
									tmp19 = "Seq"
								} else {
									tmp22 := checkDerefVar(var_clojure_DOT_core_type)
									tmp23 := lang.Apply(tmp22, []any{v2})
									tmp19 = tmp23
								}
								tmp16 = tmp19
							}
							tmp13 = tmp16
						}
						tmp10 = tmp13
					}
					tmp7 = tmp10
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_type_DASH_name = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_type_DASH_name.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-lets
	{
		tmp0 := sym_when_DASH_lets.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "Like when-let but with more than one binding", kw_file, "yamlscript/util.glj", kw_ns, lang.FindOrCreateNamespace(sym_yamlscript_DOT_util), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(76), kw_end_DASH_line, int(76))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp10 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp11 := checkDerefVar(var_clojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_clojure_DOT_core_SLASH_when_DASH_let})
					tmp13 := checkDerefVar(var_clojure_DOT_core_list)
					tmp14 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp15 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp16 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp17 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp18 := checkDerefVar(var_clojure_DOT_core_list)
					tmp19 := checkDerefVar(var_clojure_DOT_core_first)
					tmp20 := lang.Apply(tmp19, []any{v4})
					tmp21 := lang.Apply(tmp18, []any{tmp20})
					tmp22 := checkDerefVar(var_clojure_DOT_core_list)
					tmp23 := checkDerefVar(var_clojure_DOT_core_second)
					tmp24 := lang.Apply(tmp23, []any{v4})
					tmp25 := lang.Apply(tmp22, []any{tmp24})
					tmp26 := lang.Apply(tmp17, []any{tmp21, tmp25})
					tmp27 := lang.Apply(tmp16, []any{tmp26})
					tmp28 := lang.Apply(tmp14, []any{tmp15, tmp27})
					tmp29 := lang.Apply(tmp13, []any{tmp28})
					tmp30 := checkDerefVar(var_clojure_DOT_core_list)
					tmp31 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp32 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp33 := checkDerefVar(var_clojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{sym_yamlscript_DOT_util_SLASH_when_DASH_lets})
					tmp35 := checkDerefVar(var_clojure_DOT_core_list)
					tmp36 := checkDerefVar(var_clojure_DOT_core_drop)
					tmp37 := lang.Apply(tmp36, []any{int64(2), v4})
					tmp38 := lang.Apply(tmp35, []any{tmp37})
					tmp39 := lang.Apply(tmp32, []any{tmp34, tmp38, v5})
					tmp40 := lang.Apply(tmp31, []any{tmp39})
					tmp41 := lang.Apply(tmp30, []any{tmp40})
					tmp42 := lang.Apply(tmp10, []any{tmp12, tmp29, tmp41})
					tmp43 := lang.Apply(tmp9, []any{tmp42})
					tmp6 = tmp43
				} else {
					tmp44 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp45 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp46 := checkDerefVar(var_clojure_DOT_core_list)
					tmp47 := lang.Apply(tmp46, []any{sym_do})
					tmp48 := lang.Apply(tmp45, []any{tmp47, v5})
					tmp49 := lang.Apply(tmp44, []any{tmp48})
					tmp6 = tmp49
				}
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_yamlscript_DOT_util_when_DASH_lets = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_yamlscript_DOT_util_when_DASH_lets.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Override seqable? to fix broken Java interop in upstream Glojure.
	// The upstream core.glj defines seqable? as (clojure.lang.RT/canSeq x)
	// which compiles to lang.Apply(nil, ...) and panics at runtime.
	{
		seqableNs := lang.FindOrCreateNamespace(lang.NewSymbol("clojure.core"))
		seqableSym := lang.NewSymbol("seqable?").WithMeta(
			lang.NewMap(
				lang.NewKeyword("doc"),
				"Return true if the seq function is supported for x",
			)).(*lang.Symbol)
		seqableFn := lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			return lang.CanSeq(args[0])
		})
		seqableNs.InternWithValue(seqableSym, seqableFn, true)
	}
}
