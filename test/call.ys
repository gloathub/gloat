!ys-0

defn main(fun *args):
  case fun:
    # Mutating operations
    'fs/mkdir':
      apply fs/mkdir: args
    'fs/mkdir-p':
      apply fs/mkdir-p: args
    'fs/rmdir':
      fs/rmdir: args*
    'fs/touch':
      apply fs/touch: args
    'fs/cp':
      fs/cp: args.0 args.1
    'fs/mv':
      fs/mv: args.0 args.1
    'fs/rm':
      fs/rm: args*
    'fs/rm-r':
      fs/rm-r: args*
    'fs/rm-f':
      fs/rm-f: args*

    # Predicates
    'fs-e':
      say: fs-e(args.0):S
    'fs/exists?':
      say: fs/exists?(args.0):S
    'fs/dir?':
      say: fs/dir?(args.0):S
    'fs/file?':
      say: fs/file?(args.0):S

    # Path operations
    'fs/cwd':
      say: fs/cwd()
    'fs/abs':
      say: fs/abs(args.0)
    'fs/basename':
      say: fs/basename(args.0)
    'fs/dirname':
      say: fs/dirname(args.0)

    # Listing
    'fs/ls':
      say: join(fs/ls(args.0) "\n")

    # IPC: sh (direct exec) - field extraction
    'sh-exit':
      say: sh(args*).:exit
    'sh-stdout':
      say: trim(sh(args*).:out)
    'sh-stderr':
      say: trim(sh(args*).:err)

    # IPC: shell (via /bin/sh -c) - field extraction
    'shell-exit':
      say: shell(args*).:exit
    'shell-stdout':
      say: trim(shell(args*).:out)
    'shell-stderr':
      say: trim(shell(args*).:err)

    # IPC: string-returning wrappers
    'sh-out':
      say: sh-out(args*)
    'bash-out':
      say: bash-out(args*)

    # Global variables
    'env-home':
      say: ENV.HOME
    'env-path-len':
      say: len(ENV.PATH)
    'ns':
      say: str(NS)
    'cwd':
      say: CWD
    'file':
      say: FILE
    'dir':
      say: DIR
    'run-pid':
      say: RUN.pid
    'run-args-empty':
      say: RUN.args
    'run-args-with':
      say: RUN.args.rest()
    'argv-empty':
      say: ARGV
    'argv-with':
      say: ARGV.rest()
    'args-empty':
      say: ARGS
    'args-with':
      say: ARGS.rest()

    else:
      condp eq args.#:
        0: fun.call():say
        1: fun.call(args.0):say
        2: fun.call(args.0 args.1):say
